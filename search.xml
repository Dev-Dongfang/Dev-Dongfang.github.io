<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【算法】全排列/组合问题全解</title>
    <url>/posts/2020-09/8fysm.html</url>
    <content><![CDATA[<p>算法中的排列组合问题说难也不难，只要掌握排列组合的技巧，实际上所有相关的问题都会迎刃而解，本篇将循序渐进的破解排列组合问题中的经典算法。</p>
<a id="more"></a>

<p>首先先明确几个概念：</p>
<ul>
<li>组合：指从给定个数的元素中仅仅取出指定个数的元素，不考虑排序。</li>
<li><a href="[https://baike.baidu.com/item/%E5%85%A8%E6%8E%92%E5%88%97/4022220?fr=aladdin](https://baike.baidu.com/item/全排列/4022220?fr=aladdin)">全排列</a>：从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。</li>
<li><a href="[https://baike.baidu.com/item/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/9258495?fr=aladdin](https://baike.baidu.com/item/回溯算法/9258495?fr=aladdin)">回溯算法</a>：溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</li>
<li>递归算法：在计算机中指通过重复将大问题分解为同类型小问题，从而解决大问题的解法。</li>
</ul>
<h1 id="1-排列问题"><a href="#1-排列问题" class="headerlink" title="1.排列问题"></a>1.排列问题</h1><h2 id="问题1：给定一个没有重复数字的序列，返回其所有可能的全排列。"><a href="#问题1：给定一个没有重复数字的序列，返回其所有可能的全排列。" class="headerlink" title="问题1：给定一个没有重复数字的序列，返回其所有可能的全排列。"></a>问题1：给定一个没有重复数字的序列，返回其所有可能的全排列。</h2><p>分析：这个问题我们可以看成是为长度为n的数组填充数据的过程，我们循环遍历所有可能出现在第1位的数字，然后是可能出现在第二位的数字，以此类推，直到将整个数组填充完毕，得到的结果就是可能的一种排列，所有这些可能性组成的结果就是给定数组的全排列。</p>
<p>具体应该怎么控制这个过程呢？当我们填充第一位后，问题实际上变成了求2-n位的全排列，以此类推，直到最后一位。这种能够将大问题分解成相同类型的小问题，并且当问题足够小很容易求解的问题，用<strong>递归</strong>解决简直不要太爽！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">permute</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">        <span class="keyword">guard</span> nums.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [nums] &#125;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        <span class="keyword">var</span> nums = nums</span><br><span class="line">        alignment(res: &amp;res, arr: &amp;nums, loc: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">alignment</span><span class="params">(res: <span class="keyword">inout</span> [[Int]], arr: <span class="keyword">inout</span> [Int], loc: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> loc == arr.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> loc..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">            arr.swapAt(i, loc)</span><br><span class="line">            alignment(res: &amp;res, arr: &amp;arr, loc: loc + <span class="number">1</span>)</span><br><span class="line">            arr.swapAt(i, loc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在上述代码中，由于我们没有借助临时的数组来存放排列的结果，而是在原数组上采用了交换位置的方式，因此当我们每个深度搜索完毕后需要将对应位置的数据复原，这是使用回溯算法的原因。</p>
</blockquote>
<h2 id="问题2：给定一个可包含重复数字的序列，返回所有不重复的全排列。"><a href="#问题2：给定一个可包含重复数字的序列，返回所有不重复的全排列。" class="headerlink" title="问题2：给定一个可包含重复数字的序列，返回所有不重复的全排列。"></a>问题2：给定一个可<strong>包含重复数字</strong>的序列，返回所有不重复的全排列。</h2><p>如果给定的数组中存在重复的数字，问题1中的解法给出的结果中一定是包含重复序列的。例如给定序列中第三位和第四位都是5，在问题1中，第三位第四位的5分别放在第一位和第二位与放在第二位第一位是两个排列，但是事实上他们是完全相同的。如下图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200926001929.png" alt></p>
<p>那么如何才能得到不重复的结果呢？这里主要有两种方法。</p>
<ol>
<li><p><strong>Set去重。</strong>我们可以将每次排列的结果存放到一个Set集合中，利用Set集合的特性帮我们去重。</p>
</li>
<li><p><strong>排列中某一位出现相同值则略过。</strong>用Set集合或者哈希表统计某一位是否出现过某个数字。</p>
</li>
</ol>
<p>第二种方法的swift代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">permuteUnique</span><span class="params">(<span class="number">_</span> nums: [Int])</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">var</span> arr = nums</span><br><span class="line">        <span class="keyword">guard</span> arr.<span class="built_in">count</span> &gt; <span class="number">0</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line">        <span class="keyword">guard</span> arr.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [arr] &#125;</span><br><span class="line">        <span class="keyword">var</span> res = [[<span class="type">Int</span>]]()</span><br><span class="line">        alignment(res: &amp;res, arr: &amp;arr, loc: <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">alignment</span><span class="params">(res: <span class="keyword">inout</span> [[Int]], arr: <span class="keyword">inout</span> [Int], loc: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> loc == arr.<span class="built_in">count</span> - <span class="number">1</span> &#123;</span><br><span class="line">            res.append(arr)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">set</span> = <span class="type">Set</span>&lt;<span class="type">Int</span>&gt;()	<span class="comment">//set集合记录某个值是否使用过</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> loc..&lt;arr.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">set</span>.<span class="built_in">contains</span>(arr[i]) &#123;</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">set</span>.insert(arr[i])</span><br><span class="line">            </span><br><span class="line">            arr.swapAt(i, loc)</span><br><span class="line">            alignment(res: &amp;res, arr: &amp;arr, loc: loc + <span class="number">1</span>)</span><br><span class="line">            arr.swapAt(i, loc)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题3：给定两个整数-n-和-k，返回-1-…-n-中所有可能的-k-个数的排列。"><a href="#问题3：给定两个整数-n-和-k，返回-1-…-n-中所有可能的-k-个数的排列。" class="headerlink" title="问题3：给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的排列。"></a>问题3：给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的排列。</h2><p>问题3中组合是无序的，因此我们无需关心结果中数字顺序。假如题目要求我们给出k个数的排列，该怎么解决呢？</p>
<p>好办！还是全排列的解题思路，我们将已经使用的数字放置到数组的前部分，然后遍历后面的数字放在对应的目标数组中即可。</p>
<p>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func permutationAll(str: String) -&gt; [String] &#123;</span><br><span class="line">    guard str.count &gt; 1 else &#123; return [str] &#125;</span><br><span class="line"></span><br><span class="line">    var res = [String]()</span><br><span class="line">    var strArr = Array(str)</span><br><span class="line">    var tmp = [Character]()</span><br><span class="line">    func backtrace(loc: Int) &#123;</span><br><span class="line">        if tmp.isEmpty == false &#123;</span><br><span class="line">            res.append(String(tmp))</span><br><span class="line">        &#125;</span><br><span class="line">        if loc &gt;= strArr.count &#123; return &#125;</span><br><span class="line"></span><br><span class="line">        for i in loc..&lt;strArr.count &#123;</span><br><span class="line">            tmp.append(strArr[i])</span><br><span class="line">            strArr.swapAt(i, loc)</span><br><span class="line">            backtrace(loc: loc + 1)</span><br><span class="line">            strArr.swapAt(i, loc)</span><br><span class="line">            tmp.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrace(loc: 0)</span><br><span class="line">    return res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-组合问题"><a href="#2-组合问题" class="headerlink" title="2.组合问题"></a>2.组合问题</h1><h2 id="问题4：给定两个整数-n-和-k，返回-1-…-n-中所有可能的-k-个数的组合。"><a href="#问题4：给定两个整数-n-和-k，返回-1-…-n-中所有可能的-k-个数的组合。" class="headerlink" title="问题4：给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。"></a>问题4：给定两个整数 <em>n</em> 和 <em>k</em>，返回 1 … <em>n</em> 中所有可能的 <em>k</em> 个数的组合。</h2><p>这个问题和上面的全排列问题解法类似。区别在于，全排列问题中我们在原数组通过数字交换来实现回溯，组合问题中我们需要创建长度为k的数组，然后计算数组中每一个位置可能出现的数字，当目标数组填充满时候记录下当前值，然后回溯继续尝试下个可能性。</p>
<p>swift代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">combine</span><span class="params">(<span class="number">_</span> n: Int, <span class="number">_</span> k: Int)</span></span> -&gt; [[<span class="type">Int</span>]] &#123;</span><br><span class="line">        <span class="keyword">if</span> k == <span class="number">0</span> || k &gt; n &#123; <span class="keyword">return</span> [] &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> combine = [[<span class="type">Int</span>]]()</span><br><span class="line">        <span class="keyword">var</span> tmp = [<span class="type">Int</span>]()</span><br><span class="line">        <span class="function"><span class="keyword">func</span> <span class="title">backdate</span><span class="params">(start: Int, end: Int, targetCount: Int)</span></span> &#123;</span><br><span class="line">            <span class="comment">//退出条件</span></span><br><span class="line">            <span class="keyword">if</span> tmp.<span class="built_in">count</span> == targetCount &#123;</span><br><span class="line">                combine.append(tmp)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> val <span class="keyword">in</span> start..&lt;end &#123;</span><br><span class="line">                <span class="comment">//添加数字</span></span><br><span class="line">                tmp.append(val)</span><br><span class="line">                <span class="comment">//回溯</span></span><br><span class="line">                backdate(start: val + <span class="number">1</span>, end: end, targetCount: targetCount)</span><br><span class="line">                <span class="comment">//删除数字</span></span><br><span class="line">                tmp.removeLast()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        backdate(start: <span class="number">1</span>, end: n + <span class="number">1</span>, targetCount: k)</span><br><span class="line">        <span class="keyword">return</span> combine</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="问题5：给定一个没有重复数字的序列，返回这个序列所有可能组合。"><a href="#问题5：给定一个没有重复数字的序列，返回这个序列所有可能组合。" class="headerlink" title="问题5：给定一个没有重复数字的序列，返回这个序列所有可能组合。"></a>问题5：给定一个没有重复数字的序列，返回这个序列所有可能组合。</h2><p>分析：题目要求返回所有可能的组合，那么也就是说，组合的长度可能是1、2…n位，于是，这个问题就分解成了给定长度为n的没有重复数字的序列，返回长度为k的子序列，k的取值违反为<code>1-n</code>。</p>
<p>因此，第一种解法就是利用问题4中的解法，循环的指定k的长度，将最终得到的结果连接起来即可。但是这种方法会出现重复计算的情况。</p>
<p>事实上我们只需要计算给定序列的全排列，然后记录每次给目标序列添加内容后的新序列即可。</p>
<p>swift代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">permutationAll</span><span class="params">(str: String)</span></span> -&gt; [<span class="type">String</span>] &#123;</span><br><span class="line">    <span class="keyword">guard</span> str.<span class="built_in">count</span> &gt; <span class="number">1</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> [str] &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> res = [<span class="type">String</span>]()</span><br><span class="line">    <span class="keyword">let</span> strArr = <span class="type">Array</span>(str)</span><br><span class="line">    <span class="keyword">var</span> tmp = [<span class="type">Character</span>]()</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">backtrace</span><span class="params">(loc: Int)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> tmp.isEmpty == <span class="literal">false</span> &#123;</span><br><span class="line">            res.append(<span class="type">String</span>(tmp))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> loc &gt;= strArr.<span class="built_in">count</span> &#123; <span class="keyword">return</span> &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> loc..&lt;strArr.<span class="built_in">count</span> &#123;</span><br><span class="line">            tmp.append(strArr[i])</span><br><span class="line">            backtrace(loc: i + <span class="number">1</span>)</span><br><span class="line">            tmp.removeLast()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    backtrace(loc: <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-其它相关问题"><a href="#3-其它相关问题" class="headerlink" title="3.其它相关问题"></a>3.其它相关问题</h1><h2 id="问题6：下一个-排列（leetcode-31）"><a href="#问题6：下一个-排列（leetcode-31）" class="headerlink" title="问题6：下一个 排列（leetcode 31）"></a>问题6：下一个 排列（<a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">leetcode 31</a>）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">题目描述:</span><br><span class="line">实现获取下一个排列的函数，算法需要将给定数字序列重新排列成字典序中下一个更大的排列。</span><br><span class="line">如果不存在下一个更大的排列，则将数字重新排列成最小的排列（即升序排列）。</span><br><span class="line">必须原地修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<p><strong>方法一 ：</strong>暴力法。最容易想到的就是按照字典序遍历排序，当得到结果为给定序列值时候，返回下一个得到的序列。但是这样做算法的时间复杂度将会是O(n!)，作为算法题目，肯定会有更好的方法。</p>
<p><strong>方法二：</strong>查找下个较大的序列。我们知道，字典序是按照从小到大的序列排列的，因此我们只要找到一个方法，生成下一个大于当前序列的序列即可。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1,2,3 → 1,3,2</span><br><span class="line">1,1,5 → 1,5,1</span><br><span class="line">2,5,4,3 → 3,2,4,5</span><br><span class="line">3,2,1 → 1,2,3</span><br></pre></td></tr></table></figure>

<p>实际上，要想找到下一个序列，需要三个步骤：</p>
<ol>
<li>从后向前找到第一个相邻的左边小于右边的位置i；</li>
<li>从i向后查找最小的大于当前位置数字的数字，并交换位置（交换后i之后的序列是递减的序列）；</li>
<li>将i后面的数字全部反转，得到当前序列的下一个字典序序列。</li>
</ol>
<p><img src="http://img.weidongfang.online/imgbed/20200929120922.gif" alt></p>
<p style="color:gray;text-align:center">图片来自网络</p>

<p>否则序列就是一个降序的序列 ，不存在更大的值，下一个序列就是升序排列的序列，反转整个序列即可。</p>
<p>swift代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Problem31Solution &#123;</span><br><span class="line">    func nextPermutation(_ nums: inout [Int]) &#123;</span><br><span class="line">        guard nums.count &gt; 1 else &#123; return &#125;</span><br><span class="line">        //第一步</span><br><span class="line">        var i = nums.count - 2</span><br><span class="line">        while i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1] &#123;</span><br><span class="line">            i -= 1</span><br><span class="line">        &#125;</span><br><span class="line">        if i &gt;= 0 &#123;</span><br><span class="line">            //第二步</span><br><span class="line">            var j = i</span><br><span class="line">            while j &lt; nums.count - 1 &amp;&amp;  nums[j + 1] &gt; nums[i] &#123;</span><br><span class="line">                j += 1</span><br><span class="line">            &#125;</span><br><span class="line">            nums.swapAt(i, j)</span><br><span class="line">        &#125;</span><br><span class="line">        //第三步</span><br><span class="line">        reverse(nums: &amp;nums, start: i + 1, end: nums.count - 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    //反转序列指定范围</span><br><span class="line">    private func reverse(nums: inout [Int], start: Int, end: Int) &#123;</span><br><span class="line">        var start = start, end = end</span><br><span class="line">        while start &lt; end &#123;</span><br><span class="line">            nums.swapAt(start, end)</span><br><span class="line">            start += 1</span><br><span class="line">            end -= 1</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>leetcode相关题目：</strong></p>
<p>【Leetcode 46】没有重复数字的全排列：<a href="https://leetcode-cn.com/problems/permutations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations/</a></p>
<p>【Leetcode 47】有重复数字的全排列：<a href="https://leetcode-cn.com/problems/permutations-ii/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutations-ii/</a></p>
<p>【Leetcode 77】组合-求1-n中k个数可能的组合：<a href="https://leetcode-cn.com/problems/combinations/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/combinations/</a></p>
<p>【Leetcode 31】下一个排列：<a href="https://leetcode-cn.com/problems/next-permutation/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/next-permutation/</a></p>
<p>【Leetcode 60】第k个排列：<a href="https://leetcode-cn.com/problems/permutation-sequence/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/permutation-sequence/</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>【算法】Leetcode精选-持续更新中</title>
    <url>/posts/2019-09/56414.html</url>
    <content><![CDATA[<p>本篇记录leetcode上优秀的算法题目，持续更新中…</p>
<a id="more"></a>

<h1 id="1-反转单链表2"><a href="#1-反转单链表2" class="headerlink" title="1. 反转单链表2"></a>1. <a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">反转单链表2</a></h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Reverse a linked list from position m to n. Do it in one-pass.</span><br><span class="line"></span><br><span class="line">Note: 1 ≤ m ≤ n ≤ length of list.</span><br><span class="line"></span><br><span class="line">Example:</span><br><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, m = 2, n = 4</span><br><span class="line">Output: 1-&gt;4-&gt;3-&gt;2-&gt;5-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>这个题目看似和反转链表一样的简单, 但是实现起来并没有那么容易, 边界条件比反转链表多一点. 解决方案:</p>
<p>1.先顺序遍历找到需要反转的结点的前一个结点标记为pre, 找到需要插入的第一个结点的前一个结点标记start, 需要反转的第二个结点标记then. 解决思路就是, <strong>将them插入到pre的后面, 将then从start的后面删除.</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//反转链表的m~n</span><br><span class="line">func reverseBetween(_ head: ListNode?, _ m: Int, _ n: Int) -&gt; ListNode? &#123;</span><br><span class="line">    guard let head = head else &#123; return nil &#125;</span><br><span class="line">    let dummy = ListNode(0)</span><br><span class="line">    dummy.next = head</span><br><span class="line">    var pre: ListNode? = dummy</span><br><span class="line">    for _ in 1..&lt;m &#123;</span><br><span class="line">        pre = pre?.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    let start = pre?.next</span><br><span class="line">    var then = start?.next</span><br><span class="line">    for _ in m..&lt;n &#123;</span><br><span class="line">        start?.next = then?.next</span><br><span class="line">        then?.next = pre?.next</span><br><span class="line">        pre?.next = then</span><br><span class="line">        then = start?.next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return dummy.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="2-判断二叉树是否是二叉搜索树"><a href="#2-判断二叉树是否是二叉搜索树" class="headerlink" title="2. 判断二叉树是否是二叉搜索树"></a>2. <a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">判断二叉树是否是二叉搜索树</a></h1><p>二叉搜索树: 在树的任意一个结点, 其左子树每个结点的值都小于这个结点的值, 其右子树每个结点的值都小于这个结点的值.  </p>
<p>乍一看, 只需比较结点左子树小于结点, 右子树大于结点即可, 实际上这种解法是不正确的, 比如<code>[10,5,15,null,null,6,20]</code>. 要解决这个问题, 需要转换一下思维, 解决思路还是递归, 我们还是从根节点开始, <strong>根节点的值, 在其左子树中一定是最大的, 在其右子树中一定是最小的.</strong> 基于这个事实, 我们可以编写出如下的解决方案: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Problem98Solution1 &#123;</span><br><span class="line">    func isValidBST(_ root: TreeNode?) -&gt; Bool &#123;</span><br><span class="line">        return judge(node: root, lowwer: nil, upper: nil)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private func judge(node: TreeNode?, lowwer: Int?, upper: Int?) -&gt; Bool &#123;</span><br><span class="line">        guard let node = node else &#123; return true &#125;</span><br><span class="line">        </span><br><span class="line">        let val = node.val</span><br><span class="line">        if let lowwer = lowwer, lowwer &gt;= val &#123; return false &#125;</span><br><span class="line">        if let upper = upper, upper &lt;= val &#123; return false &#125;</span><br><span class="line">        </span><br><span class="line">        let leftValid = judge(node: node.left, lowwer: lowwer, upper: val)</span><br><span class="line">        let rightValid = judge(node: node.right, lowwer: val, upper: upper)</span><br><span class="line">        </span><br><span class="line">        return leftValid &amp;&amp; rightValid</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-按层遍历二叉树"><a href="#3-按层遍历二叉树" class="headerlink" title="3. 按层遍历二叉树"></a>3. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">按层遍历二叉树</a></h1><p>Given a binary tree, return the level order traversal of its nodes’ values. (ie, from left to right, level by level).</p>
<p>For example:<br>Given binary tree [3,9,20,null,null,15,7],<br>    3<br>   / <br>  9  20<br>    /  <br>   15   7<br>return its level order traversal as:<br>[<br>  [3],<br>  [9,20],<br>  [15,7]<br>]</p>
<p><strong>解决1:</strong>遍历, 将每一层的数据存储起来存储每层的结点和每层结点的结果, 最终返回.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Problem102Solution1 &#123;</span><br><span class="line">    func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        var results = [[Int]]()</span><br><span class="line">        guard let root = root else &#123; return results &#125;</span><br><span class="line">        travelLayer(result: &amp;results, nodes: [root])</span><br><span class="line">        return results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func travelLayer(result: inout [[Int]], nodes: [TreeNode]) &#123;</span><br><span class="line">        guard !nodes.isEmpty else &#123; return &#125;</span><br><span class="line">        var layerResult = [Int]()</span><br><span class="line">        var nextLayerNodes = [TreeNode]()</span><br><span class="line">        for node in nodes &#123;</span><br><span class="line">            layerResult.append(node.val)</span><br><span class="line">            if let leftNode = node.left &#123;</span><br><span class="line">                nextLayerNodes.append(leftNode)</span><br><span class="line">            &#125;</span><br><span class="line">            if let rightNode = node.right &#123;</span><br><span class="line">                nextLayerNodes.append(rightNode)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if layerResult.isEmpty == false &#123;</span><br><span class="line">            result.append(layerResult)</span><br><span class="line">        &#125;</span><br><span class="line">        if nextLayerNodes.isEmpty == false &#123;</span><br><span class="line">            travelLayer(result: &amp;result, nodes: nextLayerNodes)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>解决2</strong>: 解法2的时间复杂度优于解法1,但是事实上并没有快多少. 优雅的递归解决方案: 深度优先遍历, 遍历时候判断如果存放结果的结点存在则将结果放在对应的结果集中, 如果不存在则创建对应的集合并放入结果集中, 最后递归遍历左子树和右子树. 代码如下所示.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    func levelOrder(_ root: TreeNode?) -&gt; [[Int]] &#123;</span><br><span class="line">        var results = [[Int]]()</span><br><span class="line">        guard let root = root else &#123; return results &#125;</span><br><span class="line">        travelLayer(result: &amp;results, node: root, height: 0)</span><br><span class="line">        return results</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func travelLayer(result: inout [[Int]], node: TreeNode?, height: Int) &#123;</span><br><span class="line">        guard let node = node else &#123; return &#125;</span><br><span class="line">        if height &gt;= result.count &#123;</span><br><span class="line">            result.append([Int]())</span><br><span class="line">        &#125;</span><br><span class="line">        result[height].append(node.val)</span><br><span class="line">        travelLayer(result: &amp;result, node: node.left, height: height + 1)</span><br><span class="line">        travelLayer(result: &amp;result, node: node.right, height: height + 1)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考了leetcode上其它的解法, 发现耗时短的算法基本上是基于第一种思路,使用循环实现的代码.<strong>进一步证明了循环比递归更快</strong>, 递归比较慢的原因是递归需要开辟新的堆栈,创建临时变量,销毁堆栈返回. 代码指令条数要多于循环,所占用栈空间也要比循环多.</p>
<h1 id="4-二叉树最大深度"><a href="#4-二叉树最大深度" class="headerlink" title="4. 二叉树最大深度"></a>4. <a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">二叉树最大深度</a></h1><p> Given a binary tree, find its maximum depth.</p>
<p> The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.</p>
<p> Note: A leaf is a node with no children.</p>
<p> Example:</p>
<p> Given binary tree [3,9,20,null,null,15,7],</p>
<p> 3<br> / <br> 9  20<br> /  <br> 15   7<br> return its depth = 3.</p>
<p> <strong>递归解决方案:</strong></p>
<p> <strong>分解问题:</strong> 第一层深度等一第二层的深度+1, 第二层深度等于第三层深度+1, 如果结点没有子结点, 则是最大深度.</p>
<p> 代码如下所示: 先判断左子树深度, 再判断右子树深度, 比较两个深度最大的就是这个结点的最大深度, 依次递归查找.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Problem104Solution1 &#123;</span><br><span class="line">    func maxDepth(_ root: TreeNode?) -&gt; Int &#123;</span><br><span class="line">        guard let root = root else &#123; return 0 &#125;</span><br><span class="line">        </span><br><span class="line">        return maxDepth(root, depth: 1)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func maxDepth(_ root: TreeNode?, depth: Int) -&gt; Int &#123;</span><br><span class="line">        guard let root = root else &#123; return depth - 1 &#125;</span><br><span class="line">        </span><br><span class="line">        let leftDepth = maxDepth(root.left, depth: depth + 1)</span><br><span class="line">        let rightDepth = maxDepth(root.right, depth: depth + 1)</span><br><span class="line">        return max(leftDepth, rightDepth)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-颜色排序"><a href="#5-颜色排序" class="headerlink" title="5. 颜色排序"></a>5. <a href="https://leetcode.com/tag/two-pointers/" target="_blank" rel="noopener">颜色排序</a></h1><p>乍一看是一个挺简单的题目, 思路也比较简单. 两个指针指向数组, 一个在前面,一个在后面,依次遍历数组,如果遍历到0则与前面元素交换,如果遍历到2这与后面的交换.这里有很多的边界条件需要考虑. swift代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 3.两个指针,一前一后,遍历指针从头开始遍历,如果数字是0这和第一个交换,如果是2这和最后一个交换,原地排序.</span><br><span class="line">class Problem75Solution2 &#123;</span><br><span class="line">    func sortColors(_ nums: inout [Int]) &#123;</span><br><span class="line">        guard nums.count &gt; 1 else &#123; return&#125;</span><br><span class="line">        var left = 0, right = nums.count - 1, i = 0</span><br><span class="line">        while i &lt;= right &#123;</span><br><span class="line">            if nums[i] == 0 &#123;</span><br><span class="line">                nums.swapAt(i, left)</span><br><span class="line">                left += 1</span><br><span class="line">            &#125;else if nums[i] == 2&#123;</span><br><span class="line">                nums.swapAt(i, right)</span><br><span class="line">                right -= 1</span><br><span class="line">                i -= 1</span><br><span class="line">            &#125;</span><br><span class="line">            i += 1</span><br><span class="line">            print(nums)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要特别注意的是:</p>
<ol>
<li>如果i与后面的元素进行交换,则交换过来的数字是多少是不清楚的,因此这时候i不能加1; </li>
<li>循环终止的条件:<code>i&lt;=right</code>. 当遍历到右边界时候,循环需要终止;</li>
</ol>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>【算法】二分查找全解</title>
    <url>/posts/2020-02/56414.html</url>
    <content><![CDATA[<p>[TOC]</p>
<p>二分查找也称折半查找，是一种效率较高的查找方法，但是，二分查找要求线性表必须采取顺序存储结构，而且表中元素需按关键字有序排列。</p>
<h1 id="1-高效的二分查找"><a href="#1-高效的二分查找" class="headerlink" title="1.高效的二分查找"></a>1.高效的二分查找</h1><p>二分查找原理非常简单，查找思想有点类似分治思想，每次都通过跟区间中间元素做对比，将待查找区间缩小为之前的一半，直到找到要查找的元素，或者区间被缩小为0。二分查找的时间复杂度是对数复杂度，也就是O<strong>(log n)</strong>。</p>
<p>最简单的情况就是，有序数组中不存在任何重复元素，我们用二分查找元素等于给定值的数据，这里我用swift实现了一个简单的二分查找，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearch</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span>  l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == value &#123;</span><br><span class="line">            <span class="keyword">return</span> mid</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &gt; value&#123;</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二分查找中有三点需要特别注意：</p>
<ol>
<li><strong>循环退出条件</strong>：<code>l &lt;= h</code>，如果写成了<code>l &lt; h</code>可能造成死循环。</li>
<li><strong>mid的取值</strong>：如果写成<code>l + (l + h) / 2</code>有可能会溢出，因此应该写成<code>l + (h - l) &gt;&gt; 1</code>。</li>
<li><strong>l和h的更新</strong>，如果直接写<code>l = mid</code>或者<code>h = mid</code>，可能导致死循环，因此这里需要写成<code>mid - 1</code>、<code>mid + 1</code>。</li>
</ol>
<p><strong>二分查找的局限性</strong></p>
<ol>
<li><strong>二分查找依赖的是顺序表结构，简单说就是数组。</strong>因为数组随机访问的特性，我们可以O(1)方法数组内任意一个元素，如果是链表就达不到这种效果。</li>
<li><strong>二分查找针对的是有序数据。</strong>二分查找对数据要求比较苛刻，数据必须是有序的，如果数据是 无需的，那么必须排序后才能使用二分查找。如果针对静态数据，没有频繁的插入删除操作，一次排序、多次查找也是可以的，但是如果有频繁的插入和删除操作，二分查找就力不从心了。</li>
<li><strong>数据量太小不太适合二分查找。</strong>如果要处理的数据量太小，完全没必要使用二分查找，顺序遍历就够了，比如一个10个元素的数组，不管是二分查找还是顺序遍历，查找速度相差不大。</li>
<li><strong>数据量太大也不适合二分查找。</strong>因为二分查找依赖数组这样的数据结构，利用数组随机访问的特性才能达到O(log n)的效率。而数组要求连续的内存空间，如果数据量太大，系统可能找不到足够多的连续空间。</li>
</ol>
<h1 id="2-二分查找的变体"><a href="#2-二分查找的变体" class="headerlink" title="2.二分查找的变体"></a>2.二分查找的变体</h1><p>简单二分查找要求数组中不能有重复的数据，但是在实际项目中有重复数据的数组就不能使用二分查找了吗？其实二分查找还有很多变体，使用二分查找的变体，我们一样可以愉快的使用二分查找！</p>
<h2 id="2-1-查找第一个值等于给定值的元素"><a href="#2-1-查找第一个值等于给定值的元素" class="headerlink" title="2.1 查找第一个值等于给定值的元素"></a>2.1 查找第一个值等于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">///查找第一个等于给定值的index,目标可以在数组中出现多次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchFirstIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) &gt;&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; value &#123;</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; value&#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] != value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这份代码和简单二分查找代码的区别在于找到等于给定值时候的处理，简单二分查找中直接return返回即可，但是这里因为有重复的元素，因此我们需要判断找到的这个元素是否是第一个值等于给定值的元素。如果<code>mid == 0 || nums[mid - 1] != value</code>那么当前的mid就一定是第一个等于给定值的元素，否则我们要查找的目标元素一定在前面，因此重置<code>h = mid - 1</code>继续遍历即可。</p>
<h2 id="2-2-查找最后一个值等于给定值的元素"><a href="#2-2-查找最后一个值等于给定值的元素" class="headerlink" title="2.2 查找最后一个值等于给定值的元素"></a>2.2 查找最后一个值等于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">///查找最后一个等于给定值的index, 目标可以在数组中出现多次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchLastIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt; value &#123;</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> nums[mid] &lt; value &#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">          	<span class="comment">//判断当前元素是否是最后一个元素，或者mid之后元素不等于给定值</span></span><br><span class="line">            <span class="keyword">if</span> mid == nums.<span class="built_in">count</span> - <span class="number">1</span> || nums[mid + <span class="number">1</span>] != value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">              	<span class="comment">//更新l</span></span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>查找最后一个值等于给定值元素和查找第一个等于给定值类似的原理，区别在于判断是否是当前mid的判断条件和更新区间上，详情参考代码注释。</p>
<h2 id="2-3-查找第一个大于等于给定值的元素"><a href="#2-3-查找第一个大于等于给定值的元素" class="headerlink" title="2.3 查找第一个大于等于给定值的元素"></a>2.3 查找第一个大于等于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查找第一个大于等于给定值的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchFirstMoreThanOrEquelIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &gt;= value &#123;</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt; value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h = mid - <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>例如给定序列<code>3,4,6,7,8,9</code>，查找第一个大于等于给定值的元素，如果查找的是5，那么返回的应该 是6，如果查找的是6，那么返回的还是6。</p>
<p>这个算法的关键是，当mid位置的值<code>&gt;=</code>value时候，判断当前mid是否是我们寻找的mid，如果不是继续更新查找区间即可。</p>
<h2 id="2-4-查找最后一个小于等于给定值的元素"><a href="#2-4-查找最后一个小于等于给定值的元素" class="headerlink" title="2.4 查找最后一个小于等于给定值的元素"></a>2.4 查找最后一个小于等于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查找最后一个小于等于给定值的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchFirstLessThanOrEquelIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] &lt;= value &#123;</span><br><span class="line">            <span class="keyword">if</span> mid == nums.<span class="built_in">count</span> - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt; value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid - <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个算法思想类似<code>2.3 查找第一个大于等于给定值的元素</code>，区别在于判断当前值是否是要查找的目标元素。</p>
<h2 id="2-5-查找第一个大于给定值的元素"><a href="#2-5-查找第一个大于给定值的元素" class="headerlink" title="2.5 查找第一个大于给定值的元素"></a>2.5 查找第一个大于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查找第一个大于给定值 的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchFirstMoreThanIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &gt; value)&#123;</span><br><span class="line">            <span class="keyword">if</span> mid == <span class="number">0</span> || nums[mid - <span class="number">1</span>] &lt;= value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                h = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            l = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个问题是<code>2.3</code>中问题的拓展，在代码上唯一的区别在于<code>nums[mid] &gt; value</code>。</p>
<h2 id="2-6-查找第一个小于给定值的元素"><a href="#2-6-查找第一个小于给定值的元素" class="headerlink" title="2.6 查找第一个小于给定值的元素"></a>2.6 查找第一个小于给定值的元素</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 查找第一个小于给定值的元素位置</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">binarySearchFirstLessThanIndex</span><span class="params">(nums: [Int], value: Int)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> l = <span class="number">0</span>, h = nums.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> l &lt;= h &#123;</span><br><span class="line">        <span class="keyword">let</span> mid = l + (h - l) &gt;&gt; <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; value)&#123;</span><br><span class="line">            <span class="keyword">if</span> mid == nums.<span class="built_in">count</span> - <span class="number">1</span> || nums[mid + <span class="number">1</span>] &gt;= value &#123;</span><br><span class="line">                <span class="keyword">return</span> mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            h = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>类似于<code>2.4</code>，区别在于if条件判断<code>nums[mid] &lt; value</code>。</p>
<blockquote>
<p>Reference</p>
<p><a href="https://time.geekbang.org/column/article/42520" target="_blank" rel="noopener">https://time.geekbang.org/column/article/42520</a>   </p>
<p>注：王争老师《数据结构与算法之美》课程真正做到了深入浅出，复杂的算法在他的讲解下变得简单起来，简单的算法在他的笔下变得更加深刻，推荐！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>【算法】Swift实现线程安全的栈和队列</title>
    <url>/posts/2019-08/43383.html</url>
    <content><![CDATA[<h1 id="实现一个线程安全的栈"><a href="#实现一个线程安全的栈" class="headerlink" title="实现一个线程安全的栈"></a>实现一个线程安全的栈</h1><p>这里使用数组来存储栈的数据。不足之处在于本例中的Stack可以无限扩容，更好的是初始化时候指定一个最大容量，防止不断扩容申请内存导致内存不够的问题。这里通过信号量保证线程安全。</p>
<a id="more"></a>

<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> items: [<span class="type">Element</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semphore = <span class="type">DispatchSemphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(capacity: <span class="type">Int</span> = <span class="number">10</span>) &#123;</span><br><span class="line">        items = [<span class="type">Element</span>]()</span><br><span class="line">        items.reserveCapacity(capacity)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">push</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        semphore.wait()</span><br><span class="line">        items.append(item)</span><br><span class="line">        semphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">pop</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> item: <span class="type">Element?</span></span><br><span class="line">        semphore.wait()</span><br><span class="line">        item = items.removeLast()</span><br><span class="line">        semphore.signal()</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> item</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="实现一个线程安全的队列"><a href="#实现一个线程安全的队列" class="headerlink" title="实现一个线程安全的队列"></a>实现一个线程安全的队列</h1><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存储数据的双向链表节点</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DoubleLinkNode</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> previous: <span class="type">DoubleLinkNode?</span></span><br><span class="line">    <span class="keyword">var</span> next: <span class="type">DoubleLinkNode?</span></span><br><span class="line">    <span class="keyword">let</span> val: <span class="type">Element?</span></span><br><span class="line">    <span class="keyword">init</span>(val: <span class="type">Element?</span>) &#123;</span><br><span class="line">        <span class="keyword">self</span>.val = val</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//声明==运算符，便于判断两个节点是否相等</span></span><br><span class="line">    <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> ==<span class="params">(<span class="keyword">left</span>: DoubleLinkNode&lt;Element&gt;, <span class="keyword">right</span>: DoubleLinkNode&lt;Element&gt;)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="comment">//最准确的做法是判断内存地址是否相同</span></span><br><span class="line">        <span class="keyword">let</span> leftPointValue = <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;.passUnretained(<span class="keyword">left</span>).toOpaque()</span><br><span class="line">        <span class="keyword">let</span> rightPointValue = <span class="type">Unmanaged</span>&lt;<span class="type">AnyObject</span>&gt;.passUnretained(<span class="keyword">right</span>).toOpaque()</span><br><span class="line">        <span class="keyword">return</span> leftPointValue == rightPointValue</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> 1.使用双向链表实现队列结构，声明空的head/last哨兵节点简化双向链表操作；</span></span><br><span class="line"><span class="comment"> 2.对于生产者-消费者模型，同样可以使用semaphore来实现，当队列为空的时候，让线程休眠，当有元素入队的时候唤醒一个线程继续执行任务。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">let</span> semphore = <span class="type">DispatchSemphore</span>(value: <span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> firstNode: <span class="type">DoubleLinkNode</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    <span class="keyword">let</span> lastNode: <span class="type">DoubleLinkNode</span>&lt;<span class="type">Element</span>&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">init</span>(capacity: <span class="type">Int</span> = <span class="number">20</span>) &#123;</span><br><span class="line">        firstNode = <span class="type">DoubleLinkNode</span>(val: <span class="literal">nil</span>)</span><br><span class="line">        lastNode = <span class="type">DoubleLinkNode</span>(val: <span class="literal">nil</span>)</span><br><span class="line">        firstNode.next = lastNode</span><br><span class="line">        lastNode.previous = firstNode</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 入队操作</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">enqueue</span><span class="params">(item: Element)</span></span> &#123;</span><br><span class="line">        semphore.wait()</span><br><span class="line">        <span class="keyword">let</span> node = <span class="type">DoubleLinkNode</span>&lt;<span class="type">Element</span>&gt;(val: item)</span><br><span class="line">        <span class="keyword">let</span> tmp = firstNode.next</span><br><span class="line">        firstNode.next = node</span><br><span class="line">        node.previous = firstNode</span><br><span class="line">        node.next = tmp</span><br><span class="line">        tmp?.previous = node</span><br><span class="line">        semphore.signal()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// 出队操作</span></span><br><span class="line">    <span class="keyword">mutating</span> <span class="keyword">public</span> <span class="function"><span class="keyword">func</span> <span class="title">dequeue</span><span class="params">()</span></span> -&gt; <span class="type">Element?</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> <span class="keyword">let</span> previous = lastNode.previous, !(firstNode == previous) <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">nil</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> node: <span class="type">DoubleLinkNode</span>&lt;<span class="type">Element</span>&gt;? = <span class="literal">nil</span></span><br><span class="line">        semphore.wait()</span><br><span class="line">        node = lastNode.previous</span><br><span class="line">        node?.next = <span class="literal">nil</span></span><br><span class="line">        node?.previous = <span class="literal">nil</span></span><br><span class="line">        <span class="keyword">let</span> tmp = node?.previous</span><br><span class="line">        lastNode.previous = tmp</span><br><span class="line">        tmp?.next = lastNode</span><br><span class="line">        semphore.signal()</span><br><span class="line">        <span class="keyword">return</span> node?.val</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
  <entry>
    <title>【算法】手撕五花八门的字符串匹配算法</title>
    <url>/posts/2020-04/41401.html</url>
    <content><![CDATA[<p>字符串匹配在计算机领域是个老生常谈的问题，对于任何一个开发工程师来说应该都不陌生，我们常用的各种语言一般都提供有字符串查找相关的方法，比如swift语言String相关的<code>contains</code>、<code>hasPrefix</code>、<code>first(where:)</code>等方法，他们底层的实现就是依赖字符串匹配算法的。</p>
<p>字符串匹配算法有很多，这里只讲单模式串匹配算法，包括：BF算法、RK算法、BM算法、KMP算法。</p>
<a id="more"></a>

<p>在开始之前这里先定义几个概念：</p>
<p><strong>主串</strong>和<strong>模式串</strong>。比如我们要在字符串A中查找字符串B，那么字符串B就是模式串，字符串A就是主串。</p>
<h1 id="1-BF（Brute-Force）算法"><a href="#1-BF（Brute-Force）算法" class="headerlink" title="1.BF（Brute Force）算法"></a>1.BF（Brute Force）算法</h1><p>BF算法又叫做暴力匹配算法，顾名思义，它匹配字符串的方法很暴力，但是也很好懂，很容易实现，不足之处在于它的性能。</p>
<p>BF算法很简单，从主串和模式串的第一位开始比较，然后第二位、第三位，如果遇到模式串和主串不相等的字符，则模式串向后移动一位，继续比较模式串和对应主串字符。</p>
<p><strong>BF字符串匹配算法（swift）：</strong></p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 1.BF算法，暴力破解算法，从头到尾以此匹配</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchInString</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">bruteForce</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> strChars = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">        <span class="keyword">let</span> patternChars = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>...(strChars.<span class="built_in">count</span> - patternChars.<span class="built_in">count</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> currentIndex = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> currentIndex &lt; patternChars.<span class="built_in">count</span> &amp;&amp; strChars[currentIndex + i] == patternChars[currentIndex] &#123;</span><br><span class="line">                currentIndex += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> currentIndex &gt;= patternChars.<span class="built_in">count</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>理论上，BF算法的时间复杂度很高，O(n*m)，但在实际开发中，它是个比较常用的字符串匹配算法，原因有两点：</p>
<ol>
<li>实际开发中，大部分场景下，主串和模式串的长度都不会太长，并且每次比较遇到不相等字符时候匹配就停止了，不需要把m个字符都比较以便，算法实际的效率要远高于O(n*m)。</li>
<li>BF算法思想简单，代码实现也很简单。简单意味着不会出错，如果有bug也很容易暴露和修改，而这一点在软件工程中是相当重要的。</li>
</ol>
<h1 id="2-RK（Rabin-Karp）算法"><a href="#2-RK（Rabin-Karp）算法" class="headerlink" title="2.RK（Rabin-Karp）算法"></a>2.RK（Rabin-Karp）算法</h1><p>RK算法算是BF算法的改进版，BF算法的核心是匹配模式串和主串上对应的每一位，而RK算法引入了哈希算法，使主串和模式串的匹配立马降低很多。</p>
<p>RK算法的思路是这样的，我们通过哈希算法分别对主串中的n-m+1个子串求哈希值，然后逐个比较子串和模式串的哈希值，如果某个子串哈希值和模式串相等，那就说明对应的子串和模式串匹配了（哈希冲突问题稍后解决）。由于哈希值是数字，数字之间比较是非常快的，所以模式串和子串比较的效率就提高了。</p>
<p><img src="http://img.weidongfang.online/imgbed/015c85a9c2a4adc11236f9a40c6d57ee.jpg" alt></p>
<p>RK算法中，最关键的是哈希算法，如果我们使用常规的哈希算法，计算哈希值需要对字符串遍历多次，这样的RK不但不能提高效率，反而增加了字符串比较的成本。</p>
<p>RK算法设计的非常有技巧，我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p>
<p>比如要处理的字符串只包含 a～z 这 26 个小写字母，那我们就用二十六进制来表示一个字符串。我们把 a～z 这 26 个字符映射到 0～25 这 26 个数字，a 就表示 0，b 就表示 1，以此类推，z 表示 25。</p>
<p>第二种方法是，先建立一个每个字符对应唯一一个整形数字的哈希表，然后将字符串中字符对应的数字相加作为哈希值（本文代码将参照这种格式）。</p>
<p>以上两种方法有一个特点，那就是当我们计算下一个子串哈希值时候并不需要遍历整个子串，只需要减去第一个字符的值，再加上子串尾部的值，使用这种方法计算哈希值效率就会提高很多。</p>
<p>下面我们用第二种方法实现RK算法，我们假设已经创建好了哈希字典，核心代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//RK算法</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">rabinKarp</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> pattern = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">    <span class="keyword">let</span> str = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">    <span class="comment">//1.计算模式串哈希值</span></span><br><span class="line">    <span class="keyword">let</span> hashPattern = pattern.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;$<span class="number">0</span> + <span class="type">SearchInString</span>.dict[$<span class="number">1</span>]!&#125;</span><br><span class="line">    <span class="comment">//2.计算主串前n个字符的哈希值</span></span><br><span class="line">    <span class="keyword">var</span> hashCurrent = str.<span class="keyword">prefix</span>(pattern.<span class="built_in">count</span>).<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;$<span class="number">0</span> + <span class="type">SearchInString</span>.dict[$<span class="number">1</span>]!&#125;</span><br><span class="line">    <span class="comment">//3.依次向后移动并计算哈希值并比较</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...(str.<span class="built_in">count</span> - pattern.<span class="built_in">count</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> index != <span class="number">0</span> &#123;</span><br><span class="line">            hashCurrent -= <span class="type">SearchInString</span>.dict[str[index - <span class="number">1</span>]]!</span><br><span class="line">            hashCurrent += <span class="type">SearchInString</span>.dict[str[index + pattern.<span class="built_in">count</span> - <span class="number">1</span>]]!</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> hashCurrent == hashPattern &#123;</span><br><span class="line">            <span class="keyword">return</span> index</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里哈希字典的创建也是有讲究的，为了降低哈希碰撞，我们使用字符对应素数，判断素数这个问题算是很初级的算法了，这里直接贴代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断是否是素数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(num: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> num &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> num &gt; <span class="number">1</span> &#125;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">    <span class="keyword">while</span> i * i &lt; num &#123;</span><br><span class="line">        <span class="keyword">if</span> num % i == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了判断素数的方法，接下来我们需要建立一个字符和素数对应的哈希表，这里我们假设我们的主串和模式串中只包含大小写字母和数字，建立哈希表的代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//输出前n个素数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">outputPrime</span><span class="params">(n: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> primes = [<span class="number">2</span>]</span><br><span class="line">    <span class="keyword">var</span> currentNumber = <span class="number">3</span></span><br><span class="line">    <span class="keyword">while</span> primes.<span class="built_in">count</span> &lt; n &#123;</span><br><span class="line">        <span class="keyword">if</span> isPrime(num: currentNumber) &#123;</span><br><span class="line">            primes.append(currentNumber)</span><br><span class="line">        &#125;</span><br><span class="line">        currentNumber += <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> primes</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> dict: [<span class="type">Character</span>: <span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="comment">//构建缓存字典</span></span><br><span class="line">    <span class="keyword">let</span> primes = outputPrime(n: <span class="number">62</span>)</span><br><span class="line">    <span class="keyword">let</span> alphas = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ1234567890"</span>)</span><br><span class="line">    <span class="keyword">var</span> dict = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> (index,prime) <span class="keyword">in</span> primes.enumerated() &#123;</span><br><span class="line">        dict[alphas[index]] = prime</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure>

<p>这样看起来很完美了，但是千万别忽略了哈希碰撞，在这个算法中，如果子串和模式串字母相同顺序不同，哈希值也是相同的，也就是出现了哈希碰撞。RK算法中，如果出现哈希碰撞，我们只能使用BF算法来一位一位的进行比较了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//防止哈希冲突返回错误的结果，当遇到两个hash值相同的字符串时候，使用bf算法验证一下</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkMatching</span><span class="params">(str: [Character], index: Int, pattern: [Character])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (i, char) <span class="keyword">in</span> pattern.enumerated() &#123;</span><br><span class="line">        <span class="keyword">if</span> str[i + index] != char &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，一个完美的RK算法已经完成啦！我们来看下最终的代码吧！</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 2.RK(Rabin-Karp)算法，基于哈希匹配的算法</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchInString</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">var</span> dict: [<span class="type">Character</span>: <span class="type">Int</span>] = &#123;</span><br><span class="line">        <span class="comment">//构建缓存字典</span></span><br><span class="line">        <span class="keyword">let</span> primes = outputPrime(n: <span class="number">62</span>)</span><br><span class="line">        <span class="keyword">let</span> alphas = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(<span class="string">"abcdefghijklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ1234567890"</span>)</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> (index,prime) <span class="keyword">in</span> primes.enumerated() &#123;</span><br><span class="line">            dict[alphas[index]] = prime</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dict</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//RK算法</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">rabinKarp</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pattern = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">        <span class="keyword">let</span> str = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">        <span class="comment">//1.计算模式串哈希值</span></span><br><span class="line">        <span class="keyword">let</span> hashPattern = pattern.<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;$<span class="number">0</span> + <span class="type">SearchInString</span>.dict[$<span class="number">1</span>]!&#125;</span><br><span class="line">        <span class="comment">//2.计算主串前n个字符的哈希值</span></span><br><span class="line">        <span class="keyword">var</span> hashCurrent = str.<span class="keyword">prefix</span>(pattern.<span class="built_in">count</span>).<span class="built_in">reduce</span>(<span class="number">0</span>) &#123;$<span class="number">0</span> + <span class="type">SearchInString</span>.dict[$<span class="number">1</span>]!&#125;</span><br><span class="line">        <span class="comment">//3.依次向后移动并计算哈希值并比较</span></span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>...(str.<span class="built_in">count</span> - pattern.<span class="built_in">count</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> index != <span class="number">0</span> &#123;</span><br><span class="line">                hashCurrent -= <span class="type">SearchInString</span>.dict[str[index - <span class="number">1</span>]]!</span><br><span class="line">                hashCurrent += <span class="type">SearchInString</span>.dict[str[index + pattern.<span class="built_in">count</span> - <span class="number">1</span>]]!</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> hashCurrent == hashPattern &amp;&amp; checkMatching(str: str, index: index, pattern: pattern) &#123;</span><br><span class="line">                <span class="keyword">return</span> index</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//防止哈希冲突返回错误的结果，当遇到两个hash值相同的字符串时候，使用bf算法验证一下</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">checkMatching</span><span class="params">(str: [Character], index: Int, pattern: [Character])</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (i, char) <span class="keyword">in</span> pattern.enumerated() &#123;</span><br><span class="line">            <span class="keyword">if</span> str[i + index] != char &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//输出前n个素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">outputPrime</span><span class="params">(n: Int)</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> primes = [<span class="number">2</span>]</span><br><span class="line">        <span class="keyword">var</span> currentNumber = <span class="number">3</span></span><br><span class="line">        <span class="keyword">while</span> primes.<span class="built_in">count</span> &lt; n &#123;</span><br><span class="line">            <span class="keyword">if</span> isPrime(num: currentNumber) &#123;</span><br><span class="line">                primes.append(currentNumber)</span><br><span class="line">            &#125;</span><br><span class="line">            currentNumber += <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> primes</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 判断是否是素数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">isPrime</span><span class="params">(num: Int)</span></span> -&gt; <span class="type">Bool</span> &#123;</span><br><span class="line">        <span class="keyword">guard</span> num &gt; <span class="number">3</span> <span class="keyword">else</span> &#123; <span class="keyword">return</span> num &gt; <span class="number">1</span> &#125;</span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">2</span></span><br><span class="line">        <span class="keyword">while</span> i * i &lt; num &#123;</span><br><span class="line">            <span class="keyword">if</span> num % i == <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="3-BM（Boyer-Moore）算法"><a href="#3-BM（Boyer-Moore）算法" class="headerlink" title="3.BM（Boyer-Moore）算法"></a>3.BM（Boyer-Moore）算法</h1><p>对于工业级的软件开发来说，我们希望算法尽可能的高效，并且在极端情况下性能不要退化太严重，这时候使用BF或者RK就不太适合了，BF在极端情况下性能退化非常严重，RK算法设计一个合理的哈希算法并不容易。那么，对于查找是重要功能软件是如何处理的呢？</p>
<p>BM算法是非常高效的字符串匹配算法，有试验统计，它的性能是著名的<a href="[https://zh.wikipedia.org/wiki/%E5%85%8B%E5%8A%AA%E6%96%AF-%E8%8E%AB%E9%87%8C%E6%96%AF-%E6%99%AE%E6%8B%89%E7%89%B9%E7%AE%97%E6%B3%95](https://zh.wikipedia.org/wiki/克努斯-莫里斯-普拉特算法)">KMP 算法</a>3到4倍。</p>
<p>BM算法的核心思想并不难，字符串匹配算法的核心是，遇到不匹配的字符串时候，就将模式串向后移动一位，那么到底能不能找到一个规律，当遇到字符串不匹配时候，将模式串向后多移动几位又保证不会错过匹配字符的情况呢？</p>
<p>BM算法的本质其实就是在寻找这种规律，借助这种规律，在模式串与主串的匹配过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些一定不匹配的情况，将模式串向后多滑动几位。</p>
<p>BM算法分为两部分，分别是<strong>坏字符规则</strong>和<strong>好后缀规则</strong>。</p>
<h2 id="3-1-坏字符规则"><a href="#3-1-坏字符规则" class="headerlink" title="3.1 坏字符规则"></a>3.1 坏字符规则</h2><p>前两节讲的算法，匹配顺序都是从前往后匹配的，而BM算法的匹配是从后向前匹配的，按照下标从大到小匹配的。</p>
<p><img src="http://img.weidongfang.online/imgbed/540809418354024206d9989cb6cdd89e.jpg" alt></p>
<p>在匹配的过程中，当发现某个字符不匹配，这个不匹配的字符叫做<strong>坏字符</strong>（主串中的字符）。</p>
<p>坏字符规则的核心是，发现坏字符的处理，当发现坏字符时候并不会将模式串向后移动一位，然后继续从后向前匹配，而是在模式串中查找坏字符出现的第一个位置，这个下标记作xi，我们将坏字符在模式串中的位置记作si，如果坏字符在模式串中不存在，记作-1。那么模式串向后移动的位数就等于si-xi。</p>
<p><img src="http://img.weidongfang.online/imgbed/8f520fb9d9cec0f6ea641d4181eb432e.jpg" alt></p>
<p>根据坏字符的思想，BM算法代码如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//BM算法主体</span></span><br><span class="line"><span class="comment">//算法思想：模式串和主串从后向前匹配，找到第一个不匹配的位置，使用好后缀或者坏字符算法计算位移距离，尽可能的向后位移</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">boyerMoore</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">    <span class="keyword">let</span> pattern = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">    <span class="keyword">let</span> patternCharLocations = generateCharsDict(pattern: pattern)</span><br><span class="line">    <span class="keyword">let</span> mainStrAssist = generateGoodSuffixAssist(pattern: str)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>   <span class="comment">//表示模式串和主串对齐的第一个字符位置</span></span><br><span class="line">    <span class="keyword">while</span> i &lt;= str.<span class="built_in">count</span> - pattern.<span class="built_in">count</span> &#123;</span><br><span class="line">        <span class="comment">//从后向前匹配，找到坏字符位置</span></span><br><span class="line">        <span class="keyword">var</span> j = pattern.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">        <span class="comment">//如果模式串和主串对应位置匹配，则一直向前继续匹配</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == str[j + i] &#123;</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当j&lt;0时候，说明主串和模式串完全匹配，找到了第一个匹配的位置i</span></span><br><span class="line">        <span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根据坏字符规则更新模式串和主串对齐的起始位置</span></span><br><span class="line">        <span class="keyword">let</span> badCharacterMoveLength = (j - (patternCharLocations[str[j + i]] ?? -<span class="number">1</span>))</span><br><span class="line">        i = i + badCharacterMoveLength</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//生成模式串每个字符对应的位置,用于坏字符规则查找坏字符在模式串中位置</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">generateCharsDict</span><span class="params">(pattern: [Character])</span></span> -&gt; [<span class="type">Character</span>: <span class="type">Int</span>] &#123;</span><br><span class="line">    <span class="keyword">var</span> dict = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;pattern.<span class="built_in">count</span> &#123;</span><br><span class="line">        dict[pattern[index]] = index</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dict</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里我要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，选择最靠后的那个，因为这样不会让模式串滑动过多，导致本来可能匹配的情况被滑动略过。为了加快坏字符在模式串中位置的查找，这里同样建立一个哈希表存储模式串中每个字符最后一次出现的位置。</p>
<blockquote>
<p>这里需要注意的是，si-xi结果可能是负数，这样模式串不但不会向后移动，反而会倒推。所以BM算法还需要好后缀规则。</p>
</blockquote>
<h2 id="3-2-好后缀规则"><a href="#3-2-好后缀规则" class="headerlink" title="3.2 好后缀规则"></a>3.2 好后缀规则</h2><p>好后缀规则实际上和坏字符规则的思想类似，如下图所示。</p>
<p><img src="http://img.weidongfang.online/imgbed/d78990dbcb794d1aa2cf4a3c646ae58a.jpg" alt></p>
<p>坏字符规则本质上就是从模式串中查找最后一个和坏字符匹配的位置，好后缀规则本质上是从模式串中查找最后一个和好后缀匹配的位置，这两个规则该怎么配合呢？实际上很简单，当发现坏字符时候，分别计算坏字符移动的位数和好后缀移动位数，取最大的即可。</p>
<p><img src="http://img.weidongfang.online/imgbed/b9785be3e91e34bbc23961f67c234b63.jpg" alt></p>
<p>好后缀规则的原理就是这么简单，但是这里还有个关键问题没有讲到，那就是如何在模式串中查找好后缀出现的位置呢？如果每次都遍历查找，效率是非常低下的，这里其实有个技巧。</p>
<p>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置。而这个处理过程是非常有技巧并且很难懂的。</p>
<p>我们需要引入一个关键变量suffix数组，suffix数组的下标k，表示后缀子串的长度，下标对应的数组值存储的是，在模式串中跟好后缀相匹配的子串的起始下标，如图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/99a6cfadf2f9a713401ba8feac2484c2.jpg" alt></p>
<p>这里为了避免滑动过头，suffix存储的是最靠后的那个子串的起始位置。此外，我们还需要一个boolen数组prefix，记录模式串的后缀子串是否能匹配模式串的前缀子串。</p>
<p><img src="http://img.weidongfang.online/imgbed/279be7d64e6254dac1a32d2f6d1a2383.jpg" alt></p>
<p>这个数组的填充是非常巧妙的，详见代码所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//生成好后缀规则辅助数组</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">generateGoodSuffixAssist</span><span class="params">(pattern: [Character])</span></span> -&gt; (suffix: [<span class="type">Int</span>], <span class="keyword">prefix</span>:[<span class="type">Bool</span>]) &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="built_in">count</span> = pattern.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">var</span> suffix = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">init</span>(repeating: -<span class="number">1</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">    <span class="keyword">var</span> <span class="keyword">prefix</span> = <span class="type">Array</span>&lt;<span class="type">Bool</span>&gt;(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;(<span class="built_in">count</span> - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> j = i</span><br><span class="line">        <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == pattern[<span class="built_in">count</span> - <span class="number">1</span> - k] &#123;</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">            k += <span class="number">1</span></span><br><span class="line">            suffix[k] = j + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> j == -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">prefix</span>[k].toggle()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (suffix, <span class="keyword">prefix</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>至此好后缀规则已经讲完了，我们把好后缀规则加到前面坏字符规则代码里面，就可以得到BM算法的完整版本代码实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// 3.BM（Boyer-Moore）算法，基于坏字符和好后缀</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchInString</span> </span>&#123;</span><br><span class="line">    <span class="comment">//BM算法主体</span></span><br><span class="line">    <span class="comment">//算法思想：模式串和主串从后向前匹配，找到第一个不匹配的位置，使用好后缀或者坏字符算法计算位移距离，尽可能的向后位移</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">boyerMoore</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> str = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">        <span class="keyword">let</span> pattern = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">        <span class="keyword">let</span> patternCharLocations = generateCharsDict(pattern: pattern)</span><br><span class="line">        <span class="keyword">let</span> mainStrAssist = generateGoodSuffixAssist(pattern: str)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">var</span> i = <span class="number">0</span>   <span class="comment">//表示模式串和主串对齐的第一个字符位置</span></span><br><span class="line">        <span class="keyword">while</span> i &lt;= str.<span class="built_in">count</span> - pattern.<span class="built_in">count</span> &#123;</span><br><span class="line">            <span class="comment">//从后向前匹配，找到坏字符位置</span></span><br><span class="line">            <span class="keyword">var</span> j = pattern.<span class="built_in">count</span> - <span class="number">1</span></span><br><span class="line">            <span class="comment">//如果模式串和主串对应位置匹配，则一直向前继续匹配</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == str[j + i] &#123;</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当j&lt;0时候，说明主串和模式串完全匹配，找到了第一个匹配的位置i</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; <span class="number">0</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> i</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据坏字符规则更新模式串和主串对齐的起始位置</span></span><br><span class="line">            <span class="keyword">let</span> badCharacterMoveLength = (j - (patternCharLocations[str[j + i]] ?? -<span class="number">1</span>))</span><br><span class="line">            <span class="keyword">var</span> goodSuffixLength = <span class="number">0</span></span><br><span class="line">            <span class="keyword">if</span> j &lt; pattern.<span class="built_in">count</span> - <span class="number">1</span>&#123;</span><br><span class="line">                goodSuffixLength = goodSuffixMoveLength(index: j, length: pattern.<span class="built_in">count</span>, suffix: mainStrAssist.suffix, <span class="keyword">prefix</span>: mainStrAssist.<span class="keyword">prefix</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            i = i + <span class="built_in">max</span>(badCharacterMoveLength, goodSuffixLength)</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成模式串每个字符对应的位置,用于坏字符规则查找坏字符在模式串中位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">generateCharsDict</span><span class="params">(pattern: [Character])</span></span> -&gt; [<span class="type">Character</span>: <span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="keyword">var</span> dict = [<span class="type">Character</span>: <span class="type">Int</span>]()</span><br><span class="line">        <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;pattern.<span class="built_in">count</span> &#123;</span><br><span class="line">            dict[pattern[index]] = index</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dict</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成好后缀规则字符串位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">goodSuffixMoveLength</span><span class="params">(index: Int, length: Int, suffix: [Int], <span class="keyword">prefix</span>:[Bool])</span></span> -&gt; <span class="type">Int</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> k = length - <span class="number">1</span> - index</span><br><span class="line">        <span class="keyword">if</span> suffix[k] != -<span class="number">1</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> index - suffix[k] + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> r <span class="keyword">in</span> (index + <span class="number">2</span>)..&lt;(length - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">prefix</span>[length - r] == <span class="literal">true</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> r</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> length</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//生成好后缀规则辅助数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">generateGoodSuffixAssist</span><span class="params">(pattern: [Character])</span></span> -&gt; (suffix: [<span class="type">Int</span>], <span class="keyword">prefix</span>:[<span class="type">Bool</span>]) &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="built_in">count</span> = pattern.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">var</span> suffix = <span class="type">Array</span>&lt;<span class="type">Int</span>&gt;.<span class="keyword">init</span>(repeating: -<span class="number">1</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">var</span> <span class="keyword">prefix</span> = <span class="type">Array</span>&lt;<span class="type">Bool</span>&gt;(repeating: <span class="literal">false</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;(<span class="built_in">count</span> - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">var</span> j = i</span><br><span class="line">            <span class="keyword">var</span> k = <span class="number">0</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= <span class="number">0</span> &amp;&amp; pattern[j] == pattern[<span class="built_in">count</span> - <span class="number">1</span> - k] &#123;</span><br><span class="line">                j -= <span class="number">1</span></span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">                suffix[k] = j + <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> j == -<span class="number">1</span> &#123;</span><br><span class="line">                <span class="keyword">prefix</span>[k].toggle()</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (suffix, <span class="keyword">prefix</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>BM算法尽管难懂、复杂，但是匹配的效率却很高，在实际的软件开发中，特别是一些文本编辑器中，应用比较多。BM算法的核心思想是，利用模式串本身的特点，在模式串中某个字符与主串不匹配的时候，将模式串往后多滑动几位，以此来减少不必要的字符比较，提高匹配效率。</p>
<blockquote>
<p>这个算法体现的解决问题思想：</p>
<ol>
<li>当需要查找，又想不要太高的时间复杂度，我们可以使用散列表存储查找结果。</li>
<li>如果某个表达式计算开销较大又需要反复使用怎么办？预处理并做缓存。</li>
</ol>
</blockquote>
<h1 id="4-KMP（Knuth-Morris-Pratt）算法"><a href="#4-KMP（Knuth-Morris-Pratt）算法" class="headerlink" title="4.KMP（Knuth Morris Pratt）算法"></a>4.KMP（Knuth Morris Pratt）算法</h1><p>KMP算法是这几个字符串匹配算法中最难理解的，并且网上有很多讲解，这里我也就不浪费太多时间 在这个算法原理细节上了。</p>
<p>实际上，KMP算法原理和BM算法原理很相似，在BM算法中，我们从后向前匹配，找到不匹配的字符叫做<strong>坏字符</strong>，已经匹配的后缀子串叫做<strong>好后缀</strong>，当我们遇到 坏字符时候，通过坏字符法则和好后缀法则尽可能多的将后缀子串向后滑动。在KMP算法中，我们从前向后匹配，当遇到坏字符时候，之前已经匹配的子串叫做<strong>好前缀</strong>，我们拿好前缀的后缀子串和模式串的前缀做对比，找到第一个匹配的，然后模式串向后滑动到模式串前缀和好前缀后缀重叠为止，<strong>原理其实还是在遇到坏字符时候尽可能多的将模式串向后滑动</strong>，KMP基本原理图如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/f4ef2c1e6ce5915e1c6460c2e26c9469.jpg" alt></p>
<p>在这个算法中<strong>最核心的部分其实是如何计算好前缀的最长可匹配前缀子串</strong>，我们假设现在已经得到了一个next数组来存储最长可匹配前缀子串的位置，那么KMP算法的主体其实很简单了，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">    <span class="keyword">let</span> b = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">    <span class="keyword">let</span> n = a.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">let</span> m = b.<span class="built_in">count</span></span><br><span class="line">    <span class="keyword">let</span> next = getNexts(pattern: b)</span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">        <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j] &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">            j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">            j += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">          <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当然，我们也可以通过最笨的暴力方法得到每个好前缀的最长可匹配前缀子串，但是那样算法效率将 大大打折，特别是在模式串比较长的场景下。实际上，我们可以通过动态规划的方法快速的计算出来，这里的关键在于如何利用已经计算出来的值推算出下一个next数组中的值。</p>
<p>前面已经给出了KMP算法的框架代码了，现在把这部分代码合并起来，这两部分合在一起，就是整个KMP算法的代码实现。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">//4.KMP</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">SearchInString</span> </span>&#123;</span><br><span class="line">    <span class="comment">// a, b分别是主串和模式串；n, m分别是主串和模式串的长度。</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">kmp</span><span class="params">(str: String, pattern: String)</span></span> -&gt; <span class="type">Int?</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> a = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(str)</span><br><span class="line">        <span class="keyword">let</span> b = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">        <span class="keyword">let</span> n = a.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> m = b.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">let</span> next = getNexts(pattern: b)</span><br><span class="line">        <span class="keyword">var</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;n &#123;</span><br><span class="line">            <span class="keyword">while</span> j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j] &#123; <span class="comment">// 一直找到a[i]和b[j]</span></span><br><span class="line">                j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                j += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123; <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">              <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="comment">// b表示模式串，m表示模式串的长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">func</span> <span class="title">getNexts</span><span class="params">(pattern: [Character])</span></span> -&gt; [<span class="type">Int</span>] &#123;</span><br><span class="line">        <span class="comment">// b表示模式串，m表示模式串的长度</span></span><br><span class="line">        <span class="keyword">let</span> b = <span class="type">Array</span>&lt;<span class="type">Character</span>&gt;(pattern)</span><br><span class="line">        <span class="keyword">let</span> m = b.<span class="built_in">count</span></span><br><span class="line">        <span class="keyword">var</span> next = [<span class="type">Int</span>](repeating: -<span class="number">1</span>, <span class="built_in">count</span>: m)</span><br><span class="line">        <span class="keyword">var</span> k = -<span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;m &#123;</span><br><span class="line">            <span class="keyword">while</span> k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i] &#123;</span><br><span class="line">                k = next[k]</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> b[k + <span class="number">1</span>] == b[i] &#123;</span><br><span class="line">                k += <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">            next[i] = k</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Refersnce</p>
<p><a href="https://time.geekbang.org/column/article/71187" target="_blank" rel="noopener">https://time.geekbang.org/column/article/71187</a></p>
</blockquote>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>【笔记】RxSwift简介</title>
    <url>/posts/2019-10/31385.html</url>
    <content><![CDATA[<p>RxSwift是一个可以帮助我们简化异步编程的框架，它拓展了观察者模式，能够帮助你自由组合多个异步事件，而不需要去关心线程、同步、线程安全等问题、并发等问题。RxSwift属于函数响应式编程，它通过构建函数操作数据序列，然后对这些序列做出响应的编程方式。</p>
<a id="more"></a>

<h2 id="1-RxSwift能帮助我们做什么"><a href="#1-RxSwift能帮助我们做什么" class="headerlink" title="1. RxSwift能帮助我们做什么?"></a>1. RxSwift能帮助我们做什么?</h2><h3 id="1-1-Target-Action"><a href="#1-1-Target-Action" class="headerlink" title="1.1 Target Action"></a>1.1 Target Action</h3><p>在iOS开发中, 我们经常给UIbutton或者UIView添加交互事件, 引入RxSwift之后, 我们可以换一种方式了. 这种方式无需使用Target Action, 这样使代码逻辑更加清晰.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">redButton.rx.tap.subscribe(onNext:&#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"redbutton"</span>)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-2-代理"><a href="#1-2-代理" class="headerlink" title="1.2 代理"></a>1.2 代理</h3><p>传统的代理, 需要实现代理方法, 在代理方法中处理逻辑代码, 引入RxSwift后, 直接就能得到想要的结果. 常用的UIscrollView, UITableView代理在RxSwift中都有相关的实现, 我们在声明自己代理时候, 可以使用类似的方法. </p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">scrollView.rx.contentOffset.subscribe &#123; (contentOffset) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(contentOffset)</span><br><span class="line">&#125;.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-3-闭包回掉"><a href="#1-3-闭包回掉" class="headerlink" title="1.3 闭包回掉"></a>1.3 闭包回掉</h3><p>使用回掉RxSwift中订阅代理回掉闭包, 在订阅中处理相关的网络状态.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">URLSession</span>.shared.rx.data(request: <span class="type">URLRequest</span>(url: url))</span><br><span class="line">.subscribe(onNext: &#123; data <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Data Task Success with count: \(data.count)"</span>)</span><br><span class="line">&#125;, onError: &#123; error <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"Data Task Error: \(error)"</span>)</span><br><span class="line">&#125;)</span><br><span class="line">.disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-4-通知"><a href="#1-4-通知" class="headerlink" title="1.4 通知"></a>1.4 通知</h3><p>使用RxSwift订阅通知, 无需管理观测者的声明周期, 这样可以有更多的精力去关注业务逻辑代码.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NotificationCenter.default.rx</span><br><span class="line">	.notification(.UIApplicationWillEnterForeground)</span><br><span class="line">	.subscribe(onNext: &#123; (notification) in</span><br><span class="line">	    print(&quot;Application Will Enter Foreground&quot;)</span><br><span class="line">	&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-5-KVO"><a href="#1-5-KVO" class="headerlink" title="1.5 KVO"></a>1.5 KVO</h3><p>RxSwift可以直接使用KVO, 在subscribe中监听相关属性的变化.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">scrollView.rx.observe(CGRect.self, #keyPath(UIScrollView.frame))</span><br><span class="line">    .subscribe(onNext: &#123; (frame) in</span><br><span class="line">        print(frame?.debugDescription)</span><br><span class="line">&#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-6-多个任务之间有依赖关系"><a href="#1-6-多个任务之间有依赖关系" class="headerlink" title="1.6 多个任务之间有依赖关系"></a>1.6 多个任务之间有依赖关系</h3><p>使用RxSwift实现多个任务的依赖关系, 无需嵌套多层, 容易维护.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 用 Rx 封装接口</span><br><span class="line">enum Api &#123;</span><br><span class="line">    /// 通过用户名密码取得一个 token</span><br><span class="line">    static func token(username: String, password: String) -&gt; Observable&lt;String&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    /// 通过 token 取得用户信息</span><br><span class="line">    static func userInfo(token: String) -&gt; Observable&lt;UserInfo&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 通过用户名和密码获取用户信息</span><br><span class="line">Api.token(username: &quot;beeth0ven&quot;, password: &quot;987654321&quot;)</span><br><span class="line">    .flatMapLatest(Api.userInfo)</span><br><span class="line">    .subscribe(onNext: &#123; userInfo in</span><br><span class="line">        print(&quot;获取用户信息成功: \(userInfo)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;获取用户信息失败: \(error)&quot;)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="1-7-等待多个并发任务完成后处理结果"><a href="#1-7-等待多个并发任务完成后处理结果" class="headerlink" title="1.7 等待多个并发任务完成后处理结果"></a>1.7 等待多个并发任务完成后处理结果</h3><p>并发任务, 可以通过zip方法来统一调用.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 用 Rx 封装接口</span><br><span class="line">enum Api &#123;</span><br><span class="line"></span><br><span class="line">    /// 取得老师的详细信息</span><br><span class="line">    static func teacher(teacherId: Int) -&gt; Observable&lt;Teacher&gt; &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">    /// 取得老师的评论</span><br><span class="line">    static func teacherComments(teacherId: Int) -&gt; Observable&lt;[Comment]&gt; &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">/// 同时取得老师信息和老师评论</span><br><span class="line">Observable.zip(</span><br><span class="line">      Api.teacher(teacherId: teacherId),</span><br><span class="line">      Api.teacherComments(teacherId: teacherId)</span><br><span class="line">    ).subscribe(onNext: &#123; (teacher, comments) in</span><br><span class="line">        print(&quot;获取老师信息成功: \(teacher)&quot;)</span><br><span class="line">        print(&quot;获取老师评论成功: \(comments.count) 条&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;获取老师信息或评论失败: \(error)&quot;)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h2 id="2-一个简单的输入验证dmeo"><a href="#2-一个简单的输入验证dmeo" class="headerlink" title="2. 一个简单的输入验证dmeo"></a>2. 一个简单的输入验证dmeo</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private func setupViewModel() &#123;</span><br><span class="line">    </span><br><span class="line">    let usernameValid = username.rx.text.orEmpty.map&#123;$0.count &gt;= 6&#125;.share(replay: 1)</span><br><span class="line">    usernameValid.bind(to: password.rx.isEnabled).disposed(by: disposeBag)</span><br><span class="line">    usernameValid.bind(to: usernameNotice.rx.isHidden).disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    let passwdValid = password.rx.text.orEmpty.map&#123;$0.count &gt;= 6&#125;.share(replay: 1)</span><br><span class="line">    passwdValid.bind(to: passwordNotice.rx.isHidden).disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    let everythingValid = Observable.combineLatest(usernameValid, passwdValid) &#123; $0 &amp;&amp; $1 &#125;.share(replay: 1)    //??</span><br><span class="line">    everythingValid.bind(to: confirmButton.rx.isEnabled).disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    confirmButton.rx.tap.subscribe(onNext: &#123;[weak self] in</span><br><span class="line">        self?.showAlert()</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private func showAlert() &#123;</span><br><span class="line">    let alertController = UIAlertController(title: &quot;Rx Helloworld&quot;, message: nil, preferredStyle: .alert)</span><br><span class="line">    let action = UIAlertAction(title: &quot;confirm&quot;, style: .default, handler: nil)</span><br><span class="line">    alertController.addAction(action)</span><br><span class="line">    present(alertController, animated: true, completion: nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-函数响应式编程"><a href="#3-函数响应式编程" class="headerlink" title="3. 函数响应式编程"></a>3. 函数响应式编程</h2><p><strong>函数式编程:</strong>是一种编程范式, 他需要我们将函数作为参数传递, 或者作为返回值返还. 我们可以通过组合不同的函数得到想要的结果. 函数式编程更加的灵活/高复用性/简洁/易维护/适应各种需求变化.</p>
<p>我们通过不同的构建函数来创建所需要的数据序列. 最后通过适当的方式来响应这个序列. 这就是<strong>函数响应式编程</strong>.</p>
<p>在RxSwift中有个比较重要的概念就是<strong>数据绑定(订阅)</strong>. 就是指可被监听的序列绑定到观察者上. </p>
<h2 id="4-RxSwift核心"><a href="#4-RxSwift核心" class="headerlink" title="4. RxSwift核心"></a>4. RxSwift核心</h2><ol>
<li>Observable - 产生事件</li>
<li>Observer - 响应事件</li>
<li>Operator - 创建变化组合事件</li>
<li>Disposable - 管理绑定(订阅)的生命周期</li>
<li>Schedulers - 线程队列调配</li>
</ol>
<h3 id="4-1-1-Observable-可被监听的序列"><a href="#4-1-1-Observable-可被监听的序列" class="headerlink" title="4.1.1 Observable - 可被监听的序列"></a>4.1.1 Observable - 可被监听的序列</h3><p>所有的事物都是序列. Observable可以用来描述元素异步产生的序列. 我们生活中许多事物都可以通过它来表示, 例如: 温度变化的序列(Observable<double>), 网络请求JSON序列(Observable<json>). </json></double></p>
<p><strong>Event - 事件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum Event&lt;Element&gt; &#123;</span><br><span class="line">    case next(Element)</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>next - 序列产生一个新的元素;</li>
<li>error - 创建序列时候产生一个错误,导致序列终止;</li>
<li>completed - 序列的所有元素都已经成功产生,整个序列已经完成;</li>
</ul>
<p><strong>特征序列</strong></p>
<p>RxSwift中, Observable也存在一些特征序列, 这些特征序列可以帮助我们更准确的描述序列. 并且他们还可以给我们提供语法糖, 让我们使用更优雅的方式书写代码.分别有: Single, Completable, Maybe, Driver, ControlEvent. </p>
<h3 id="4-1-2-Single"><a href="#4-1-2-Single" class="headerlink" title="4.1.2 Single"></a>4.1.2 Single</h3><p>Singles=使Observable的另一个版本. 不像Observable可以发出多个元素, 它要么只发出一个元素, 要么产生一个error事件.</p>
<ul>
<li>发出一个元素, 或者一个error事件</li>
<li>不会共享状态变化</li>
</ul>
<p>一个常见的例子使执行http请求, 然后返回一个应答或者错误. 不过你<strong>可以使用Single来描述任何只有一个元素的序列</strong>.</p>
<p><code>SingleEvent</code>的枚举:</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">SingleEvent</span>&lt;<span class="title">Element</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">case</span> success(<span class="type">Element</span>)</span><br><span class="line">    <span class="keyword">case</span> error(<span class="type">Swift</span>.<span class="type">Error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-3-Completable"><a href="#4-1-3-Completable" class="headerlink" title="4.1.3 Completable"></a>4.1.3 Completable</h3><p>Completable是Observale的另一个版本. 它要么产生一个completed事件, 要么产生一个error事件. </p>
<ul>
<li>发出零个元素</li>
<li>发出一个completed事件或者一个error事件</li>
<li>不会共享状态变化</li>
</ul>
<p>Completable适用于那种只关心任务是否完成, 而不需要在意任务返回值的情况. 他和Observable<void>有点相似.</void></p>
<p><strong>CompletableEvent的枚举:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public enum CompletableEvent &#123;</span><br><span class="line">    case error(Swift.Error)</span><br><span class="line">    case completed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-Maybe"><a href="#4-1-4-Maybe" class="headerlink" title="4.1.4 Maybe"></a>4.1.4 Maybe</h3><p>Maybe是Observable的另一个版本. 介于Single和Completable之间, 它要么只能发出一个元素, 要么产生一个completed事件, 要么产生一个error事件.</p>
<ul>
<li>发出一个元素或者一个completed事件或者一个error事件</li>
<li>不会共享状态变化</li>
</ul>
<h3 id="4-1-5-Driver"><a href="#4-1-5-Driver" class="headerlink" title="4.1.5 Driver"></a>4.1.5 Driver</h3><p>Driver是一个精心准备的特征序列. 它主要是为了简化UI层代码. 不过如果你遇到的序列具有以下特征, 你也可以使用它:</p>
<ul>
<li>不会产生error事件</li>
<li>一定会在MainScheduler监听(主线程监听)</li>
<li>共享状态变化</li>
</ul>
<p>这些都是驱动UI的序列所具有的特征.</p>
<p><strong>示例代码:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/// 模拟根据shu用户输入,产生一个网络请求,网络请求结果绑定到UI上,一个UI空间展示数量,另一个产生结果</span><br><span class="line">private func testDriver() &#123;</span><br><span class="line">    let results = username.rx.text.asDriver().distinctUntilChanged()        // 将普通序列转换为 Driver</span><br><span class="line">        .throttle(0.03)</span><br><span class="line">        .flatMapLatest &#123; query in</span><br><span class="line">            return self.fetchAutoCompleteItems(keyword: query).asDriver(onErrorJustReturn: [])</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    results.map&#123;&quot;\($0.count)&quot;&#125;.drive(usernameNotice.rx.text).disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    results.map&#123;&quot;\($0.description)&quot;&#125;.drive(passwordNotice.rx.text).disposed(by: disposeBag)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private func fetchAutoCompleteItems(keyword: String?) -&gt; Observable&lt;[String]&gt; &#123;</span><br><span class="line">    return Observable&lt;[String]&gt;.create(&#123; (observable) -&gt; Disposable in</span><br><span class="line">        DispatchQueue.global().asyncAfter(deadline: DispatchTime.now() + 0.5, execute: &#123;</span><br><span class="line">            observable.onNext([keyword!])</span><br><span class="line">        &#125;)</span><br><span class="line">        return Disposables.create()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>任何被监听的序列都可以呗转换为Driver, 只要满足三个条件: 不会产生error事件;一定在MainScheduler监听(主线程监听);共享状态变化;</p>
<p>drive方法只能被Driver调用. 这意味着, 如果你发现代码存在driver, 那么这个序列不会产生错误事件并且一定在主线程监听. 这样你可以安全的绑定UI元素.</p>
<h3 id="4-1-6-ControlEvent"><a href="#4-1-6-ControlEvent" class="headerlink" title="4.1.6 ControlEvent"></a>4.1.6 ControlEvent</h3><p>ControlEvent专门用于描述UI控件所产生的事件, 它具有以下特征:</p>
<ul>
<li>不会产生error事件</li>
<li>一定在MainScheduler订阅(主线程订阅)</li>
<li>一定在MainScheduler监听(主线程监听)</li>
<li>共享状态变化</li>
</ul>
<h3 id="4-2-Observer-观察者"><a href="#4-2-Observer-观察者" class="headerlink" title="4.2 Observer - 观察者"></a>4.2 Observer - 观察者</h3><p>观察者是用来监听事件, 然后它需要这个事件做出响应. 例如: 弹出提示框就是观察者, 它对点击按钮这个事件做出响应.</p>
<p><strong>如何创建观察者</strong></p>
<p>和Observable一样, 框架已经帮我们创建好很多的观察者. 例如: view是否隐藏, button是否可点击, label当前文本, imageView的当前图片等.</p>
<p>另外, 有一些自定义的观察者是需要我们自己创建的. 例如:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tap.subscribe(onNext: &#123; [weak self] in</span><br><span class="line">    self?.showAlert()</span><br><span class="line">&#125;, onError: &#123; error in</span><br><span class="line">    print(&quot;发生错误： \(error.localizedDescription)&quot;)</span><br><span class="line">&#125;, onCompleted: &#123;</span><br><span class="line">    print(&quot;任务完成&quot;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>创建观察者最直接的方法就是Observable的subscribe方法后面的描述, 事件发生时, 需要如何做出响应. 而观察者就是由后面的onNext, onError, onCompleted等这些闭包构建出来的.</p>
<h3 id="4-2-1-AnyObserver"><a href="#4-2-1-AnyObserver" class="headerlink" title="4.2.1 AnyObserver"></a>4.2.1 AnyObserver</h3><p>AnyObservable可以用来描述任意一种观察者.</p>
<p><strong>根据逻辑判断是否显示usernameNotice:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">usernameValid.bind(to: usernameNotice.rx.isHidden).disposed(by: disposeBag)</span><br><span class="line"></span><br><span class="line">相当于下面代码:</span><br><span class="line"></span><br><span class="line">let usernameNoticeObserver: AnyObserver&lt;Bool&gt; = AnyObserver &#123; [weak self] (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let isHidden):</span><br><span class="line">        self?.usernameNotice.isHidden = isHidden</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(error)</span><br><span class="line">    case .completed:</span><br><span class="line">        print(&quot;completed&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">usernameValid.bind(to: usernameNoticeObserver).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p><strong>对网络请求结果的处理:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">URLSession.shared.rx.data(request: URLRequest(url: url))</span><br><span class="line">    .subscribe(onNext: &#123; data in</span><br><span class="line">        print(&quot;Data Task Success with count: \(data.count)&quot;)</span><br><span class="line">    &#125;, onError: &#123; error in</span><br><span class="line">        print(&quot;Data Task Error: \(error)&quot;)</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">相当于下面拆分后的代码:</span><br><span class="line"></span><br><span class="line">let observer: AnyObserver&lt;Data&gt; = AnyObserver &#123; (event) in</span><br><span class="line">    switch event &#123;</span><br><span class="line">    case .next(let data):</span><br><span class="line">        print(&quot;Data Task Success with count: \(data.count)&quot;)</span><br><span class="line">    case .error(let error):</span><br><span class="line">        print(&quot;Data Task Error: \(error)&quot;)</span><br><span class="line">    default:</span><br><span class="line">        break</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">URLSession.shared.rx.data(request: URLRequest(url: url))</span><br><span class="line">    .subscribe(observer)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-Binder"><a href="#4-2-2-Binder" class="headerlink" title="4.2.2 Binder"></a>4.2.2 Binder</h3><p>和Observable一样, Observer也存在特征观察者, 例如: <code>Binder</code>.</p>
<p>Binder主要有以下两个特征:</p>
<ul>
<li>不会处理错误事件</li>
<li>确保绑定都是在给定Scheduler上执行(默认MainScheduler)</li>
</ul>
<p>一旦产生错误事件, 在调试环境下将执行fatalError, 在发布环境将打印错误信息.</p>
<p>如上<code>4.2.1-根据逻辑判断是否显示usernameNotice</code>代码所示, 观察者是一个UI观察者, 所以它在响应事件时候, 只会处理next事件, 并且更新UI的操作需要在主线程上执行. 因此更好的方案就是使用Binder:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let observer: Binder&lt;Bool&gt; = Binder.init(usernameNotice) &#123; (usernameNotice, isHidden) in</span><br><span class="line">    usernameNotice.isHidden = isHidden</span><br><span class="line">&#125;</span><br><span class="line">usernameValid.bind(to: observer).disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>Binder只处理next事件, 并且保证响应next事件的代码一定在Scheduler上执行, 这里采用默认的MainScheduler.</p>
<p>由于页面是否隐藏式一个常用的观察者, 所以应该让所有的UIView都提供这种观察者:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">extension Reactive where Base: UIView &#123;</span><br><span class="line">    fileprivate var isVisible: Binder&lt;Bool&gt; &#123;</span><br><span class="line">        return Binder(self.base, binding: &#123; (view, hidden) in</span><br><span class="line">            view.isHidden = hidden</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-Observable-amp-Observer既是可被监听的序列也是观察者"><a href="#4-3-Observable-amp-Observer既是可被监听的序列也是观察者" class="headerlink" title="4.3 Observable &amp; Observer既是可被监听的序列也是观察者"></a>4.3 Observable &amp; Observer既是可被监听的序列也是观察者</h3><p>我们所遇到的事务中, 有一部分非常特别, 他们既是可被监听的序列, 也是由外部文本序列来控制的当前显示内容的观察者. 许多的UI控件都有这种特性, 比如switch开关的状态, segmentControl的选中索引, datePicker的选中日期等等.</p>
<p>RxSwift中定义了一些辅助类型, 他们既是可被监听的序列, 也是观察者. 使用合适的辅助类型, 能够帮助你更加准确的描述事物的特征: AsyncSubject, PublishSubject, ReplaySubject, BehaviorSubject, Variable, ControlProperty.</p>
<h3 id="4-3-1-AsyncSubject"><a href="#4-3-1-AsyncSubject" class="headerlink" title="4.3.1 AsyncSubject"></a>4.3.1 AsyncSubject</h3><p>AsyncSubject将在源Observable产生完成事件后, 发出最后一个元素(仅仅只有最后一个元素), 如果源Observable没有发出任何元素, 只有一个完成事件. 那么AsyncSubject也只有一个完成事件.</p>
<p>它会对随后的观察者发出最终元素. 如果源Observable产生了一个error事件而终止, AsnycSubject就不会发出任何元素, 而是将这个error事件发送出来.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private func testAsyncSubject() &#123;</span><br><span class="line">    let subject = AsyncSubject&lt;String&gt;()</span><br><span class="line">    subject.subscribe(onNext: &#123; (element) in</span><br><span class="line">        print(element)</span><br><span class="line">    &#125;, onError: &#123; (error) in</span><br><span class="line">        print(error)</span><br><span class="line">    &#125;, onCompleted: &#123;</span><br><span class="line">        print(&quot;on completed&quot;)</span><br><span class="line">    &#125;).disposed(by: disposeBag)</span><br><span class="line">    </span><br><span class="line">    subject.onNext(&quot;111&quot;)</span><br><span class="line">    subject.onNext(&quot;222&quot;)</span><br><span class="line">    subject.onNext(&quot;333&quot;)</span><br><span class="line">    subject.onCompleted()   //只会发出最后一个元素 &quot;333&quot;, 调用onCompleted才会发出元素,不调用这不会发出任何元素.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-2-PublishSubject"><a href="#4-3-2-PublishSubject" class="headerlink" title="4.3.2 PublishSubject"></a>4.3.2 PublishSubject</h3><p>PublishSubject将对观察者发送订阅后产生的元素, 而在订阅前发出的元素将不会发送给观察者. 如果你希望观察者接受所有的元素, 你可以通过Observale的create方法来创建Observale或者使用ReplaySubject.</p>
<p>如果Observable因为产生一个error事件而终止, 则PublishSibject就不会发出任何元素, 而将这个error事件发送出来.</p>
<h3 id="4-3-3-ReplaySubject"><a href="#4-3-3-ReplaySubject" class="headerlink" title="4.3.3 ReplaySubject"></a>4.3.3 ReplaySubject</h3><p>ReplaySubject将对观察者发送全部的元素, 无论观察者何时进行订阅的.</p>
<p>这里有多个版本的ReplaySubject, 有的只会将最新的n歌元素发送给观察者, 有的只会将限定时间段内最新的元素发送给观察者.</p>
<p>如果把ReplaySubject当做观察者来使用, 注意不要再多个县城调用onNext, onError或者onCompleted. 这样会导致无需调用, 造成意想不到的结果.</p>
<h3 id="4-3-4-BehaviorSubject"><a href="#4-3-4-BehaviorSubject" class="headerlink" title="4.3.4 BehaviorSubject"></a>4.3.4 BehaviorSubject</h3><p>当观察者对BehaviorSubject进行订阅时候, 它会将源Observable中最新的元素发送出来(如果不存在就发出默认元素). 然后将随后产生的元素发送出来.</p>
<p>如果源产生一个error事件而终止, BehaviorSubject就不会发出任何元素, 而是将这个error事件发送出来.</p>
<h3 id="4-3-5-Variable"><a href="#4-3-5-Variable" class="headerlink" title="4.3.5 Variable"></a>4.3.5 Variable</h3><p>即将废弃, 使用<code>BehaviorRelay</code>代替.</p>
<h3 id="4-3-6-ControlProperty"><a href="#4-3-6-ControlProperty" class="headerlink" title="4.3.6 ControlProperty"></a>4.3.6 ControlProperty</h3><p>ControlProperty专门用来描述UI控件的, 具有以下特征:</p>
<ul>
<li>不会产生error事件</li>
<li>一定在MainScheduler订阅</li>
<li>一定在MainScheduler监听</li>
<li>共享状态变化</li>
</ul>
<h3 id="4-4-Operator-操作符"><a href="#4-4-Operator-操作符" class="headerlink" title="4.4 Operator - 操作符"></a>4.4 Operator - 操作符</h3><p>操作符可以帮助我们创建新的序列, 或者变化组合原有的序列, 从而生成一个新的序列. 例如map和combineLatest都是操作符, 它们可以帮助我们构建所需要的序列.</p>
<ul>
<li>filter: 过滤, 符合条件的元素生成新的序列;</li>
<li>map: 变形, 将序列中所有的元素进行变形操作;</li>
<li>zip: 配对, 将两个或者多个Observable序列匹配起来, 例如等待两个事情完成后处理结果;</li>
</ul>
<p>Rx提供了充分的操作符帮助我们来创建序列. 如果内置操作符无法满足你的需求, 你也可以自定义操作符.</p>
<p>如果你不知道该如何选择操作符, 可以参考决策树: <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation/content/decision_tree.html" target="_blank" rel="noopener">如何选择操作符?</a></p>
<h3 id="4-5-Disposable-可被清除的资源"><a href="#4-5-Disposable-可被清除的资源" class="headerlink" title="4.5 Disposable - 可被清除的资源"></a>4.5 Disposable - 可被清除的资源</h3><p>通常来说, 一个<strong>序列如果发出了error或者completed事件, 那么所有的内部资源都会被释放</strong>. 如果你需要提前释放那些资源或取消订阅的话, 那么你可以对返回的<code>可被清除的资源</code>调用dispose方法.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">self.disposable = textField.rx.text.orEmpty</span><br><span class="line">        .subscribe(onNext: &#123; text in print(text) &#125;)</span><br><span class="line">self.disposable?.dispose()</span><br></pre></td></tr></table></figure>

<p>调用dispose方法后, 订阅将被取消, 并且内存资源会被释放. 通常情况下, 你是不需要手动调用dispose方法的. 推荐使用清楚包(DisposeBag)或者takeUntil操作符来管理订阅的声明周期.</p>
<p>Swift中我们习惯使用ARC管理内存. 我们可以使用ARC来管理订阅的声明周期. 在实例对象中声明DisposeBag类型的属性, 使用disposeBag属性管理订阅的声明周期.</p>
<p>另一种实现自动取消订阅的方法就是使用takeUntil操作符, 这会使得订阅一直持续到控制器的dealloc事件产生为止.</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">func</span> <span class="title">viewDidLoad</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">super</span>.viewDidLoad()</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="number">_</span> = usernameValid</span><br><span class="line">        .takeUntil(<span class="keyword">self</span>.rx.deallocated)</span><br><span class="line">        .bind(to: passwordOutlet.rx.isEnabled)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-Schedulers-调度器"><a href="#4-6-Schedulers-调度器" class="headerlink" title="4.6 Schedulers - 调度器"></a>4.6 Schedulers - 调度器</h3><p>Schedulers是Rx实现多线程得核心模块, 它主要用于控制任务在哪个线程或者队列运行.</p>
<p><strong>GCD实现多线程实例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DispatchQueue.global(qos: .userInitiated).async &#123;</span><br><span class="line">    let data = try? Data(contentsOf: url)</span><br><span class="line">    DispatchQueue.main.async &#123;</span><br><span class="line">        self.data = data</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>RxSwift实现多线程示例:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let rxData: Observable&lt;Data&gt; = ...</span><br><span class="line"></span><br><span class="line">rxData</span><br><span class="line">    .subscribeOn(ConcurrentDispatchQueueScheduler(qos: .userInitiated))</span><br><span class="line">    .observeOn(MainScheduler.instance)</span><br><span class="line">    .subscribe(onNext: &#123; [weak self] data in</span><br><span class="line">        self?.data = data</span><br><span class="line">    &#125;)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p><strong>subscribeOn:</strong>我们使用subscribeOn来决定数据序列的构建函数在哪个Scheduler上运行. 以上例子中, 由于获取Data需要花费很长时间, 所以subscribeOn切换到后台Scheduler来获取Data. 这样可以避免主线程被阻塞.</p>
<p><strong>observeOn:</strong>我们用observeOn来决定在哪个Scheduler监听这个数据序列. 上面例子中我们使用observeOn方法切换到主线程来监听并且处理结果.</p>
<p>一个典型的例子就是, 在后台发起网络请求, 然后解析数据, 最后在主线程刷新页面. 你就可以先用subcribeOn切换到后台去发送网络请求并解析数据, 最后使用observeOn切换到主线程更新页面.</p>
<ul>
<li><strong>MainScheduler:</strong> 主线程, 如果你需要执行一些UI相关任务, 就需要切换到该Scheduler运行.</li>
<li><strong>SerialDispatchQueueScheduler:</strong> 抽象了串行DispatchQueue, 如果你需要执行一些串行任务, 可以切换到这个Scheduler运行.</li>
<li><strong>ConcurrentDispatchQueueScheduler:</strong> 抽象了并行DispatchQueue, 如果你需要执行一些并发任务, 可以切换到这个Scheduler运行.</li>
<li><strong>OperationQueueScheduler:</strong> 抽象了NSOperationQueue. 具备NSOperationQueue的一些特定,例如你可以设置maxConcurrentOperationCount来控制同时执行并发任务的最大数量.</li>
</ul>
<h3 id="4-7-Error-Handling-错误处理"><a href="#4-7-Error-Handling-错误处理" class="headerlink" title="4.7 Error Handling - 错误处理"></a>4.7 Error Handling - 错误处理</h3><p>一旦序列产生了一个error事件, 整个序列将被终止. RxSwift主要有两种错误处理机制: retry, catch</p>
<h4 id="1-retry-重试"><a href="#1-retry-重试" class="headerlink" title="1. retry - 重试"></a>1. retry - 重试</h4><p>retry可以让序列在发生错误后重试,如果<code>query.retry(3)</code>, 表示当序列发生错误时候, 进行重试操作, 并且最多重试3次.</p>
<h4 id="2-retryWhen"><a href="#2-retryWhen" class="headerlink" title="2. retryWhen"></a>2. retryWhen</h4><p>当发生错误时候, 经过一端延时后进行重试. </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 请求 JSON 失败时，等待 5 秒后重试，</span><br><span class="line">let retryDelay: Double = 5  // 重试延时 5 秒</span><br><span class="line"></span><br><span class="line">rxJson</span><br><span class="line">    .retryWhen &#123; (rxError: Observable&lt;Error&gt;) -&gt; Observable&lt;Int&gt; in</span><br><span class="line">        return Observable.timer(retryDelay, scheduler: MainScheduler.instance)</span><br><span class="line">    &#125;</span><br><span class="line">    .subscribe(...)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<h4 id="3-catchError-恢复"><a href="#3-catchError-恢复" class="headerlink" title="3. catchError - 恢复"></a>3. catchError - 恢复</h4><p>catchError可以在错误产生时候, 用一个备用元素或者一组备用元素将错误替换掉: </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">searchBar.rx.text.orEmpty</span><br><span class="line">    ...</span><br><span class="line">    .flatMapLatest &#123; query -&gt; Observable&lt;[Repository]&gt; in</span><br><span class="line">        ...</span><br><span class="line">        return searchGitHub(query)</span><br><span class="line">            .catchErrorJustReturn([])</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">    .bind(to: ...)</span><br><span class="line">    .disposed(by: disposeBag)</span><br></pre></td></tr></table></figure>

<p>如上所示, 当产生错误时候, 就返回一个空数组, 于是就会显示一个空列表页面.</p>
<h4 id="4-Result"><a href="#4-Result" class="headerlink" title="4. Result"></a>4. Result</h4><p>我们可以使用<code>Result</code>类型包装序列的结果, 如果发生错误则使用failure包装错误类型, 如果成功则使用success包装需要返回的元素. 这样即使序列产生错误也不会终止这个那个序列. 就算网络请求失败, 整个订阅依然存在. 如果用户再次点击更新按钮, 也是能够发起网络请求进行更新操作的.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 自定义一个枚举类型 Result</span><br><span class="line">public enum Result&lt;T&gt; &#123;</span><br><span class="line">    case success(T)</span><br><span class="line">    case failure(Swift.Error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="5-一些问题以及解答"><a href="#5-一些问题以及解答" class="headerlink" title="5.一些问题以及解答"></a>5.一些问题以及解答</h1><p>什么是函数式编程?</p>
<blockquote>
<p><strong>函数式编程</strong>是一种编程范式, 它需要我们将函数作为参数进行传递, 或者作为返回值返还. 我们可以通过组合不同的函数来得到想要的结果. 举例swift提供的高阶函数:filter,map,reduce,flatMap等.</p>
</blockquote>
<p>什么是响应式编程?</p>
<blockquote>
<p>我们通过不同的构建函数, 来创建所需要的数据序列. 最后通过适当的方式来响应这个序列. 这就是<strong>函数响应式编程</strong>.</p>
</blockquote>
<p>使用RxSwift有什么好处?</p>
<blockquote>
<p>1.更加方便的实现数据绑定，构建清晰的数据流。结合MVVM使用RxSwift实现数据绑定，代码逻辑也更加清晰。</p>
<p>2.将复杂业务代码分离到ViewModel中，减轻Controller的负担。（通过官方示例Demo来说明）</p>
</blockquote>
<p>RxSwift常用变形函数？</p>
<blockquote>
<p>map：变形，flatMapLeatest：只接受最新的一个，比如一次发出2个，只会对最新发出的一个做响应。</p>
</blockquote>
<p>bind和subscribe的区别是什么?</p>
<blockquote>
<p>bind需要保证一定不会出错，一定发生在主线程上，主要用来绑定UI视图。</p>
</blockquote>
<p>RxSwift内部实现原理是什么？</p>
<blockquote>
<p>通过观察者设计模式来实现的，建立订阅实际上可以看成是添加监听的过程。Observable可以看成是自动提供包含监听方法的一个对象，调用方法传入参数即可完成添加监听这样的 功能；Disposable相当于一个移除观察者的过程，也因此在RxSwift中，DisposeBag是必须的。</p>
<p>在OC中，RxSwift可以通过KVO来实现监听，实质上和使用通知模式实现监听是一模一样的。</p>
</blockquote>
<p><strong>相关关键字：</strong></p>
<blockquote>
<p>函数式编程、响应式编程、数据绑定、任务依赖、Obervable、Observer、disposable、Single、Completable、Maybe、Driver、bind、subscribe、变形函数、RxDataSources</p>
</blockquote>
<p>Reference: <a href="https://beeth0ven.github.io/RxSwift-Chinese-Documentation" target="_blank" rel="noopener">https://beeth0ven.github.io/RxSwift-Chinese-Documentation</a></p>
]]></content>
      <categories>
        <category>Swift</category>
      </categories>
  </entry>
  <entry>
    <title>linux/raspberry中挂载外接硬盘</title>
    <url>/posts/2020-05/50924.html</url>
    <content><![CDATA[<p>最近在学一个linux课程，于是就入手了一个raspberry开始折腾，在挂载外接硬盘过程中走了不少的弯路，希望记下来能够帮助更多的人。这里我写的可能并不太详细，但是尽可能的系统，具体到挂载的每个技术点上，更多的详情可以自行google。如果操作上有任何问题和疑问可以和我联系，一起探讨。</p>
<p>实践中，我是在树莓派<code>Raspbian</code>系统中操作的，但是我认为其他linux操作系统都是一样的道理。</p>
<a id="more"></a>

<h1 id="1-查看当前的磁盘信息"><a href="#1-查看当前的磁盘信息" class="headerlink" title="1. 查看当前的磁盘信息"></a>1. 查看当前的磁盘信息</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过df命令查看当前磁盘信息</span><br><span class="line">df -h</span><br></pre></td></tr></table></figure>

<p>比如，我的是这样的：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200524223830.png" alt></p>
<p>这里展示的是已经挂载的磁盘和磁盘被挂载到的位置。</p>
<h1 id="2-确认磁盘位置信息"><a href="#2-确认磁盘位置信息" class="headerlink" title="2. 确认磁盘位置信息"></a>2. 确认磁盘位置信息</h1><p>在raspbian中，可以通过<code>fdisk</code>命令确认当前连接到系统上的硬盘设备所在位置信息，在其它linux系统中可能是<code>diskutil</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#树莓派插卡磁盘位置信息</span><br><span class="line">sudo fdisk -l</span><br><span class="line"></span><br><span class="line">#mac或其它类linux系统上也可能是diskutil</span><br><span class="line">diskutil list</span><br></pre></td></tr></table></figure>

<p>树莓派：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200524224312.png" alt></p>
<p>mac osx：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200524224806.png" alt></p>
<h1 id="3-使用mount命令将磁盘挂载到指定位置"><a href="#3-使用mount命令将磁盘挂载到指定位置" class="headerlink" title="3. 使用mount命令将磁盘挂载到指定位置"></a>3. 使用mount命令将磁盘挂载到指定位置</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo mount -o rw,users,umask=000,exec /dev/sda1 /home/toshiba/</span><br></pre></td></tr></table></figure>

<p>如上所示，我么通过mount命令，将<code>/dev/sda1</code>位置的磁盘挂载到了本地的<code>/home/toshiba</code>。</p>
<p>磁盘位置我们通过fdisk可以找到，目标位置需要 我们创建一个空文件夹专门用来挂载磁盘，一般情况下，你可以将磁盘挂载到<code>/mnt</code>或者<code>/media</code>，当然，你也可以像我一样将磁盘挂载到任意其它的目录中。</p>
<p><img src="http://img.weidongfang.online/imgbed/20200524225126.png" alt></p>
<h1 id="4-卸载磁盘"><a href="#4-卸载磁盘" class="headerlink" title="4. 卸载磁盘"></a>4. 卸载磁盘</h1><p>当磁盘使用完毕，我们需要手动卸载磁盘，类似于图形界面的推出操作。我们使用umount可以推出一个已经挂载的磁盘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 卸载挂载在指定目录的磁盘</span><br><span class="line">sudo umount /home/toshiba</span><br></pre></td></tr></table></figure>

<h1 id="5-开机自动挂载磁盘"><a href="#5-开机自动挂载磁盘" class="headerlink" title="5. 开机自动挂载磁盘"></a>5. 开机自动挂载磁盘</h1><p>比如在树莓派上，我们想让外接硬盘作为下载的数据盘，总不能每次重启机器都去手动挂载磁盘。实际上，我们可以通过 fstab 来实现开机自动挂载外接磁盘。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过vim打开fstab文件</span><br><span class="line">sudo vim /etc/fstab</span><br><span class="line"></span><br><span class="line">#格式大概是这样的，被挂载磁盘的位置，目标位置，挂载相关参数等等</span><br><span class="line">/dev/sda1 /home/pi/toshiba ntfs-3g defaults,nofail,noexec,umask=0000 0 0</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>这里需要注意，挂载参数上一定要加上<code>nofail</code>，这样当挂载失败后系统一样正常启动，否则可能导致挂载失败而导致系统无法启动。</p>
<p>如果你的磁盘是exFAT格式，在树莓派上是不支持的，幸运的是，你可以通过扩展<code>exfat-fuse</code>进行支持。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install exfat-fuse</span><br></pre></td></tr></table></figure>

<h1 id="6-挂载磁盘权限问题"><a href="#6-挂载磁盘权限问题" class="headerlink" title="6. 挂载磁盘权限问题"></a>6. 挂载磁盘权限问题</h1><p>如果你挂载磁盘的目的和我一样，是作为网络下载盘使用，那么你会发现，你无法通过<code>chown</code>或<code>chmod</code>修改挂载磁盘的文件夹权限，这样一来，一个<code>www-data</code>用户运行的服务程序将没有挂载磁盘的读写权限。</p>
<p>原因是，<strong>Linux挂载NTFS或FAT32外接磁盘的磁盘权限是在挂载时候指定的</strong>，你无法通过chmod或chown修改磁盘所属关系。</p>
<p>也就是说，我们可以在挂载磁盘时候通过挂载参数指定挂载磁盘的权限和所属的用户。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#例如，我的树莓派fstab中是这样写的</span><br><span class="line"># 这样比较省事，但是并不安全，因为users指定了所有用户都有权限对磁盘进行读写操作</span><br><span class="line">/dev/sda1    /home/toshiba     auto   rw,users,umask=000,exec,nofail,noatime     0     0</span><br><span class="line"></span><br><span class="line">#通过uid指定磁盘所属关系，uid表示用户的id，你可以在`/etc/passwd`中查看到 </span><br><span class="line">sudo mount -o rw,user,uid=1000,dmask=007,fmask=117 /dev/sdxn /mnt/sd1  # general syntax</span><br></pre></td></tr></table></figure>

<p>关于挂载磁盘权限问题，askubuntu上有个回答质量还是比较高的，建议查阅一下。<a href="https://askubuntu.com/questions/11840/how-do-i-use-chmod-on-an-ntfs-or-fat32-partition/956072#956072" target="_blank" rel="noopener">How do I use ‘chmod’ on an NTFS (or FAT32) partition?</a></p>
<h1 id="7-常见的mount命令挂载参数"><a href="#7-常见的mount命令挂载参数" class="headerlink" title="7. 常见的mount命令挂载参数"></a>7. 常见的mount命令挂载参数</h1><p>下面 选项仅能在<code>etc/fstab</code>文件中使用：</p>
<ul>
<li><p>auto：可以使用 -a 选项挂载。这是默认值。</p>
</li>
<li><p>group：允许非root用户挂载，如果该用户所属组之一匹配设备的属组。</p>
</li>
<li><p>owner：允许非root用户挂载，如果该用户是此设备文件的宿主的话。</p>
</li>
<li><p>user：允许非root用户挂载此文件系统，此用户的名字将记入 mtab 中以便于随后再卸载。</p>
</li>
<li><p>users：允许所有用户挂载此文件系统。</p>
</li>
</ul>
<p>下面的选项既可以在 /etc/fstab 文件中使用，也可以在命令行中使用：</p>
<ul>
<li>defaults：等价于使用如下默认选项：rw, suid,  dev,  exec,  auto, nouser, async。</li>
<li>exec：允许直接执行其中的二进制文件。</li>
<li>noexec：禁止直接执行其中的二进制文件。</li>
<li>nofail：即使指定的设备不存在也不报错。</li>
<li>atime：每一次访问文件与目录都更新inode访问时间(access time)。</li>
<li>noatime：禁止更新文件与目录的inode访问时间，以获得更快的访问速度。</li>
</ul>
<ul>
<li>uid=value/gid=value：设置文件和目录的UID和GID，默认值是当前进程的UID和GID。</li>
<li>umask=value：设置文件/目录的umask(8进制)，默认值是’000’，表示对所有用户都不屏蔽任何权限。</li>
</ul>
<p>其它更多命令请查看<a href="http://www.jinbuguo.com/man/mount.html" target="_blank" rel="noopener">mount中文手册</a>。</p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>【iOS】如何实现弱引用字典，并在对象释放时自动移除？</title>
    <url>/posts/2021-04/ye238s3iweir3.html</url>
    <content><![CDATA[<blockquote>
<p>这个问题来自一道面试题，去年换工作时候碰到的一个问题，现场并没有想到完整的解决方案，面试结束后想到了可行的解决方案。</p>
</blockquote>
<p>我们知道，在objc中，数组和字典中必须存放真实存在的对象，如果存储nil就会导致崩溃，当数组或者字典持有一个对象时候，会自动对对象的引用计数做+1操作。在一些实际开发场景，一方面我们希望保存对象的引用，另一方并不想干预对象的正常释放流程，这时候使用NSArray或者NSDictionary就会有问题了。</p>
<p>幸运的是，objc中也提供了几个可以存储弱引用的序列，NSMapTable、NSHashTable、NSPointerArray。在开发中如果有需要存储弱引用的场景，可以使用这些序列。</p>
<p>那么，我们应该如何实现一个弱引用序列？如何存储对象的弱引用？对象释放后，又是如何将对象从序列中移除掉？这些个问题也是本文需要解决的关键问题。</p>
<a id="more"></a>

<p><strong>注意：以下实现并不是NSMapTable中实现原理</strong>。</p>
<h1 id="如何弱持有一个对象？"><a href="#如何弱持有一个对象？" class="headerlink" title="如何弱持有一个对象？"></a>如何弱持有一个对象？</h1><p>根据开发经验，在使用代理时候，通常会定义一个弱引用的代理对象，代码通常如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;YourProtocol&gt; delegate;</span><br></pre></td></tr></table></figure>

<p>所以，为了让Map类型持有弱引用，我们可以引入一个中间对象，Map对象强持有中间对象，中间对象通过weak弱持有目标对象即可。这样，当目标对象被释放时候，中间对象所持有的弱引用会被自动置空。对象之间关系如下图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/20210428134130.png" alt></p>
<p>通过引入中间对象<code>DFWeakValue</code>的方式，基本上可以解决弱持有对象的问题。实际上，objc提供了一个包装对象可以提供一样的功能，那就是<code>NSValue</code>。至于原理我想和DFWeakValue应该是类似的。NSValue弱持有对象代码如下所示：</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">[<span class="built_in">NSValue</span> valueWithNonretainedObject:anObject];</span><br></pre></td></tr></table></figure>

<p>现在，我们的<code>DFWeakDictionary</code>已经可以正常存储弱引用目标对象了，但是，当对象被释放时候我们保存在DFWeakDictionary中的DFWeakValue（NSValue）并不会被清理掉，如果这样的数据很多，实际上也是非常消耗内存的。</p>
<h1 id="如何监控目标对象的释放？"><a href="#如何监控目标对象的释放？" class="headerlink" title="如何监控目标对象的释放？"></a>如何监控目标对象的释放？</h1><p>仔细思考会发现，如果要将DFWeakValue（NSValue）在目标对象被释放时候从DFWeakDictionary中清理掉，关键是如何知道目标对象什么时候被释放的？</p>
<p>要解决这个问题我们需要从objc对象的释放流程开始入手。观察分析对象的释放流程发现，实际上我们可以无侵入的介入目标对象释放过程的只有<strong>关联对象</strong>了。</p>
<p><img src="http://img.weidongfang.online/imgbed/20210428135245.png" alt></p>
<p><strong>分析发现，我们可以无侵入的给目标对象添加一个关联值，这个关联值只有目标对象持有一份，那么当目标对象被释放时候，我们的关联值就会同步被释放。我们只需要监听关联值的释放即可间接的监控到目标对象的释放。</strong></p>
<p>根据上面的分析，我们的弱引用字典结构图如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/20210428143149.png" alt></p>
<p>到此为止，我们已经解决了实现弱引用序列最关键的部分。</p>
<p>根据以上所述原理，我们就可以实现自己的弱引用序列了，弱引用Set和数组也是类似的原理。这里代码以弱引用字典为例，代码如下所示：</p>
<p><strong>DFTargetAssociationObject类</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFTargetAssociationObject.h</span></span><br><span class="line"><span class="class"><span class="keyword">@class</span> <span class="title">DFTargetAssociationObject</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">DFTargetAssociationObjectDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)targetAssociationObjectWillDeallocWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DFTargetAssociationObject</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)objectWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey deallocDelegate:(<span class="keyword">id</span>&lt;DFTargetAssociationObjectDelegate&gt;)delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DFTargetAssociationObject.m</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DFTargetAssociationObject</span>()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">copy</span>) <span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt; aKey;</span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">weak</span>) <span class="keyword">id</span>&lt;DFTargetAssociationObjectDelegate&gt; delegate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DFTargetAssociationObject</span></span></span><br><span class="line"></span><br><span class="line">+ (<span class="keyword">instancetype</span>)objectWithKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey deallocDelegate:(<span class="keyword">id</span>&lt;DFTargetAssociationObjectDelegate&gt;)delegate &#123;</span><br><span class="line">    DFTargetAssociationObject *obj = [[DFTargetAssociationObject alloc] init];</span><br><span class="line">    obj.aKey = aKey;</span><br><span class="line">    obj.delegate = delegate;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)dealloc &#123;</span><br><span class="line">    [_delegate targetAssociationObjectWillDeallocWithKey:_aKey];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p><strong>DFWeakDictionary类</strong></p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="comment">//DFWeakDictionary.h</span></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DFWeakDictionary</span> : <span class="title">NSObject</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 从字典中移除一个元素</span></span><br><span class="line"><span class="comment">/// @param aKey 被移除元素的key</span></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 向字典中添加一个元素</span></span><br><span class="line"><span class="comment">/// @param anObject 元素的值</span></span><br><span class="line"><span class="comment">/// @param aKey 元素的key</span></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/// 从字典中获取一个元素</span></span><br><span class="line"><span class="comment">/// @param aKey 元素的key</span></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//DFWeakDictionary.m</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">#import <span class="meta-string">"DFWeakDictionary.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">"DFTargetAssociationObject.h"</span></span></span><br><span class="line"><span class="meta">#import <span class="meta-string">&lt;objc/runtime.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="built_in">NSString</span> *DFTargetAssociationKey;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DFWeakDictionary</span>() &lt;<span class="title">DFTargetAssociationObjectDelegate</span>&gt;</span></span><br><span class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>) <span class="built_in">NSMutableDictionary</span> *container;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">DFWeakDictionary</span></span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">instancetype</span>)init &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span> = [<span class="keyword">super</span> init]) &#123;</span><br><span class="line">        _container = [[<span class="built_in">NSMutableDictionary</span> alloc] initWithCapacity:<span class="number">5</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey &#123;</span><br><span class="line">    <span class="keyword">if</span> (aKey) &#123;</span><br><span class="line">        [<span class="keyword">self</span>.container removeObjectForKey:aKey];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)anObject forKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey &#123;</span><br><span class="line">    <span class="keyword">if</span> (!anObject) &#123; <span class="keyword">return</span>; &#125;</span><br><span class="line">    DFTargetAssociationObject *targetObject = [DFTargetAssociationObject objectWithKey:aKey deallocDelegate:<span class="keyword">self</span>];</span><br><span class="line">    objc_setAssociatedObject(anObject, &amp;DFTargetAssociationKey, targetObject, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">    <span class="built_in">NSValue</span> *value = [<span class="built_in">NSValue</span> valueWithNonretainedObject:anObject];</span><br><span class="line">    [<span class="keyword">self</span>.container setObject:value forKey:aKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>&lt;<span class="built_in">NSCopying</span>&gt;)aKey &#123;</span><br><span class="line">    <span class="keyword">if</span> (!aKey) &#123; <span class="keyword">return</span> <span class="literal">nil</span>; &#125;</span><br><span class="line">    <span class="built_in">NSValue</span> *value = [<span class="keyword">self</span>.container objectForKey:aKey];</span><br><span class="line">    <span class="keyword">return</span> value.nonretainedObjectValue;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)targetAssociationObjectWillDeallocWithKey:(<span class="built_in">NSString</span> *)aKey &#123;</span><br><span class="line">    [<span class="keyword">self</span> removeObjectForKey:aKey];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (<span class="built_in">NSString</span> *)debugDescription &#123;</span><br><span class="line">    <span class="built_in">NSMutableString</span> *desc = [<span class="built_in">NSMutableString</span> stringWithString:<span class="string">@"\n--------------------------------"</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">NSString</span> *key <span class="keyword">in</span> <span class="keyword">self</span>.container.allKeys) &#123;</span><br><span class="line">        <span class="keyword">id</span> value = [<span class="keyword">self</span> objectForKey:key];</span><br><span class="line">        [desc appendFormat:<span class="string">@"\n%@: %@"</span>, key, value];</span><br><span class="line">    &#125;</span><br><span class="line">    [desc appendFormat:<span class="string">@"\n--------------------------------"</span>];</span><br><span class="line">    <span class="keyword">return</span> desc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>实现弱引用序列关键问题是：</p>
<p><strong>存储目标对象</strong>：引入中间对象，中间对象弱持有目标对象。</p>
<p><strong>目标对象销毁时移除</strong>：我们可以无侵入的给目标对象添加一个关联值，这个关联值只有目标对象持有一份，那么当目标对象被释放时候，我们的关联值就会同步被释放。我们只需要监听关联值的释放即可间接的监控到目标对象的释放。</p>
<p>具体的实现Demo可以参考这里：<a href="https://github.com/Dev-Dongfang/CustomWeakCollection" target="_blank" rel="noopener">https://github.com/Dev-Dongfang/CustomWeakCollection</a></p>
<blockquote>
<p>Reference:</p>
<p><a href="https://www.jianshu.com/p/99aa4fc17d56" target="_blank" rel="noopener">数组（字典）中添加弱引用；NSPointerArray、NSHashTable、NSMapTable</a></p>
<p><a href="https://kealdishx.github.io/2016/03/10/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3NSMapTable%E3%80%81NSHashTable%E3%80%81NSPointerArray/" target="_blank" rel="noopener">深入理解NSMapTable、NSHashTable、NSPointerArray</a> </p>
<p> <a href="https://juejin.cn/post/6844903463445331975" target="_blank" rel="noopener">对象从创建到销毁的过程探究</a></p>
</blockquote>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
  </entry>
  <entry>
    <title>【笔记】ngrok搭建你自己的内网穿透</title>
    <url>/posts/2020-05/40324.html</url>
    <content><![CDATA[<p>大概两周前，入手了一块树莓派，然后就开始各种折腾，安装了php环境，安装了nginx、部署了静态博客、安装了Django环境，部署了Django项目、安装了Owncloud+aria私人网盘和下载器。接下来想要探索一下外网访问，第一个想到的是花生壳，花生壳的内网穿透还算稳定，官方使用教程也比较详细，很快就搭建好了。</p>
<p>可是，作为一个技术人，不自己动手搭建内网穿透怎么过瘾？网上有很多关于内网穿透的技术，最终我选择两种来实操了一下。其一是ngrok，其二是ssh反向代理。</p>
<a id="more"></a>

<h1 id="Ngrok实现内网穿透（基于Docker）-nginx"><a href="#Ngrok实现内网穿透（基于Docker）-nginx" class="headerlink" title="Ngrok实现内网穿透（基于Docker）+nginx"></a>Ngrok实现内网穿透（基于Docker）+nginx</h1><p>ngrok实现内网穿透的原理，我认为是这样的：首先需要一个客户机和服务器，服务器上要有可以外网访问的ip；客户端和服务端的通信是通过ngrok和ngrokd之间的socket实现的；服务端启动ngrokd后，会监听指定的端口，当监听到端口访问时候，将请求通过ngrokd和ngrok之间的tunnel转发给客户端，客户端收到请求后，再做一个端口映射，将请求转发到真正提供服务的端口，以此实现了内网穿透。</p>
<p><img src="http://img.weidongfang.online/imgbed/20200521130156.png" alt></p>
<blockquote>
<p>关于这个网上也是找了很多参考，但是只有这个博客（<a href="https://www.lylinux.net/article/2018/9/18/51.html" target="_blank" rel="noopener">使用Docker部署Ngrok实现内网穿透</a>）写的最清楚。这里的笔记主要来自这篇博客。</p>
</blockquote>
<p><strong>1）准备工作</strong></p>
<p>首先需要在你的域名提供商增加两条记录到你的服务器，比如<code>ngrok.weidongfang.online</code>, <code>*.ngrok.weidongfang.online</code>。这样你就可以使用subdomain的方式来实现内网穿透了。</p>
<p>在电脑上安装Docker工具，安装过程请自行百度谷歌。</p>
<p>安装docker：<a href="https://www.runoob.com/docker/centos-docker-install.html" target="_blank" rel="noopener">https://www.runoob.com/docker/centos-docker-install.html</a></p>
<p><strong>2）配置文件</strong></p>
<p>这里主要需要准备两个配置文件，<code>Dockerfile</code>和<code>build.sh</code>。</p>
<p>Dockerfile由一行行命令语句组成，可以在命令行中调用的任何命令。Docker通过读取Dockerfile中的指令自动生成镜像。</p>
<p><code>docker build</code>命令用于从Dockerfile构建映像。可以在<code>docker build</code>命令中使用<code>-f</code>标志指向文件系统中任何位置的Dockerfile。（ex：<code>docker build -f /path/to/a/Dockerfile</code>）</p>
<p>编写Dockerfile</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM golang:1.7.1-alpine</span><br><span class="line">ADD build.sh /</span><br><span class="line">RUN apk add --no-cache git make openssl</span><br><span class="line">RUN git clone https://github.com/inconshreveable/ngrok.git --depth=1 /ngrok</span><br><span class="line">RUN sh /build.sh</span><br><span class="line">EXPOSE 8081</span><br><span class="line">VOLUME [ &quot;/ngrok&quot; ]</span><br><span class="line">CMD [ &quot;/ngrok/bin/ngrokd&quot;]</span><br></pre></td></tr></table></figure>

<p>编写build.sh</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export NGROK_DOMAIN=&quot;ngrok.lylinux.net&quot;</span><br><span class="line">cd /ngrok/</span><br><span class="line">openssl genrsa -out rootCA.key 2048</span><br><span class="line">openssl req -x509 -new -nodes -key rootCA.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -days 5000 -out rootCA.pem</span><br><span class="line">openssl genrsa -out device.key 2048</span><br><span class="line">openssl req -new -key device.key -subj &quot;/CN=$NGROK_DOMAIN&quot; -out device.csr</span><br><span class="line">openssl x509 -req -in device.csr -CA rootCA.pem -CAkey rootCA.key -CAcreateserial -out device.crt -days 5000</span><br><span class="line">cp rootCA.pem assets/client/tls/ngrokroot.crt</span><br><span class="line">cp device.crt assets/server/tls/snakeoil.crt</span><br><span class="line">cp device.key assets/server/tls/snakeoil.key</span><br><span class="line"></span><br><span class="line">make release-server</span><br><span class="line">GOOS=linux GOARCH=386 make release-client</span><br><span class="line">GOOS=linux GOARCH=amd64 make release-client</span><br><span class="line">GOOS=windows GOARCH=386 make release-client</span><br><span class="line">GOOS=windows GOARCH=amd64 make release-client</span><br><span class="line">GOOS=darwin GOARCH=386 make release-client</span><br><span class="line">GOOS=darwin GOARCH=amd64 make release-client</span><br><span class="line">GOOS=linux GOARCH=arm make release-client</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意将<strong>NGROK_DOMAIN</strong>改成你自己的域名。</p>
</blockquote>
<p><strong>3）构建镜像</strong></p>
<p>通过docker build命令构建镜像。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker build -t ngrok .</span><br></pre></td></tr></table></figure>

<p>构建完成后，通过docker运行镜像，注意这里响应的地方改成自己想要的域名和端口。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -it  -p 8300:8300 -p 4443:4443 -v /root/docker/ngrok/bin:/root/ngrok/bin/ -d ngrok /ngrok/bin/ngrokd -domain=&quot;raspberry.weidongfang.online&quot; -httpAddr=&quot;:8300&quot;</span><br></pre></td></tr></table></figure>

<p>此命令执行完毕后，会输出以长串字符串，这个是docker镜像的ID，需要记下来备用。</p>
<p><strong>4）客户端</strong></p>
<p>我们可以使用 <code>docker inspect 镜像ID</code> 命令来查看镜像的详细信息，另外在Mounts节点可以看到挂载信息，我的挂载信息如下图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200520160856.png" alt></p>
<p>在Source目录中的bin目录中可以找到编译出来的二进制客户端文件，找到我们需要执行的客户端文件就可以在客户机上连接了。</p>
<p>首先使用sftp将ngrok的客户端传到客户机上去，然后在相同的文件夹中创建<code>ngrok.cfg</code>配置文件。</p>
<p>例如我的配置文件如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server_addr: ngrok.weidongfang.online:4443</span><br><span class="line">trust_host_root_certs: false</span><br><span class="line">tunnels:</span><br><span class="line"> ssh:</span><br><span class="line">  remote_port: 8322</span><br><span class="line">  proto:</span><br><span class="line">   tcp: 22</span><br><span class="line"> dashboard:</span><br><span class="line">  subdomain: dashboard</span><br><span class="line">  proto:</span><br><span class="line">   http: 82</span><br></pre></td></tr></table></figure>

<p>然后执行命令开启本地服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">./ngrok -config=ngrok.cfg start-all</span><br></pre></td></tr></table></figure>

<p>如果你看到如下图所示的输出，则说明成功了！</p>
<p><img src="http://img.weidongfang.online/imgbed/20200520162240.png" alt></p>
<p><strong>5）nginx转发</strong></p>
<p>经过以上四步的操作，内网穿透已经完成了，但是如果你想通过80端口访问http服务，还需要配置nginx转发，nginx配置示例如下所示:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        server_name dashboard.raspberry.weidongfang.online;</span><br><span class="line">        listen 80;</span><br><span class="line">        keepalive_timeout 70;</span><br><span class="line">        proxy_set_header &quot;Host&quot; $host:8300;</span><br><span class="line">        location / &#123;</span><br><span class="line">                proxy_pass_header Server;</span><br><span class="line">                proxy_redirect off;</span><br><span class="line">                proxy_pass http://127.0.0.1:8300;</span><br><span class="line">        &#125;</span><br><span class="line">        access_log off;</span><br><span class="line">        log_not_found off;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6）ngrok客户端后台运行与开机自启动</strong></p>
<p>一切工作准备完成，只留下最后一个问题，通过<code>./ngrok -config=ngrok.cfg start-all</code>命令启动客户端后，一切运行正常，一旦关闭命令行窗口这个服务就自动停止了，如果实现ngrok客户端后台运行呢？</p>
<p>好吧，打开浏览器随手就是一顿百度，二十多分钟过去了，还是没找到真正能够解决问题的答案。</p>
<p>无奈只有求助google，没想到第一条就是真正的解决方案，不得不说google真的很强大，百度真的很菜，既然这样，<strong>从今往后，技术问题只用google。</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/20200520175715.png" alt></p>
<p>到底怎么后台启动ngrok客户端呢？</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ./ngrok -config=ngrok.cfg -log=stdout &gt; /dev/null &amp;</span><br></pre></td></tr></table></figure>

<p>更多的解释请移步stackoverflow：<a href="https://stackoverflow.com/questions/27162552/ngrok-running-in-background" target="_blank" rel="noopener">ngrok running in background</a></p>
<p>关于开机自启动官方文档很详细了，这里不再赘述：<a href="https://ngrok.com/docs/ngrok-link#service" target="_blank" rel="noopener">https://ngrok.com/docs/ngrok-link#service</a></p>
<h1 id="使用ssh实现内网穿透"><a href="#使用ssh实现内网穿透" class="headerlink" title="使用ssh实现内网穿透"></a>使用ssh实现内网穿透</h1><p><strong>原理</strong>：ssh内网穿透原理很简单，在局域网内的服务器（A）通过ssh远程连接到公网的服务器（B）。服务器A上配置到服务器B的反向代理；在服务器B上配置正向代理，转发请求到指定的本地端口。因此，<strong>使用ssh做内网穿透，需要一台有公网IP的服务器来做转发。</strong></p>
<p><strong>1）服务器配置</strong></p>
<ul>
<li>服务端的sshd后台服务默认是不允许远程主机连接本地的转发端口的，因此需要修改sshd配置文件：<br>编辑<code>/etc/ssh/sshd_config</code>，找到<code>GatewayPorts</code>配置项，默认是注释起来的，取消注释，并把后面的值改成<code>clientspecified</code>。</li>
<li>重启sshd：<code>systemctl restart sshd</code>。</li>
</ul>
<p><strong>2）建立客户端A到服务器B的反向代理(在客户端A上操作)</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-CNR</span> 8081<span class="selector-pseudo">:localhost</span><span class="selector-pseudo">:80</span> <span class="selector-tag">userb</span>@<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span></span><br><span class="line"></span><br><span class="line"># <span class="number">8081</span>为服务器B端口，用来与客户端A的<span class="number">80</span>端口绑定。</span><br><span class="line"># 可通过 -f 参数实现后台运行</span><br></pre></td></tr></table></figure>

<p><strong>3）建立服务器B上的正向代理用作本地转发(在服务器B上操作)</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ssh</span> <span class="selector-tag">-CNL</span> "*<span class="selector-pseudo">:8080</span><span class="selector-pseudo">:localhost</span><span class="selector-pseudo">:8081'</span> <span class="selector-tag">localhost</span></span><br><span class="line"></span><br><span class="line"># 8080为本地转发端口,将数据转发到先前已经映射的8081端口，实现外网访问。</span><br><span class="line"># 其中的*表示接受来自任意机器的访问。</span><br><span class="line"># 可通过 <span class="selector-tag">-f</span> 参数实现后台运行</span><br></pre></td></tr></table></figure>

<p><strong>4）用autossh(需安装)建立稳定隧道</strong></p>
<p>autossh的参数与ssh的参数是一致的，但是不同的是在隧道断开的时候，autossh会自动重新连接而ssh不会；另外不同的是 <code>-M</code> 参数，该参数指定一个端口用于外网的主机用来接收内网主机的信息，若隧道不正常则返回给内网主机重新连接。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">autossh</span> <span class="selector-tag">-M</span> 5678 <span class="selector-tag">-f</span> <span class="selector-tag">-CNR</span> 8081<span class="selector-pseudo">:localhost</span><span class="selector-pseudo">:80</span> <span class="selector-tag">userb</span>@<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span></span><br><span class="line"># 参数 -f 为后台运行</span><br></pre></td></tr></table></figure>

<p><strong>5）可使用sshpass与autossh组合使用：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">sshpass</span> <span class="selector-tag">-p</span> "<span class="selector-tag">ssh</span>密码" <span class="selector-tag">autossh</span> <span class="selector-tag">-M</span> 5678 <span class="selector-tag">-CNR</span> 8081<span class="selector-pseudo">:localhost</span><span class="selector-pseudo">:80</span> <span class="selector-tag">userb</span>@<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span>.<span class="keyword">B</span></span><br></pre></td></tr></table></figure>

<p>注：使用sshpass，那么autossh不能加-f参数，因为sshpass需要autossh在前台请求密码才能实现输入(这点和expect差不多)，而加上-f参数放后台后会无效，所以若要使用sshpass请务必不要加-f参数，建议使用autossh然后配合-i参数使用用key认证登陆。 最后可以把命令加入开机启动项实现开机启动。</p>
<p><strong>6）ssh命令参数说明</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-f 后台运行</span><br><span class="line">-C 允许压缩数据</span><br><span class="line">-N 不执行任何命令</span><br><span class="line">-R 将端口绑定到远程服务器，反向代理</span><br><span class="line">-L 将端口绑定到本地客户端，正向代理</span><br></pre></td></tr></table></figure>

<ul>
<li>如果使用的是阿里云，注意要修改ECS实例的安全组添加规则。</li>
</ul>
<blockquote>
<p>Reference</p>
<p><a href="https://www.jianshu.com/p/3682e07a2ea3" target="_blank" rel="noopener">SSH反向隧道实现内网穿透</a></p>
<p><a href="https://segmentfault.com/a/1190000020766229?utm_source=tag-newest" target="_blank" rel="noopener">ssh内网穿透方案</a>        </p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>Raspberry挂载移动硬盘的坑：解决挂载失败导致raspberry系统无法启动的问题</title>
    <url>/posts/2020-05/58865.html</url>
    <content><![CDATA[<p>第一次玩raspberry，踩了不少的坑，在挂载移动硬盘上走了不少的弯路，同时也学到了很多。关于挂载移动硬盘，主要遇到两个问题，第一个问题是挂载后的移动硬盘目录权限和所属关系无法修改；第二个问题是挂载失败导致raspberry系统无法启动的问题。</p>
<p>关于第一个问题的解决方法，上篇博客已经有了解释，详情请<a href="http://blog.weidongfang.online/posts/2020-05/50924.html">点这里</a>。这里主要讲解挂载失败导致系统无法重启的探索发现过程。</p>
<a id="more"></a>

<p>关于挂载外接磁盘，每次重启系统都去手动挂载肯定是不现实的。自动挂载的话，我能想到的方案是在系统启动时执行mount脚本，我们可以将mount命令以及参数封装到sh文件中，在<code>rc.local</code>文件中添加执行sh文件的脚本即可。经过查找发现，linux中有专门存放文件系统的静态信息文件，系统启动时候会去查找并自动挂载，这个文件就是<code>fstab</code>。既然这样那就学习一下新的方式吧！</p>
<h1 id="1-糟糕！"><a href="#1-糟糕！" class="headerlink" title="1.糟糕！"></a>1.糟糕！</h1><p>于是我在网上找了一段挂载的代码，放入fstab，大眼一看似乎没什么问题，就关机重启了。然后raspberry系统再也起不来了… </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/dev/sdp1      /home/raspberry       ext4      defaults,noatime      0      1</span><br></pre></td></tr></table></figure>

<p>经过检查发现，我写进fstab的外接磁盘位置是<code>/dev/sdp1</code>，我记得raspberry上外接磁盘位置是<code>/dev/sda1</code>，一个字母之差，导致系统起不来了… 看到这我肠子都悔青了，没有好好检查一下。</p>
<p>难道说要重新刷系统？重新配置环境？可是raspberry已经部署了很多东西了，docker、nextcloud、aria2、nginx、django等等等…. </p>
<h1 id="2-我相信我并不孤独"><a href="#2-我相信我并不孤独" class="headerlink" title="2.我相信我并不孤独"></a>2.我相信我并不孤独</h1><p>在网上简单搜索下，发现很多人建议重新刷系统。但是，<strong>我相信我并不是第一个遇到这个问题的人</strong>，一定有前人探索出过可行的解决方案！</p>
<p>我们知道，<strong>在linux操作系统上，整个系统都是以文件的形式组织的</strong>，所以fstab这个文件一定存储在raspberry启动盘的某个位置，我们只需要找到方法，打开这个文件，修改这个文件中一个字符即可解决一切问题！</p>
<p>想到这，我兴奋的拔下raspberry的闪存卡，插到电脑上。然而，直接挂载到mac上的只有几百兆的存储空间，剩下的空间都不见了！</p>
<h1 id="3-Here-We-Go"><a href="#3-Here-We-Go" class="headerlink" title="3.Here We Go"></a>3.Here We Go</h1><p>用mac磁盘工具发现，Linux系统所在区间的文件系统，mac不支持，实际上存储raspbian系统的部分，磁盘文件系统是<a href="https://en.wikipedia.org/wiki/Ext4" target="_blank" rel="noopener">ext4</a>。</p>
<p><img src="http://img.weidongfang.online/imgbed/20200526170803.png" alt></p>
<p>幸运的是，mac上可以通过安装插件支持ext4。这里主要要用到两个插件：<a href="https://github.com/osxfuse/osxfuse" target="_blank" rel="noopener">osxfuse</a>和<a href="https://github.com/gerard/ext4fuse" target="_blank" rel="noopener">ext4fuse</a>。</p>
<ul>
<li><strong>osxfuse</strong>：github上的解释<em>FUSE extends macOS by adding support for user space file systems</em>。就是说，让Mac osx支持fuse这个文件系统的插件。</li>
<li><strong>ext4fuse</strong>：ext4fuse是fuse这个文件系统的ext4实现。</li>
</ul>
<p>有了这两个工具，我们就可以在mac上操作ext4文件系统了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 使用HomeBrew安装ext4fuse</span><br><span class="line">brew install ext4fuse</span><br></pre></td></tr></table></figure>

<p>osxfuse可以去<a href="https://osxfuse.github.io/" target="_blank" rel="noopener">官网</a>下载最新的安装包进行安装，这里需要注意的是，<strong>安装时候一定要勾选<code>MacFUSE Compatibility Layer</code></strong>，否则可能导致无无法写入，说多了都是泪… </p>
<p><img src="http://img.weidongfang.online/imgbed/20200526172958.png" alt></p>
<p>接下来，我们可以通过ext4fuse命令，将ext4文件系统挂载到我们的mac上了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#查看mac上链接的外接磁盘位置</span><br><span class="line">diskutil list</span><br><span class="line"></span><br><span class="line">#通过ext4fuse命令将ext4挂载到mac指定的目录中，`allow_other`参数表示允许其他用户读取</span><br><span class="line">sudo ext4fuse /dev/disk2s2 /Volumes/raspberry -o allow_other</span><br></pre></td></tr></table></figure>

<p>然后，我们就可以进入到raspberry系统目录了。</p>
<p><img src="http://img.weidongfang.online/imgbed/20200526174159.png" alt></p>
<p>这时候你会发现，你只能从ext4系统中读取文件而无法写入（这块也卡了我挺长时间），实际上，你认真阅读ext4fuse的readme的话，你会发现下面这句：</p>
<p><img src="http://img.weidongfang.online/imgbed/20200526174519.png" alt></p>
<p><strong>最终的解决方案就是fuse-ext2！</strong>fuse-ext2是一个多操作系统fuse模块，支持挂载ext2/ext3/ext4文件系统并<strong>提供读写支持</strong>。mac上fuse-ext2的安装步骤可以<a href="https://github.com/alperakcan/fuse-ext2#macos" target="_blank" rel="noopener">点这里</a>。</p>
<p>安装完毕后，使用<code>fuse-ext2</code>命令重新挂载即可（注意安装osxfuse时候选中<code>MacFUSE Compatibility Layer</code>，否则可能导致无写入权限），你会发现，现在你可以愉快的读写raspberry系统盘了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo fuse-ext2 /dev/disk2s2 /Volumes/raspberry -o allow_other</span><br></pre></td></tr></table></figure>

<p>然后，修改fstab文件，重启raspberry，外接硬盘挂载成功！😄</p>
<p><em>说明：部分图片来源于网络，因为解决问题过程中没有保存现场。</em></p>
<blockquote>
<p>Reference:</p>
<p><a href="https://piratefache.ch/mount-raspberry-pi-sd-card-on-mac-os/" target="_blank" rel="noopener">https://piratefache.ch/mount-raspberry-pi-sd-card-on-mac-os/</a></p>
<p><a href="https://docs.j7k6.org/mount-ext4-macos/" target="_blank" rel="noopener">https://docs.j7k6.org/mount-ext4-macos/</a></p>
<p><a href="https://github.com/alperakcan/fuse-ext2" target="_blank" rel="noopener">https://github.com/alperakcan/fuse-ext2</a></p>
<p><a href="https://en.wikipedia.org/wiki/Filesystem_in_Userspace" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Filesystem_in_Userspace</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
  <entry>
    <title>【笔记】区块链技术</title>
    <url>/posts/2020-04/8260.html</url>
    <content><![CDATA[<p>不可否认，区块链技术是一个很有想象力的新技术，区块链技术的革命性在于去中心化，但区块链技术的发展却越来约中心化，这像极了整个人类历史的发展。人类的聚集形式从部落到村落再到国家、全球化，区块链技术也从Pow到Pos再到DPos，区块链的发展似乎再次证明了中心化的优越性。</p>
<p>区块链技术到底是怎么回事呢？</p>
<a id="more"></a>

<h2 id="区块链技术的本质"><a href="#区块链技术的本质" class="headerlink" title="区块链技术的本质"></a>区块链技术的本质</h2><h3 id="1-区块链技术的革命性"><a href="#1-区块链技术的革命性" class="headerlink" title="1.区块链技术的革命性"></a>1.区块链技术的革命性</h3><ul>
<li>1.去中心化</li>
<li>2.数据防篡改</li>
<li>3.固定的发行量</li>
</ul>
<h3 id="2-技术概要"><a href="#2-技术概要" class="headerlink" title="2.技术概要"></a>2.技术概要</h3><ul>
<li>1.首先交易用户将交易上传网络中.</li>
<li>2.网络上负责记账的机器,通过比拼算力获得记账权.</li>
<li>3.获得记账权的节点会把交易进行打包向全部网络节点推送, 收到消息的节点验证合法性并将节点存放到自己的区块中.</li>
</ul>
<h3 id="3-工作量证明共识机制"><a href="#3-工作量证明共识机制" class="headerlink" title="3.工作量证明共识机制"></a>3.工作量证明共识机制</h3><ul>
<li>1.使得修改变得几乎不可能</li>
<li>2.能掌握51%的算力的人变得几乎不可能</li>
<li>3.解决分歧问题.</li>
</ul>
<h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><h3 id="1-比特币的哈希算法"><a href="#1-比特币的哈希算法" class="headerlink" title="1.比特币的哈希算法"></a>1.比特币的哈希算法</h3><h3 id="2-Merkle-Root"><a href="#2-Merkle-Root" class="headerlink" title="2.Merkle Root"></a>2.Merkle Root</h3><ul>
<li>1.有利于大量数据的分割,利于整合数据和校验数据.</li>
<li>2.让数据校验变得更加简单.</li>
<li>3.利于大量数据的分割和在p2p网络上安全传输.</li>
</ul>
<h2 id="加密与挖矿"><a href="#加密与挖矿" class="headerlink" title="加密与挖矿"></a>加密与挖矿</h2><h3 id="1-比特币的加密"><a href="#1-比特币的加密" class="headerlink" title="1.比特币的加密"></a>1.比特币的加密</h3><ul>
<li>公钥作为交易账户</li>
<li>交易: 用私钥为交易信息和自己地址生成交易签名,然后将签名和自己信息向p2p网络广播, 以证明交易是合法的</li>
<li>验证: 使用公钥解密交易,  把交易信息和地址做hash并比较是否一致.</li>
</ul>
<h3 id="2-比特币挖矿"><a href="#2-比特币挖矿" class="headerlink" title="2.比特币挖矿"></a>2.比特币挖矿</h3><ul>
<li>1.难度系数会在每出2016个区块后调整一次, 难度是指找到前面有多少个0的哈希值.</li>
<li>2.挖矿流程<ul>
<li>2.1 从网络取得之前的区块信息;</li>
<li>2.2 从待记账区域获取一组交易数据</li>
<li>2.3 形成区块头-计算Merkle Root并设计几张时间等</li>
<li>2.4 穷举Nonce并计算区块头的哈希值. 直到找到符合条件的哈希值.</li>
<li>2.5 一旦矿工成功打包一个区块,就会想全网广播. 其它矿工停止工作开始验证并 继续广播.</li>
</ul>
</li>
</ul>
<h2 id="去中心化的共识机制"><a href="#去中心化的共识机制" class="headerlink" title="去中心化的共识机制"></a>去中心化的共识机制</h2><p>其实,去中心化的共识机制也是要解决拜占庭将军问题.</p>
<h3 id="1-分布式一致性算法"><a href="#1-分布式一致性算法" class="headerlink" title="1.分布式一致性算法"></a>1.分布式一致性算法</h3><h3 id="2-PoW工作量证明"><a href="#2-PoW工作量证明" class="headerlink" title="2.PoW工作量证明"></a>2.PoW工作量证明</h3><ul>
<li>计算符合条件的哈希值</li>
<li>目的<ul>
<li>1)提高对数据 篡改的成本</li>
<li>2)提高网络中不同声音的成本</li>
<li>3)解决分歧问题</li>
</ul>
</li>
</ul>
<h3 id="3-PoS股权证明协议"><a href="#3-PoS股权证明协议" class="headerlink" title="3.PoS股权证明协议"></a>3.PoS股权证明协议</h3><p>为了解决pow中耗费电力和时间成本问题.</p>
<ul>
<li>1.为了解决pow中过多浪费资源和时间的问题</li>
<li>2.矿工记账权根据所拥有财富分配, 更像是资本主义, 财富越多的人也越有动力维护社会的稳定,  因为如果社会不稳定,最先损失的就是他(博弈的思想)</li>
<li>3.好处<ul>
<li>节约资源</li>
<li>利用博弈论让系统更加稳定</li>
</ul>
</li>
<li>4.潜在问题<ul>
<li>分叉问题. pos机制并不需要太多的算力, 因此可能导致某些节点同时养两个甚至多个分叉</li>
<li>双重支付: A在一个分叉支付给B, 在另一个分叉支付给C      </li>
</ul>
</li>
</ul>
<h3 id="4-DPoS机制"><a href="#4-DPoS机制" class="headerlink" title="4.DPoS机制"></a>4.DPoS机制</h3><p>在常规的PoW和PoS中,一大音响效率之处在于任何一个新加入的区块,都需要被整个网络节点确认 .  DPoS优化方案是: 通过不同策略,不定时选中一小群节点做新区块的创建/验证/签名.<br>以此大幅度减少区块创建和确认所需要消耗的事件和算力成本.<br>类似于选举人制度.</p>
<h3 id="5-小结"><a href="#5-小结" class="headerlink" title="5.小结"></a>5.小结</h3><ul>
<li>贿赂攻击: 攻击者在一个分叉上购买 商品, 收到货后在通提高手续费养另一个分叉, 声称没有收到货.</li>
<li>1.PoW 就是蛮荒社会。谁的拳头大谁说话。是真正意义上的无政府的去中心化的社会。</li>
<li>2.PoS 就是资本主义社会。谁的钱多谁说话，还是无政府的社会，但是资本家控制的。</li>
<li>3.DPoS 就是政治主义社会。谁的选票多谁说话，我也不知道怎么个选举，竞选活动吗？有电视辩论吗？还是投票玩玩？但是感觉又回到了中心化架构中的 Leader 选举。</li>
</ul>
<h2 id="智能合约"><a href="#智能合约" class="headerlink" title="智能合约"></a>智能合约</h2><h3 id="1-举个例子"><a href="#1-举个例子" class="headerlink" title="1.举个例子"></a>1.举个例子</h3><ul>
<li>这里举个二手房买卖银行资金托管的例子。因为房屋买卖中设计的资金数目太大，卖家怕交了钱后卖家不过户，卖家怕过了户后买家不给钱。<br>为了解决这个问题，银行提供“资金托管”的服务，银行提供了类似于支付宝这样的中间担保 的服务。买家先将钱款存入银行，等过户后银行将钱款达到卖家账户中。这就是一个正常的担保服务。</li>
</ul>
<h3 id="2-以太坊的智能合约"><a href="#2-以太坊的智能合约" class="headerlink" title="2.以太坊的智能合约"></a>2.以太坊的智能合约</h3><ul>
<li>1）以太坊的智能和也是为了解决信任问题而诞生的。智能合约其实就是一段可执行的程序片段，由发布人使用编程语言编写，这段程序就是一个合约，编写人将合约代码在本地编译完毕后发布到区块链上。</li>
<li>2）这个程序可以理解成一个特殊的交易，被发布后会被旷工打包记录在某一个区块中。当需要调用这个只能合约的方法时，只需要向这个智能合约地址 发送一笔交易即可。</li>
<li>3）每个节点的电脑都安装了以太坊客户端，客户端自带了类似JVM的程序解释器。当交易触发智能合约后，智能合约的代码就会在解释器中执行。</li>
<li>4）这种方式相当于把程序部署到非常多的电脑上，随时都可以通过交易来触发这些智能合约的执行难，也完成了分布式的程序的部署和调用。</li>
</ul>
<h3 id="3-以太坊合约的劣势"><a href="#3-以太坊合约的劣势" class="headerlink" title="3.以太坊合约的劣势"></a>3.以太坊合约的劣势</h3><ul>
<li>1）以太坊合约看似很完美了，但实际生活中的合约要远比这个复杂。比如在银行担保的国际业务中，除了交易双方，物流信息也必须在区块链上，以便触发合约交易；如果收到货物有问题要退货或者换货怎么办？要重新议价怎么办？<br>如果找一个中心化的物流公司参与其中，区块链本身是为了去中心化的，搞中心化的东西算怎么回事？去中心化的物流公司又是怎么样的？</li>
<li>2）以太坊上的合约是用代码写的，而有代码的地方就会有bug。现实生活中我们可以给合同打补丁，但是区块链上遇到有bug的合同就只能认了。<br>实际上“The DAO”被盗$7000w就是因为智能合约写的不够好，被黑客找到了bug。</li>
</ul>
<h2 id="传统金融与虚拟货币"><a href="#传统金融与虚拟货币" class="headerlink" title="传统金融与虚拟货币"></a>传统金融与虚拟货币</h2><h3 id="1-金融的本质"><a href="#1-金融的本质" class="headerlink" title="1.金融的本质"></a>1.金融的本质</h3><ul>
<li>金融最大的本质就是——促进交易完成，实现价值提升。而促进交易的过程中需要解决下面几个问题：</li>
<li>1）交易中的信用问题。</li>
<li>2）交易中的资金不足问题。通过借贷完成。</li>
<li>3）交易中的大额问题。把一个大额的金融事件拆分以股份形式进行大众投资。</li>
</ul>
<h3 id="2-经济运作原理"><a href="#2-经济运作原理" class="headerlink" title="2.经济运作原理"></a>2.经济运作原理</h3><ul>
<li>现代经济学一般认为，消费是有助于经济增长的。</li>
</ul>
<h3 id="3-虚拟货币"><a href="#3-虚拟货币" class="headerlink" title="3.虚拟货币"></a>3.虚拟货币</h3><ul>
<li>1）首先，如果虚拟货币想要有货币的特征，那么就要能保持稳定。而稳定并不仅仅是不增发（增发并不一定是坏事），其价值最好是稳定的。</li>
<li>2）因为目前的虚拟货币并没有任何一个经济体为其背书，因此它远远达不到货币的功能。</li>
<li>3）于是虚拟货币就像股票一样，而股票是有实际的经济实体为其背书的，而虚拟货币为其背书的是空气。</li>
<li>4）虚拟货币这种没有任何价值背书的玩法，总有一天会达到瓶颈，也就是没有新人入场，老人不再投入的时候，就是泡沫破灭的时候。</li>
<li>5）说白了，就是一个高级赌场罢了，人类历史上已经有无数这样的案例了。</li>
</ul>
<h3 id="4-虚拟货币相关的几个逻辑问题"><a href="#4-虚拟货币相关的几个逻辑问题" class="headerlink" title="4.虚拟货币相关的几个逻辑问题"></a>4.虚拟货币相关的几个逻辑问题</h3><ul>
<li>1）比特币掉服了什么？本来，中本聪想通过比特币来建立一个可以避开政府、银行家和企业的支付系统，从而避免通货膨胀或金融腐败。但相反的是，比特币现在是一堆快速膨胀的投机泡沫，其创造了另一个和传流世界一样的金融体系。思考问题：数字货币是在颠覆现有的传统金融体系，还是建立另外一个一模一样，但充满更多泡沫和投机的体系？</li>
<li>2）是否消除了中间商？如今比特币已有各种不同类型的中间商，像是能帮用户把零碎比特币存储成账户的钱包服务等。这些中间商的存在却也破坏了比特币的隐私特性，像 Coinbase 这种中间商就会搜集跟用户有关的大量信息。这并不能怪罪中间商的贪婪，而是因为比特币本身的设计让交易变得非常复杂。对非技术背景的使用者来说，如果没有中间商或应用程序简化，使用比特币还是不太便利。思考问题：比特币的原意是建立一种无需银行和中间商，不会有交易费用的交易系统，但现在比特币的进展却反过来复制了原本想破坏的体系。</li>
<li>3）大公司参与的区块链？ 看到像投资银行高盛或是中介机构蚂蚁金融这样的公司参与到区块链这个事来？你有没有觉得，有点奇怪？我还看到有些人评论到：“区块链就是需要大公司来参与”。看到这，我不知道中本聪会怎么想？反正我感觉有很强烈的喜感。思考问题：区块链本质上是要颠覆这些银行和中间商的，代表了先进的生产关系，而这些传统的落后的生产力来玩这个事，是不是有点像，我造了一列火车，而要用这些马车来拉……</li>
<li>4）投资人投资去中心化的公司？ 我有点不明白，为什么投资人或是投资公司会关注这个事？如果投资人看到了去中心化这个事可以颠覆现有的大公司，所以看好这个事。于是把钱投给了去颠覆中心化的大公司的这些公司，而这些公司又会成为中心化的大公司。这看起来好奇怪啊。因为真正的去中心化是完全找不到主体的。思考问题：去中心化需要有公司吗？有公司的话，还能叫是去中心化吗？投资人并不傻，那么，他们想来这里面干点什么呢？是投机吗？</li>
</ul>
<p><img src="https://walden-image.oss-cn-beijing.aliyuncs.com/img/block-chain-xmind-note-2020-05-0714:45:06.png" alt></p>
<blockquote>
<p>Reference: </p>
<p>笔记主要参考自：<a href="https://time.geekbang.org/column/article/5612" target="_blank" rel="noopener">https://time.geekbang.org/column/article/5612</a>  </p>
<p><a href="[https://blockchainlittlebook.com/#/?nsukey=oxmtzu5jjvol8mjb03au5nvuyioxgbvboqju7ckivcjacmbvao5z2juldphv45r1b%2fmv%2bdy27pflm%2bt65q4msybkm7m8njm%2bk5i8%2fvja%2fpljko0%2bihqxmalotbwvh8x0ydjw%2bkyfwirlxbflpi%2bar6fb5z9sogehktd3yvba1dvqh3fqkch9wxapmlk84fdoybafjcx0bckonjxfyi37lq%3d%3d&id=%e5%8c%ba%e5%9d%97%e9%93%be%e5%b0%8f%e7%99%bd%e4%b9%a6](https://blockchainlittlebook.com/#/?nsukey=oxmtzu5jjvol8mjb03au5nvuyioxgbvboqju7ckivcjacmbvao5z2juldphv45r1b%2fmv%2bdy27pflm%2bt65q4msybkm7m8njm%2bk5i8%2fvja%2fpljko0%2bihqxmalotbwvh8x0ydjw%2bkyfwirlxbflpi%2bar6fb5z9sogehktd3yvba1dvqh3fqkch9wxapmlk84fdoybafjcx0bckonjxfyi37lq%3d%3d&id=区块链小白书)">李笑来:区块链小白书</a></p>
<p><a href="https://mp.weixin.qq.com/s/qtbyvpcEmN06V_p-QtCJ7A" target="_blank" rel="noopener">EOS超级节点投票：「千亿」利润下的币圈国家战争</a></p>
<p><a href="https://bitcoin.org/bitcoin.pdf" target="_blank" rel="noopener">bitcoin白皮书</a></p>
<p><a href="https://github.com/ethereum/wiki/blob/master/[中文]-權益證明機制FAQ.md" target="_blank" rel="noopener">以太坊官方WIKI: Proof of Stake</a></p>
<p><a href="https://www.jianshu.com/p/f65bf7691482" target="_blank" rel="noopener">EOS正式版技术白皮书（中文）</a></p>
</blockquote>
]]></content>
      <categories>
        <category>区块链</category>
      </categories>
  </entry>
  <entry>
    <title>为什么浮点数在运算过程中会造成精度损失</title>
    <url>/posts/2020-01/47451.html</url>
    <content><![CDATA[<p>在日常程序开发中，很多时候我们需要用到实数，这时候我们就需要使用浮点数来表示了。现在我们先来看下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a: <span class="type">Float</span> = <span class="number">0.2</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="type">Float</span> = <span class="number">0.3</span></span><br><span class="line"><span class="keyword">let</span> num = a * b</span><br><span class="line"><span class="built_in">print</span>(num)</span><br></pre></td></tr></table></figure>

<p>这是一个最简单的Float乘法，你觉得打印结果是多少，0.06吗？实际上打印结果是<code>0.060000002</code>，看到这个结果你有没有吃惊，聪明的计算机竟然连最简单的小数乘法都算不好。</p>
<a id="more"></a>

<p>你可以将上面代码翻译成Objective-C、C++、Java、JavaScript或者其它语言，我相信你会看到同样的结果。</p>
<p>在回答是什么造成这个结果之前，我们先来思考一个 问题，32bit能够表示多少个数字？正常情况下是2^32个，大概三十多亿个数字，不能再多了。但是实数却是有无限个的，那么我们应该如何使用有限的bit位表示无限的实数呢？</p>
<h1 id="1-定点数表示法-BCD码"><a href="#1-定点数表示法-BCD码" class="headerlink" title="1.定点数表示法-BCD码"></a>1.定点数表示法-BCD码</h1><p>BCD码是用4位二进制数表示1位十进制数中的0<del>9这10个数字，那么32bit能够表示8个这样的数字，表示范围是0</del>99999999，如果我们用最后两位表示小数，那么范围就是0~999999.99。</p>
<p>例如，我们用BCD码表示123456.78，那么这个数字在内存中是这样的：</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20200120-200630@2x.png" alt></p>
<p>这种数字表示法就是BCD码表示法，用于超市收银、温度计数字、重量等较小的计数中还可以，但是一旦需要表示较大或者较小的数字，这种方法就无可奈何了。这种小数点位置固定的表示法，我成称之为<strong>定点数</strong>。</p>
<p>这种数字表示法主要有两个缺点 ：</p>
<ol>
<li>这种表示方法有点浪费空间，本来32bit能够表示将近40亿个数字，使用BCD码方式却只能表示1亿个数字。</li>
<li>这种表示法能够表示的范围有限。</li>
</ol>
<h1 id="2-浮点数表示法"><a href="#2-浮点数表示法" class="headerlink" title="2. 浮点数表示法"></a>2. 浮点数表示法</h1><p>事实上，程序开发中，很多时候我们既需要表示很大的数字，比如计算光速、地球质量、宇宙物质总质量等，又要表示很小的数，比如一个原子的质量、cpu一个晶体管长度、cpu的主频周期等。在日常生活中，我们一般会用科学计数法来表示这些数字，实际上，在计算机上我们同样可以使用<strong>科学计数法</strong>来表示这些数字。</p>
<p>IEEE标准规定，计算机中的科学计数法分为两种，一种是32bit的叫做Float类型，另一种是64bit的叫做Double类型。这里主要讲Float类型，Double类型也是一样的道理。Float类型的bit位分布如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/914b71bf1d85fb6ed76e1135f39b6941.jpg" alt></p>
<ol>
<li><strong>s=符号位</strong>：顾名思义，符号位表示一个数的符号，是正数还是负数。</li>
<li><strong>e=指数位</strong>：指数位用来表示数字的指数部分，Float中指数位占8b。能够表示0<del>255的范围，这里使用1</del>254分别映射到-126~125上。（0和255另有用途）</li>
<li><strong>f=有效数位</strong>：有效数位就是小数点后的数字。</li>
</ol>
<p>这样，我们就可以用科学计数法来表示一个数字了：</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20200120-202705@2x.png" alt></p>
<p>通过这个公式，我们无法表示0和其它特殊的数字，比如无穷大、无穷小，实际上这些数字需要使用钢材的0和255两个数字组合来表示了，如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/f922249a89667c4d10239eb8840dc94c.jpg" alt></p>
<p>在这样的浮点数表示下，32bit能够表示的范围扩大了很多，大约是<code>1.17\*10^-38</code>到<code>3.40\*10^38</code>正是因为这种表示法<strong>小数点的位置是变动的</strong>，因此才被叫做<strong>浮点数</strong>。</p>
<h1 id="3-浮点数二进制转化"><a href="#3-浮点数二进制转化" class="headerlink" title="3. 浮点数二进制转化"></a>3. 浮点数二进制转化</h1><p>那么一个十进制数字到底是怎么被转换成浮点数的呢？下面我们以<code>11.3</code>为例，详细介绍它是怎么被转换成Float类型数字的。</p>
<p>首先，我们先把这个数字的整数部分转换成二进制，<code>11</code>转换成二进制就是<code>1011</code>。</p>
<p>接下来我们把小数部分转换成二进制，小数部分转换二进制的规则是这样的：<strong>小数部分乘以2，然后看是否超过1，如果超过1则记下1并记下小数部分，否则记下0，一直循环下去，直到小数 部分是0为止。</strong>那么0.3的转换就是这样的，如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20200120-210539@2x.png" alt></p>
<p>我们发现，0.3转换成二进制是一个无限循环的数字：0.0100110011001……。</p>
<p>最后我们将整数部分和小数部分拼接到一起：1011.0100110011001…，因为是科学计数法，小数点左移3位，最终就是：1.0110100110011…*2^3。也就是说，s=0，e=3，f=01100110011001100…(23位)。</p>
<p>这也解释了开篇遇到的那个问题。0.2*0.3=0.060000002，因为0.06表示成Float是这样的：</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20200120-211642@2x.png" alt></p>
<h1 id="4-浮点数的精度丢失"><a href="#4-浮点数的精度丢失" class="headerlink" title="4. 浮点数的精度丢失"></a>4. 浮点数的精度丢失</h1><p>来看这个浮点数加法，两千万个Float类型1相加，你猜结果是多少，<strong>16777216.0</strong>，吃惊不😲？我相信其它语言也是同样的结果。下面咱们就一起来看看浮点数的加法到底是怎么运算的。</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20191224-190058.png" alt></p>
<p>浮点数加法原理非常简单，六个字：<strong>先对齐，再计算</strong>。就是说，如果两个浮点数的指数位如果不一样，我们要先把两个浮点数的指数位变成一样的，然后只计算有效位的加法即可。</p>
<p>下面我们来看下<code>16777216.0+1</code>到底是怎么计算的。16777216和1的二进制表示如下图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20200120-213249@2x.png" alt></p>
<p>我们知道加法的原理是先对齐再计算，16777216的指数位是24，1的指数位是0，为了对齐指数位，1的小数点需要左移24位，由于Float类型的浮点数指数位只有23位，移动完毕后，1变成了0，因此，16777216之后对1的加法都是无效的。</p>
<h1 id="5-Kahan-Summation算法"><a href="#5-Kahan-Summation算法" class="headerlink" title="5. Kahan Summation算法"></a>5. Kahan Summation算法</h1><p>面对Float精度丢失的问题，科学家们想出了一个解决办法，那就是Kahan Summation算法。</p>
<p>这个算法主要是在每次计算过程中，都用一次减法，把加法计算中损失的数字记录下来，再做一次运算，<a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm" target="_blank" rel="noopener">wiki</a>里有这个算法的证明，感兴趣可以去阅读，下面是Kahan Summation算法计算上个章节中算法题目的代码，计算结果是<code>2e+07</code>，一点都不差，完美！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">var sum: Float = 0</span><br><span class="line">var c: Float = 0</span><br><span class="line">for _ in 0..&lt;20000000 &#123;</span><br><span class="line">    let x: Float = 1</span><br><span class="line">    let y: Float = x - c</span><br><span class="line">    let t: Float = sum + y</span><br><span class="line">    c = (t - sum) - y</span><br><span class="line">    sum = t</span><br><span class="line">&#125;</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> 2e+07</span></span><br></pre></td></tr></table></figure>

<h1 id="6-BigDecimal的浮点数精度解决方案"><a href="#6-BigDecimal的浮点数精度解决方案" class="headerlink" title="6. BigDecimal的浮点数精度解决方案"></a>6. BigDecimal的浮点数精度解决方案</h1><p>在java开发中，如果遇到高精度计算时候，我们需要使用BigDecimal类型，需要注意的是，我们需要将double、float等类型转换成String类型，然后使用BigDecimal的构造方法进行构造，如果直接使用double或者 float类型构造BigDecimal，计算结果还是有精度误差的。</p>
<p>BigDecimal源码可以<a href="/resource/files/BigDecimal.java">点这里</a>下载。</p>
<p>首先我们先来看看BigDecimal的String构造函数式怎么实现的：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BigDecimal</span><span class="params">(String val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(val.toCharArray(), <span class="number">0</span>, val.length());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过这个入口函数，我们发现，最终真正干活的构造方法是第389行的<code>public BigDecimal(char[] in, int offset, int len, MathContext mc)</code>，这个方法还是比较复杂的，洋洋洒洒几百行代码。</p>
<p>简单看下，我们发现，这几百行代码还是做了很多事情的。由于这里参数传过来的是字符数组，所以我们需要对每一位进行计算和判断，比如判断正负号、判断小数点位置、判断精度等等。</p>
<p>BigDecimal最终会将一个浮点数有效数位转换成long整数，并在其它变量中记录小数点的位置。</p>
<p>这个初始化方法，计算的最终结果是得到四个值分别是：</p>
<ol>
<li><strong>scale</strong>：表示这个数字被放大的倍数。</li>
<li><strong>precision</strong>：小数的精度。</li>
<li><strong>intCompact</strong>：所有的有效数位表示的整数。</li>
<li><strong>intVal</strong>：放大之前的int数值。</li>
</ol>
<p>接下来我们再来看看具体运算过程是怎么进行的，这里以<code>add</code>方法为例:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BigDecimal <span class="title">add</span><span class="params">(BigDecimal augend)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.intCompact != INFLATED) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((augend.intCompact != INFLATED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> add(<span class="keyword">this</span>.intCompact, <span class="keyword">this</span>.scale, augend.intCompact, augend.scale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> add(<span class="keyword">this</span>.intCompact, <span class="keyword">this</span>.scale, augend.intVal, augend.scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ((augend.intCompact != INFLATED)) &#123;</span><br><span class="line">            <span class="keyword">return</span> add(augend.intCompact, augend.scale, <span class="keyword">this</span>.intVal, <span class="keyword">this</span>.scale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> add(<span class="keyword">this</span>.intVal, <span class="keyword">this</span>.scale, augend.intVal, augend.scale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> BigDecimal <span class="title">add</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> xs, <span class="keyword">int</span> scale1, <span class="keyword">final</span> <span class="keyword">long</span> ys, <span class="keyword">int</span> scale2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> sdiff = (<span class="keyword">long</span>) scale1 - scale2;</span><br><span class="line">    <span class="keyword">if</span> (sdiff == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> add(xs, ys, scale1);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sdiff &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> raise = checkScale(xs,-sdiff);</span><br><span class="line">        <span class="keyword">long</span> scaledX = longMultiplyPowerTen(xs, raise);</span><br><span class="line">        <span class="keyword">if</span> (scaledX != INFLATED) &#123;</span><br><span class="line">            <span class="keyword">return</span> add(scaledX, ys, scale2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger bigsum = bigMultiplyPowerTen(xs,raise).add(ys);</span><br><span class="line">            <span class="keyword">return</span> ((xs^ys)&gt;=<span class="number">0</span>) ? <span class="comment">// same sign test</span></span><br><span class="line">                <span class="keyword">new</span> BigDecimal(bigsum, INFLATED, scale2, <span class="number">0</span>)</span><br><span class="line">                : valueOf(bigsum, scale2, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> raise = checkScale(ys,sdiff);</span><br><span class="line">        <span class="keyword">long</span> scaledY = longMultiplyPowerTen(ys, raise);</span><br><span class="line">        <span class="keyword">if</span> (scaledY != INFLATED) &#123;</span><br><span class="line">            <span class="keyword">return</span> add(xs, scaledY, scale1);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            BigInteger bigsum = bigMultiplyPowerTen(ys,raise).add(xs);</span><br><span class="line">            <span class="keyword">return</span> ((xs^ys)&gt;=<span class="number">0</span>) ?</span><br><span class="line">                <span class="keyword">new</span> BigDecimal(bigsum, INFLATED, scale1, <span class="number">0</span>)</span><br><span class="line">                : valueOf(bigsum, scale1, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们发现，加法计算中，BigDecimal先获取到加数和被加数的有效数位和放大值，然后对齐放大倍数，最后将两个BigDecimal的有效数位相加，把结果和放大倍数保存到一个新的BigDecimal。</p>
<blockquote>
<p>Reference</p>
<p><a href="https://time.geekbang.org/column/intro/170" target="_blank" rel="noopener">https://time.geekbang.org/column/intro/170</a></p>
<p><a href="https://baike.baidu.com/item/BCD码/826461?fr=aladdin" target="_blank" rel="noopener">https://baike.baidu.com/item/BCD%E7%A0%81/826461?fr=aladdin</a></p>
<p><a href="https://blog.csdn.net/m0_37482190/article/details/87218019" target="_blank" rel="noopener">https://blog.csdn.net/m0_37482190/article/details/87218019</a></p>
<p><a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Kahan_summation_algorithm</a></p>
<p><a href="https://blog.csdn.net/yin_xing_ye/article/details/94596247" target="_blank" rel="noopener">https://blog.csdn.net/yin_xing_ye/article/details/94596247</a></p>
</blockquote>
]]></content>
      <categories>
        <category>其它</category>
      </categories>
  </entry>
  <entry>
    <title>《人月神话》— 阅读笔记</title>
    <url>/posts/2020-03/6589.html</url>
    <content><![CDATA[<blockquote>
<p>原文摘录：</p>
<p><strong>乐观主义：</strong>所有的编程人员都是乐观主义者。… “这次她肯定会运行的” “我刚刚找到了最后一个错误”。<strong>人月：</strong>第二个谬误是在估计和进度安排中使用的工作单位﹣人月。暗示着时间和人员可以相互替换。 —— 引自章节：chapter 2-人月神话</p>
<p>统开发的时间安排 1／3 计划 1／6 编码 1／4 构件测试和早期系统测试 1／4 系统测试，所有构件已完成 需要特别指出的是，不为系统测试安排足够的时间简直就是一场灾难。—— 引自章节：chapter 2-人月神话</p>
</blockquote>
<a id="more"></a>

<p>这本写自40多年前的书，在今天看来仍然不过时。作者为人们管理复杂项目提供了颇具洞察力的见解，即便是小型的项目，也能从中受益匪浅。用两个字来评价这本书：<strong>深刻</strong>。</p>
<h1 id="1-焦油坑"><a href="#1-焦油坑" class="headerlink" title="1.焦油坑"></a>1.焦油坑</h1><p>过去几十年，各种大型系统开发犹如一个焦油坑，很多大型项目在其中挣扎。因为编程系统产品并不等同于程序，编程系统产品是指包含所有的通用规范、测试文档、维护文档的产品，编程系统产品是将很多不同功能的程序组合在一起，组成功能上相互协作、具有规范的格式、可以进行交互的程序集合。</p>
<p>编程过程中有很多的乐趣：</p>
<ol>
<li>创造事务单纯的快乐；</li>
<li>开发对他人有用东西的快乐；</li>
<li>组装程序不同模块成一个整体，看他们完美协调运行的快乐；</li>
<li>持续学习，非重复性工作的快乐；</li>
<li>程序员就像诗人一样，在创造中工作；</li>
</ol>
<p>变成过程中也有很多的苦恼：</p>
<ol>
<li>追求完美；</li>
<li>编程活动由他人设定目标、提供资源、提供信息；</li>
<li>对他人的依赖是非常痛苦的；</li>
<li>设计功能模块是快乐的，但是debug，调试错误信息是苦恼的；</li>
<li>当投入大量劳动，程序过时，被弃用也是苦恼的；</li>
</ol>
<p>这大概就是编程吧！一个许多人痛苦挣扎的焦油坑，以及一种乐趣与苦恼共存的创造性活动。</p>
<h1 id="2-人月神话"><a href="#2-人月神话" class="headerlink" title="2.人月神话"></a>2.人月神话</h1><p><strong>在众多的软件项目中，缺乏合理进度安排是项目滞后最主要的原因，比其它因素加起来影响还大</strong>。</p>
<p><strong>乐观主义</strong>。所有的编程人员都是乐观主义。只有在实际的开发过程中，才能发现我们构思的不完整与不一致。而程序员默认假设一切都将良好运作，能够轻易驾驭所有的问题，这就是造成乐观主义的原因。</p>
<p><strong>人月。</strong>程序开发中，用人月衡量一项工作是危险的、带欺骗性的活动。它暗示人员的数量和时间是可以互换的。人月只适用于不需要交流的工程中，比如摘棉花。当任务因先后次序限制不能细分时，添加人手无益于进度，反而会由于添加人手造成额外的培训与交流成本。</p>
<p><strong>系统测试。</strong>很少有项目会为系统测试安排一半的时间，但大多数项目系统测试时间都占项目时间的一半。因此，不为系统测试预留足够的时间简直是一场灾难。</p>
<p><strong>空泛的估算。</strong>为了满足顾客需要而造成不合理的项目进度安排在软件开发领域是非常普遍的。</p>
<p><strong>重复产生的进度灾难。</strong>当项目不能如期完成，往往会加派人手，而加派人手往往会引出更多的问题，最终可能进一步拖慢进度。</p>
<h1 id="3-外科手术团队"><a href="#3-外科手术团队" class="headerlink" title="3.外科手术团队"></a>3.外科手术团队</h1><p>问题：同样有两年经验而且在受到同样培训的情况下，优秀的专业程序员的生产效率是较差程序员的10倍。而对于大型项目来说，个别优秀的人也无可奈何。如果要想提升软件开发的效率，必须提升软件项目的完整性。对于提升软件项目概念完整性，最好的办法是由少数干练的人员来设计和开发。</p>
<p>可以组建像外科手术团队一样的开发团队，比如10个人，整个系统只能是1~2个人思维的产物，这样才能达到软件概念上的一致性。</p>
<p>扩建：对于更大型的项目，可以由更多的人员来进行设计，但是只能由1~2个人来操刀书写，整个系统必须具备概念上的完整性，必须由一个系统的结构师从上而下的设计。</p>
<h1 id="4-贵族专制、民主政治、系统设计"><a href="#4-贵族专制、民主政治、系统设计" class="headerlink" title="4.贵族专制、民主政治、系统设计"></a>4.贵族专制、民主政治、系统设计</h1><p><strong>概念完整性是系统设计中最重要的考虑因素。</strong>就是说，为了体现连贯的设计思路，宁可省去不规则的改进与特性。</p>
<p><strong>为了获得概念上的完整性，设计必须由一个人或者多个具有共识的小团队来完成。</strong>而进度的压力由众多的开发人员承担。此时，贵族专制统治是较优的解决方案，因为数量少的设计师会处在解决问题的位置，他的工作产物要比大部分的功能实现人员更长，<strong>要想实现软件概念上的完整性，必须实施贵族专制制度。</strong></p>
<h1 id="5-画蛇添足"><a href="#5-画蛇添足" class="headerlink" title="5.画蛇添足"></a>5.画蛇添足</h1><p>结构师如何成功的影响软件开发：</p>
<ol>
<li>牢记开发人员承担创造性的实现责任，结构师只能提出建议；</li>
<li>时刻准备为自己说明建议一种实现方案，并转呗接受任何其它的可行方案；</li>
<li>对建议保持低调和不公开；</li>
<li>时刻准备放弃自己坚持做的功能修改；</li>
</ol>
<p>对于结构师来说，第一个系统都倾向于精炼和简洁；第二个系统普遍倾向于<strong>过度设计</strong>。结构师应当避免过度设计，过度设计会给项目造成不必要的负担。（实际上，很多时候开发者也会出现过度开发）</p>
<h1 id="6-贯彻执行"><a href="#6-贯彻执行" class="headerlink" title="6.贯彻执行"></a>6.贯彻执行</h1><p><strong>规格说明手册。</strong>书面的规格说明手册是非常必要的，它描述系统设计的每一个细节，也是系统结构师的重要产物。</p>
<ol>
<li>体系结构人员必须为自己描述的特性准备一种实现方案，但不应该支配具体的实现过程。</li>
<li>规格说明说必须清晰、准确、完整。</li>
<li>设计思路可以是10个人的想法，但必须保证由1~2人来完成结论转换成书面的规格说明，以便保证完整性。保证这些看似琐碎问题的一致性，绝对不是无关紧要的事情。</li>
</ol>
<p><strong>结构化定义。</strong>如果某个功能由两种实现方案，必须规定一种为标准，另一个用作辅助描述。</p>
<p><strong>会议与大会。</strong>可以选择在固定日子召开会议，会议之前提出问题，在大会上大家一块讨论，遇到任何问题，在界限内外同时寻求解决方案，<strong>明确授权首席结构师决策权，避免妥协和拖延</strong>。</p>
<p><strong>电话日志。</strong>遇到问题及时反馈提出，整理问题集合定期发布更新。</p>
<h1 id="7-为什么巴比伦塔会失败"><a href="#7-为什么巴比伦塔会失败" class="headerlink" title="7.为什么巴比伦塔会失败"></a>7.为什么巴比伦塔会失败</h1><p><strong>巴比伦塔的管理教训。</strong>交流的缺乏导致争辩、沮丧和相互的猜疑。很快，部落开始分裂—— 大家选择孤立，从而导致了失败。</p>
<p>特别是在大型项目中，通常交流是项目成功的必要条件！非正式交流、会议、工作手册都是有用的交流手段。</p>
<h1 id="8-胸有成竹"><a href="#8-胸有成竹" class="headerlink" title="8.胸有成竹"></a>8.胸有成竹</h1><p>合理的预测编码效率是非常困难的。</p>
<ol>
<li>仅仅通过对编码部分时间的估计，然后乘以其它部分的相对系数，是无法得出对整个工作的精确估计的。</li>
<li>构建独立小程序的数据不适用于编程系统项目。</li>
</ol>
<h1 id="9-削足适履"><a href="#9-削足适履" class="headerlink" title="9.削足适履"></a>9.削足适履</h1><ol>
<li>除了运行时间以外，程序所占据的内存空间也是非常重要的开销。特别是对于操作系统来说，它的很多程序都是常驻内存的。</li>
<li>规模本身不是坏事，但不必要的规模是不可取的。软件开发人员必须设立规模目标，控制规模，尽量的去减少规模的大幅增长。</li>
<li>规模预算不仅仅是在占据内存方面，同时应该指明程序对磁盘访问的次数。</li>
<li>在整个实现的过程期间，系统结构师必须保持持续的警觉，确保连贯的系统完整性。</li>
</ol>
<h1 id="10-提纲擎领"><a href="#10-提纲擎领" class="headerlink" title="10.提纲擎领"></a>10.提纲擎领</h1><p>定义项目，必须准备一些文书工作，书面记录决策是必要的。只有记录下来，分歧才会明朗，矛盾才会突出。文档可以作为同他人沟通的渠道，为管理工作减轻负担。通过遵守文档开展工作，项目经理能够更清晰和快速的设定自己的方向。</p>
<h1 id="11-未雨绸缪"><a href="#11-未雨绸缪" class="headerlink" title="11.未雨绸缪"></a>11.未雨绸缪</h1><p>变，是唯一的不变。</p>
<p><strong>为变化而计划，无论什么时候都要这么做</strong>。项目开发过程中，变化是唯一的不变，因为做任何项目计划都要将可能的变化考虑在内。</p>
<p>系统设计可能会变，架构设计可能会变，甚至组织结构也可能会变。</p>
<h1 id="12-干将莫邪"><a href="#12-干将莫邪" class="headerlink" title="12.干将莫邪"></a>12.干将莫邪</h1><p>主要讲，系统开发过程中，各种软件工具的管理，就是说，必须为开发各种工具分配资源。采用合适的高级语言，使用交互式编程工具都是较好的选择。</p>
<h1 id="13-整体部分"><a href="#13-整体部分" class="headerlink" title="13.整体部分"></a>13.整体部分</h1><p><strong>许许多多的失败完全是因为那些产品未精确定义的地方而导致的</strong>。细致的功能定义、详细的规格说明、规范化的功能描述说明以及这些方法的实施，这些都可以大大减少系统bug率。</p>
<p>认真的构建单元调试和系统集成调试都是必不可少的。</p>
<h1 id="14-祸起萧墙"><a href="#14-祸起萧墙" class="headerlink" title="14.祸起萧墙"></a>14.祸起萧墙</h1><p>实际上，系统开发中的重大灾难是比较容易处理的，它往往和重大压力、彻底重组、新技术的出现有关，整个项目组通常可以应对自如。但是项目进度往往会以难以觉察，但是残酷无情的方式慢慢落后。</p>
<p><strong>一天一天的进度落后比起重大灾难更难以识别，更不容易防范和难以弥补</strong>。</p>
<p>根据一个严格的进度表来控制大型项目的第一个步骤是制定进度表，进度表由里程碑和日期组成。里程碑必须是具体、特定和可度量的事件，能清晰进行定义的事件。如果里程碑定义的非常的清晰，以至于无法自欺欺人时候，程序员很少会在里程碑的进展中弄虚作假。</p>
<h1 id="15-另外一面"><a href="#15-另外一面" class="headerlink" title="15.另外一面"></a>15.另外一面</h1><p><strong>系统开发过程中，文档是非常重要的！</strong>写好文档更是一个软件开发师的日常工作的一部分。</p>
<p>只是口头说教并不能起到太多的效果，更重要的是要以身作则，以优秀的例子来教育其它工程师怎么写好文档。</p>
<h1 id="16-没有银弹"><a href="#16-没有银弹" class="headerlink" title="16.没有银弹"></a>16.没有银弹</h1><blockquote>
<p>在未来的十年内，无论是在技术还是管理方法上，都看不出有任何突破性的进步，能够保证在十年内大幅度的提高软件生产率、可靠性和简洁性。</p>
</blockquote>
<p>这个作者写自40年前的语言，我想放在今天同样适用。</p>
<p>因为现代软件系统中存在无法避免的内在特性：复杂度、一致性、可变性、不可见性。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>《设计模式》— 阅读笔记</title>
    <url>/posts/2020-03/62842.html</url>
    <content><![CDATA[<blockquote>
<p>这篇设计模式笔记内容，绝大部分来自于<a href="https://blog.csdn.net/LoveLion/article/details/17517213" target="_blank" rel="noopener">刘伟老师的博客</a>，部分来自书本《精通swift设计模式》（Adam Freeman著，邱元乐译）。同时也参考了其它关于设计模式的博客与书籍，相形之下，刘伟老师关于设计模式的讲解最令人印象深刻，真正的深入浅出，详细了讲述了设计模式相关的方方面面。</p>
</blockquote>
<a id="more"></a>

<h1 id="1-设计原则"><a href="#1-设计原则" class="headerlink" title="1.设计原则"></a>1.设计原则</h1><ul>
<li><strong>单一职责原则</strong>. 一个类只负责一件事.</li>
<li><strong>开闭原则</strong>. 对修改关闭, 对扩展开放.</li>
<li><strong>接口隔离原则</strong>. 使用多个专门的协议, 而不是一个庞大臃肿的协议; 协议中方法尽量精简. 例如,UITableViewDelegate,UITableViewDataSource使用两个协议而不是一个协议, 这样更符合接口隔离原则.</li>
<li><strong>依赖倒置原则</strong>. 抽象不不应该依赖具体实现, 具体实现可以依赖于抽象.</li>
<li><strong>里氏替换原则</strong>. 父类可以被子类无缝替换, 且原有功能不受影响. (KVO遵从了这个法则,无缝使用子类)</li>
<li><strong>合成复用原则</strong>. 尽量使用对象组合, 而不是继承来达到复用的目的. 因为继承会破坏类的封装性. </li>
<li><strong>迪米特法则</strong>. 一个对象应当对其它对象尽可能少的了解. 高内聚,低耦合.</li>
</ul>
<p><strong>分类记忆：</strong></p>
<ul>
<li>单类：开闭原则、单一职责原则</li>
<li>多类：里氏替换原则、合成复用原则、迪米特原则</li>
<li>接口：接口隔离原则、依赖倒置原则</li>
</ul>
<h1 id="2-六个创建型模式"><a href="#2-六个创建型模式" class="headerlink" title="2.六个创建型模式"></a>2.六个创建型模式</h1><h2 id="2-1-简单工厂模式"><a href="#2-1-简单工厂模式" class="headerlink" title="2.1 简单工厂模式"></a>2.1 简单工厂模式</h2><p>*<em>简单工厂并不属于<code>GoF 23个经典设计模式</code>, 但通常作为学习其它工厂模式的基础. *</em></p>
<p><strong>简单工厂模式: 定义一个工厂类, 它可以根据参数的不同返回不同类的实例, 被创建的实例通常都具有共同的父类. 因为在简单工厂模式中用于创建实例的方法是静态方法, 因此简单工厂模式又被称为静态工厂方法模式, 属于创建性模式.</strong> </p>
<p><img src="http://img.weidongfang.online/imgbed/20130711143612921.jpg" alt></p>
<p><strong>工厂模式虽然简单, 但是存在一个严重问题. 当系统中需要引入新产品时, 由于静态工厂方法通过所传入参数的不同来创建不同的产品, 这必定要修改工厂类的源码, 将违背开闭原则. 使用工厂方法模式将避免这点.</strong></p>
<h2 id="2-2-工厂方法模式"><a href="#2-2-工厂方法模式" class="headerlink" title="2.2 工厂方法模式"></a>2.2 工厂方法模式</h2><p>在工厂方法模式中, 我们不再提供一个统一的工厂类来创建所有的产品对象, 而是针对不同的产品提供不同的工厂, 系统提供一个与产品等级结构对应的工厂等级结构. </p>
<p><strong>工厂方法模式: 定义一个用于创建对象的接口, 让子类决定将哪一个类实例化. 工厂方法模式让一个类的实例化过程延迟到其子类. 工厂方法模式又称为工厂模式. 工厂模式是一种创建型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/20130712101002890.jpg" alt></p>
<p>与简单工厂相比, 工厂方法模式最重要的区别是引入了抽象工厂角色, 抽象工厂可以是接口, 也可以是抽象类或者具体类.</p>
<p><strong>优点</strong></p>
<ol>
<li>工厂方法用来创建客户所需的产品, 同时向客户隐藏了哪种具体产品类将被实例化这一细节, 用户只需关心所需产品对应的工厂, 无需关心创建细节.</li>
<li>系统中加入新产品时, 无需修改抽象工厂和抽象产品提供的接口. 符合”开闭原则”.</li>
</ol>
<p><strong>缺点</strong></p>
<ol>
<li>在添加新产品时, 需要编写新的具体产品类, 而且还要提供与之对应的具体工厂类, 系统中类的数量将成对增加, 在一定程度傻姑娘增加了系统的复杂性, 有更多的类需要编译和运行, 会给系统带来一些额外的开销.</li>
<li>考虑到系统扩展性, 需要引入抽象层, 在客户端代码中均使用抽象层定义, 增加了系统的抽象性和理解难度. </li>
</ol>
<h2 id="2-3-抽象工厂模式"><a href="#2-3-抽象工厂模式" class="headerlink" title="2.3 抽象工厂模式"></a>2.3 抽象工厂模式</h2><p>工厂方法模式通过引入工厂等级结构, 解决了简单工厂模式中工厂类职责太重的问题, 但是工厂方法模式中的一个工厂只生产一类产品, 可能会导致系统中存在大量的工厂类, 势必会增加系统的开销. 此时, 我们可以考虑<strong>将一些相关的产品组成一个”产品簇”, 由同一个工厂来统一生产</strong>.</p>
<p>工厂模式和抽象工厂模式区别: 工厂模式针对一个产品等级结构, 抽象工厂模式需要面对多个产品等级结构, 一个工厂等级可以负责多个不同产品等级结构中产品对象的创建. <strong>当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品族中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。</strong></p>
<p><strong>抽象工厂模式: 提供一个创建一系列相关或相互依赖对象的接口, 无需指定它们具体的类. 抽象工厂模式又称为Kit模式, 是一种对象创建型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/20130713163800203.jpg" alt></p>
<p>抽象工厂模式中, 每个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品, 这些产品构成了一个产品簇.</p>
<p>举例: 要给某个UI页面设计两套皮肤, 分别是春季皮肤和夏季皮肤. UI空间包括Button, TextField, Combox. 使用抽象工厂的设计方案如下所示: </p>
<p><img src="http://img.weidongfang.online/imgbed/20130713164620203.jpg" alt></p>
<h2 id="2-4-单例模式"><a href="#2-4-单例模式" class="headerlink" title="2.4 单例模式"></a>2.4 单例模式</h2><p><strong>单例模式: 确保某一个类只有一个实例, 而且自行实例化并向整个系统提供这个实例, 这个类称为单例类, 它提供全局访问的方法. 到哪里模式是一种对象创建型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1333305124_9327.gif" alt></p>
<p><strong>饿汉式单例类: 在类被初始化时候就将自己实例化, 优点是无需考虑多线程访问问题.</strong></p>
<p><strong>懒汉式单例类: 在第一次使用时候创建, 无需一直占用资源, 实现延迟加载, 但是必须处理好多线程访问问题.</strong></p>
<p>使用懒汉式单例时候, 注意要用<strong>双重检查锁定</strong>来保证单例的唯一性.</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static LazySingleton getInstance() &#123; </span><br><span class="line">    //第一重判断</span><br><span class="line">    if (instance == null) &#123;</span><br><span class="line">        //锁定代码块</span><br><span class="line">        synchronized (LazySingleton.class) &#123;</span><br><span class="line">            //第二重判断</span><br><span class="line">            if (instance == null) &#123;</span><br><span class="line">                instance = new LazySingleton(); //创建单例实例</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li>单例模式提供了对唯一实例的受控访问. 因为单例类封装了它的唯一实例, 所以它可以控制客户怎样以及何时访问它.</li>
<li>由于系统内存只存在一个对象, 因此可以介于系统资源.</li>
<li>允许可变数目的实例. 基于单例模式我们可以进行扩展, 使用与单例控制相似的方法来获得指定个数的对象实例. 既节省系统资源, 又解决了到哪里对象共享过多有损性能的问题. </li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>系统只需要一个实例对象, 如系统资源管理器, 唯一序列号生成器, 或者需要考虑消耗资源太大而只允许创建一个对象.</li>
<li>客户调用类的单个实例只允许使用一个公共访问点, 除了该访问点, 不能通过其它途径访问该实例.</li>
</ol>
<p><strong>Objective-C单例实现:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@interface Singleton : NSObject</span><br><span class="line"></span><br><span class="line">//类方法</span><br><span class="line">+ (Singleton *) getInstance;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">#import &quot;Singleton.h&quot;</span><br><span class="line"></span><br><span class="line">@implementation Singleton</span><br><span class="line"></span><br><span class="line">//在.m文件中声明静态的类实例，不放在.h中是为了让instance私有</span><br><span class="line">static Singleton* instance = nil;</span><br><span class="line"></span><br><span class="line">//提供的类唯一实例的全局访问点</span><br><span class="line">//跟C++中思路相似，判断instance是否为空</span><br><span class="line">//如果为空，则创建，如果不是，则返回已经存在的instance</span><br><span class="line">//不能保证线程安全</span><br><span class="line">+(Singleton *) getInstance&#123;</span><br><span class="line">    static dispatch_once_t onceToken;</span><br><span class="line">    dispatch_once(&amp;onceToken, ^&#123;</span><br><span class="line">        instance = [[self alloc]init];</span><br><span class="line">    &#125;);</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//相当于将构造函数设置为私有，类的实例只能初始化一次</span><br><span class="line">+(id) allocWithZone:(struct _NSZone*)zone &#123;</span><br><span class="line">    if (instance == nil) &#123;</span><br><span class="line">        instance = [super allocWithZone:zone];</span><br><span class="line">    &#125;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//重写copy方法中会调用的copyWithZone方法，确保单例实例复制时不会重新创建</span><br><span class="line">-(id) copyWithZone:(struct _NSZone *)zone &#123;</span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure>

<p><strong>Swift单例类实现:</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class SingletonClass: NSObject &#123;</span><br><span class="line"></span><br><span class="line">    static let shared = SingletonClass()</span><br><span class="line">    </span><br><span class="line">    // Make sure the class has only one instance</span><br><span class="line">    // Should not init or copy outside</span><br><span class="line">    private override init() &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    override func copy() -&gt; Any &#123;</span><br><span class="line">        return self // SingletonClass.shared</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    override func mutableCopy() -&gt; Any &#123;</span><br><span class="line">        return self // SingletonClass.shared</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Optional</span><br><span class="line">    func reset() &#123;</span><br><span class="line">        // Reset all properties to default value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="2-5-原型模式"><a href="#2-5-原型模式" class="headerlink" title="2.5 原型模式"></a>2.5 原型模式</h2><blockquote>
<p><code>Cocoa Touch</code>中对原型模式的应用: <code>copy</code>, <code>mutableCopy</code>方法.</p>
</blockquote>
<p><strong>原型模式:使用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象. 原型模式是一种对象创建型模式.</strong></p>
<p>原型对象的原理很简单: 将一个原型对象传给哪个要发动创建的对象, 这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程. 由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况, 因此原型模式在真实开发中的使用频率还是非常高的. </p>
<p><strong>通过克隆兑现所创建的对象是全新的对象, 它们在内存中拥有新的地址.</strong> </p>
<p><img src="http://img.weidongfang.online/imgbed/1333464346_2107.gif" alt></p>
<p><strong>优点</strong></p>
<ol>
<li>当创建新的对象实例比较复杂时, 使用原型模式可以简化对象的创建过程, 通过复制一个已有实例可以提高新实例的创建效率.</li>
<li>扩展性好, 由于在原型模式中提供了抽象原型类, 在客户端可以针对抽象原型类进行编程.</li>
<li>可以使用深拷贝的方式来保存对象的状态, 使用原型模式将对象复制一份并将其状态保存起来, 以便在需要的时候使用, 可辅助实现撤销操作.</li>
</ol>
<h2 id="2-6-建造者模式"><a href="#2-6-建造者模式" class="headerlink" title="2.6 建造者模式"></a>2.6 建造者模式</h2><blockquote>
<p>示例: 构建一个游戏人物. 一个游戏任务的组成部分一般都比较复杂, 包括身体, 头发, 面部, 衣服, 武器等. 我们可以确定一个游戏任务的构建过程, 然后通过不同的构造方法来构建不同的游戏人物.</p>
</blockquote>
<p>建造者模式是比较复杂的创建型模式, 它将客户端与包含多个组成部分的复杂对象的创建过程分离, 客户端无需知道复杂对象的内部组成部分与拼装方式, 只需知道所需建造者的类型即可. 它关注如何一步步创建一个复杂对象, 不同的具体建造者定义了不同的创建过程, 且具体建造者相互独立, 增加新的建造者非常方便, 无需修改已有代码, 系统有较好的扩展性.</p>
<p><strong>建造者模式: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. 建造者模式是一种对象创建型模式.</strong> </p>
<p><img src="http://img.weidongfang.online/imgbed/1333532291_9501.gif" alt></p>
<p>如上图所示, 关于指挥者类Director在建造过程中扮演者非常重要的作用. 某些情况下, 为了精简系统结构, 我们可以将Director和抽象建造者类进行合并, 在Builder中提供构建产品对象的<code>construct()</code>方法.  另外<code>construct()</code>中也可以通过钩子方法来对Product的构建过程进行更加精细化的控制.</p>
<blockquote>
<p>建造者模式的核心在于如何一步步构建一个包含多个组成部件的完整对象过程, 使用相同的构建过程构建不同的产品, 在软件开发中, 我们需要创建复杂对象并希望系统具备很好的灵活性和可扩展性可以考虑使用建造者模式.</p>
</blockquote>
<h1 id="3-七个结构型模式"><a href="#3-七个结构型模式" class="headerlink" title="3.七个结构型模式"></a>3.七个结构型模式</h1><h2 id="3-1-适配器模式"><a href="#3-1-适配器模式" class="headerlink" title="3.1 适配器模式"></a>3.1 适配器模式</h2><blockquote>
<p><strong>例子:</strong> 笔记本电脑工作电压是20V, 我国家庭用电电压是220V, 他们之间无法直接连接, 这时候就需要一个适配器来适配两者的工作, 这就引入了电源适配器. </p>
</blockquote>
<p><img src="http://img.weidongfang.online/imgbed/1362066387_9870.jpg" alt></p>
<p><strong>适配器模式</strong>: 将一个接口转换成客户希望的另一个接口, 使接口不兼容的哪些类型可以一起工作, 其别名为包装类. 适配器模式既可以作为类结构型模式, 也可以作为对象结构型模式. </p>
<p><strong>在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。</strong></p>
<h3 id="3-1-1-对象适配器"><a href="#3-1-1-对象适配器" class="headerlink" title="3.1.1 对象适配器"></a>3.1.1 对象适配器</h3><p><strong>对象适配器模式类图:</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1362066399_9469.jpg" alt></p>
<p>Adapter继承自目标抽象类, 实现request方法. Adapter引用了Adaptee, 在其request中调用需要适配的方法.</p>
<h3 id="3-1-2-类适配器"><a href="#3-1-2-类适配器" class="headerlink" title="3.1.2 类适配器"></a>3.1.2 类适配器</h3><p>类适配器模式和对象适配器模式最大的不同时适配器与适配者的关系不同, 对象适配器模式中适配器与适配者是关联关系; 类适配器中适配器与适配者是继承关系, 类适配器类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1362099343_7447.jpg" alt></p>
<p>Adapter继承自Adaptee, 实现了目标协议的request协议方法, 在方法内部调用适配者相关的方法, 完成适配工作.</p>
<h3 id="3-1-3-小结"><a href="#3-1-3-小结" class="headerlink" title="3.1.3 小结"></a>3.1.3 小结</h3><p><strong>优点:</strong> </p>
<ol>
<li>将目标类和适配者类解耦, 通过引入一个适配者类来重用现有的适配者类, 无需修改原有结构.</li>
<li>增加类的透明性和复用性. 将具体的业务封装在适配者类中, 对客户端而言是透明的, 提高了适配者的复用性.</li>
</ol>
<p><strong>使用场景:</strong></p>
<ol>
<li>系统需要使用一些现有的类, 而这些类的接口(方法名)不符合系统的需要, 甚至没有这些类的源代码.</li>
<li>向创建一个可以重复使用的类, 用于与一些彼此没有太大关联的类, 包括一些可能将来需要引进的类一起工作.的.</li>
</ol>
<h2 id="3-2-桥接模式"><a href="#3-2-桥接模式" class="headerlink" title="3.2 桥接模式"></a>3.2 桥接模式</h2><blockquote>
<p>示例: 设计一款跨平台的图片解压程序. 不同的图片格式是一个变化的纬度, 不同的操作系统平台又是一个变化的纬度. 这时候我们需要使用桥接模式, 将两者的变化连接起来.</p>
</blockquote>
<p><img src="http://img.weidongfang.online/imgbed/1334506504_5936.gif" alt></p>
<p><strong>桥接模式:</strong> 将抽象部分和它的实现部分分离, 使他们可以独立的变化. 它是一种对象结构型模式, 又称为柄体模式或者接口模式.</p>
<p><strong>桥接模式用于软件系统中某个类存在两个独立变化的纬度, 通过该模式将两个或者多个纬度的变化分离开来, 使两者可以独立扩展</strong>, 让系统更加符合”单一职责原则”. 它将两个独立变化的纬度设计为两个独立的继承等级结构, 并且在抽象层简历抽象关联, 该关联关系类似一条链接两个独立继承结构的桥, 故称桥接模式.</p>
<p><strong>桥接模式类图:</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1334505919_5277.gif" alt></p>
<p><strong>桥接模式和适配器模式配合使用</strong>, 示例类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1334507018_4999.gif" alt></p>
<p>读取excel报表的程序需要使用ExcelAPI, 这时候通过一个适配器关联读取API类的对象, 在响应的方法中调用读取方法.</p>
<p><strong>优点:</strong></p>
<ol>
<li>分离抽象接口和实现部分. 桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。</li>
<li>取代多重继承方案.</li>
<li>提高系统扩展性, 在两个变化纬度中任意扩展一个纬度, 都不需要修改原有系统, 符合”开闭原则”.</li>
</ol>
<h2 id="3-3-组合模式"><a href="#3-3-组合模式" class="headerlink" title="3.3 组合模式"></a>3.3 组合模式</h2><p><strong>组合模式为处理树形结构提供了一种较为完美的解决方案, 它描述了如何将容器和叶子进行递归组合, 使得用户再使用时无需对他们进行区分, 可以一致的对待容器和叶子.</strong></p>
<p><strong>组合模式:</strong> 组合多个对象形成树形结构以表示具有”整体-部分”关系的层次结构. 组合模式对整个对象和组合对象的使用具有一致性, 组合模式又称为”整体-部分”模式, 是一种对象结构型模式.</p>
<p>组合模式类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1347029718_6268.jpg" alt></p>
<p>组合模式的关键是定义一个抽象构件类, 它既可以代表叶子, 也可以代表容器. 而客户端针对该抽象构件类进行编程, 无需知道它到底表示的是叶子还是容器, 可以对他们统一处理.</p>
<p><strong>组合模式在Cocoa框架中最重要的应用在页面布局通用行为的UIView这个类上. 视图层级中的单个视图对象可能是叶子结点, 也可以是包含其它视图集合的composite对象.</strong></p>
<p><strong>优点:</strong></p>
<ol>
<li>组合模式可以清楚地定义分层次的复杂对象, 表示对象的全部或者部分层次, 让客户端忽略层次的差异, 方便对这个那个层次结构进行控制.</li>
<li>在组合模式中增加新的容器构建和叶子构件都很方便, 无需对现有类进行修改, 符合”开闭原则”.</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案.</li>
</ol>
<p><strong>使用场景:</strong></p>
<ol>
<li>在一个面向对象语言开发的系统中需要处理一个树形结构.</li>
<li>在具有整体和部分的层次结构中, 希望通过一种方式忽略整体和部分的差异, 客户端可以一致的对待它们.</li>
</ol>
<h2 id="3-4-装饰模式"><a href="#3-4-装饰模式" class="headerlink" title="3.4 装饰模式"></a>3.4 装饰模式</h2><p><strong>装饰模式:</strong> 动态的给一个对象增加一些额外的职责, 就增加对象功能来说, 装饰模式比生成子类实现更加灵活. 装饰模式是一种对象结构型模式.</p>
<p>装饰器模式类图:</p>
<p><img src="http://img.weidongfang.online/imgbed/1333528185_7832.gif" alt></p>
<p>由于具体构建类和装饰器类都实现了相同的抽象接口, 因此装饰器模式以对客户透明的方式动态给一个对象附加更多责任, 而客户端并不会觉得对象在装饰前和装饰后有什么不同. 装饰模式可以在不需要更多子类的情况下, 对对象的功能加一扩展.</p>
<p>装饰器模式可以多层嵌套, 每个装饰器实现不同的新功能, 并包装旧的装饰器或者原始类, 这一切对客户端来说都是透明的.</p>
<p><img src="http://img.weidongfang.online/imgbed/WX20190529-142102@2x.png" alt></p>
<p><strong>优点:</strong></p>
<ol>
<li>对于扩展一个对象的功能, 装饰模式比继承更加灵活, 不会导致类数量急剧增加.</li>
<li>可以通过一种动态的方式扩展一个对象功能. </li>
<li>可以对一个对象进行多次装饰, 通过使用不同的具体装饰类的排列组合, 可以创造出很多不同的行为组合, 得到功能更加强大的对象.</li>
</ol>
<p><strong>使用场景:</strong></p>
<ol>
<li>在不影响其它对象的情况下, 以动态透明的方式给单个对象添加职责.</li>
<li>当不能采用继承方式进行扩展, 或者扩展将产生大量子类的情况下.</li>
</ol>
<h2 id="3-5-外观模式"><a href="#3-5-外观模式" class="headerlink" title="3.5 外观模式"></a>3.5 外观模式</h2><p><strong>外观模式:</strong> 为子系统的一组接口提供一个统一的入口. 外观模式定义了一个高层的接口, 这个借口使得这一子系统更容易使用.</p>
<p>外观模式中, 一个子系统的外部与其内部通信通过一个统一的外观类进行, 外观类将客户类与子系统的内部复杂性分割开, 使得客户类只需要与外观角色打交道, 而不需要与子系统内部的很多对象打交道. <strong>外观模式是迪米特法则的具体实现, 通过引入外观角色可以降低原有系统的复杂度, 同时降低客户类与子系统耦合度.</strong></p>
<p>外观模式类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1354636733_5965.jpg" alt></p>
<p><strong>优点:</strong></p>
<ol>
<li>降低子系统和客户端之间的耦合;</li>
<li>对客户端屏蔽了子系统组件, 减少客户端所需处理的对象数目, 使子系统使用起来更加方便;</li>
<li>一个子系统的修改对其它子系统没有影响;</li>
</ol>
<p><strong>使用场景:</strong></p>
<ol>
<li>为一系列复杂的子系统提供一个简单入口时候可以用外观模式;</li>
<li>客户端与多个子系统之间存在很大的依赖性;</li>
<li>层次化结构中, 可以用外观模式定义系统每一层的入口;</li>
</ol>
<h2 id="3-6-享元模式"><a href="#3-6-享元模式" class="headerlink" title="3.6 享元模式"></a>3.6 享元模式</h2><blockquote>
<p>示例: 享元模式在Cocoa Touch的应用是<code>UITableViewCell</code>, <code>UICollectionViewCell</code>的复用.</p>
</blockquote>
<p><strong>享元模式:</strong> 运用共享技术有效的支持大量细粒度对象的复用. 系统只使用少量对象, 而这些对象都很相似, 状态变化很小, 可以实现对象的多次复用. 由于享元模式要求能够共享的对象必须是细粒度的对象, 因此它又称为轻量级模式, 它是一种对象结构型模式.</p>
<p>享元模式结构比较复杂, 一般结合工厂模式一起使用, 在它的结构图中包含了一个享元工厂类, 其类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1339770628_5970.jpg" alt></p>
<p>享元模式中引入了享元工厂类, 享元工厂类的作用在于提供一个存储享元对象的享元池, 当用户需要对象时, 首先从享元池中获取, 如果享元池中不存在, 则创建一个新的享元对象返回给用户, 并在享元池中保存该对象. 典型的享元工厂类代码如下所示:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">//定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">       <span class="keyword">private</span> HashMap flyweights = newHashMap();</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span></span>&#123;</span><br><span class="line">              <span class="comment">//如果对象存在，则直接从享元池获取</span></span><br><span class="line">              <span class="keyword">if</span>(flyweights.containsKey(key))&#123;</span><br><span class="line">                     <span class="keyword">return</span>(Flyweight)flyweights.get(key);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">//如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span></span><br><span class="line">              <span class="keyword">else</span> &#123;</span><br><span class="line">                     Flyweight fw = newConcreteFlyweight();</span><br><span class="line">                     flyweights.put(key,fw);</span><br><span class="line">                     <span class="keyword">return</span> fw;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>优点</strong></p>
<ol>
<li>可以极大减少内存中对象的数量, 使得相同或者相似对象在内存中只保留一份, 从而节约系统资源, 提高系统性能.</li>
<li>享元模式的外部状态相对独立, 而且不会影响其内部状态, 从而使得享元对象可以在不同环境中被共享.</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>一个系统中存在大量相同或者相似的对象, 造成内存的大量消耗.</li>
<li>对象的大部分状态都可以外部化, 可以将这些外部状态传入对象中.</li>
<li>在使用享元模式时候需要维护一个共享的享元对象池不, 而这需要消耗一定的系统资源, 因此, 应当在需要多次重复使用享元对象时候吃啊值得使用享元模式.</li>
</ol>
<h2 id="3-7-代理模式"><a href="#3-7-代理模式" class="headerlink" title="3.7 代理模式"></a>3.7 代理模式</h2><p><strong>代理模式:</strong> 给某一个对象提供一个代理或者占位符, 并由代理对象来控制对原对象的访问.</p>
<p>代理模式类图如下所示:</p>
<p><img src="http://img.weidongfang.online/imgbed/1353942400_6301.jpg" alt></p>
<p><strong>优点</strong></p>
<ol>
<li>能够协调调用者和被调用者, 在一定程度上降低系统的耦合度.</li>
<li>客户端针对抽象主题编程, 增加和更换代理类无序</li>
</ol>
<h1 id="4-十一个行为型模式"><a href="#4-十一个行为型模式" class="headerlink" title="4.十一个行为型模式"></a>4.十一个行为型模式</h1><h2 id="4-1-责任链模式"><a href="#4-1-责任链模式" class="headerlink" title="4.1 责任链模式"></a>4.1 责任链模式</h2><p><strong>责任链模式:</strong> 避免请求发送者和请求接收者耦合在一起, 让多个对象都有可能接收请求, 将这些对象链接成一条链, 并且沿着这条链传递请求, 直到有对象处理它为止. 责任链模式是一种对象行为型模式.</p>
<p><img src="http://img.weidongfang.online/imgbed/1333307613_2407.gif" alt></p>
<p>具体的处理者是抽象处理者的子类, 它有两大作用: 处理请求或者转发请求:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class ConcreteHandler extends Handler &#123;</span><br><span class="line">	public void handleRequest(String request) &#123;</span><br><span class="line">		if (请求满足条件) &#123;</span><br><span class="line">			//处理请求</span><br><span class="line">		&#125;</span><br><span class="line">		else &#123;</span><br><span class="line">			this.successor.handleRequest(request);  //转发请求</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>责任链模式的关键在于对调用组件隐藏了责任链上单个链的实现细节. 责任链的创建可以放在客户端, 也可以放在责任链的基类中, 根据枚举类型创建不同的责任链.(放在客户端创建责任链可能更好一点, 更加符合开闭原则)</p>
<p><strong>应用:</strong></p>
<ol>
<li>Cocoa框架中使用责任链来处理用户界面事件. 所有UI组件都派生自UIResponder类. 每个UI组件都是责任链中的链, 他们的位置反应的是其在界面组件层级关系中的位置, 层级顶端是责任链中的最后一个链.</li>
<li>车主邦App中, Bundle图片获取器通过责任链模式实现. 如果是二倍屏, 则先获取二倍图, 没有的话获取三倍图, 一倍图. </li>
<li>消息处理也可以作为责任链来开发. 当收到一个消息, 把消息传递给第一个处理器, 如果不能处理则传递给第二个处理器…</li>
</ol>
<p><strong>使用场景:</strong> 当多个对象可以响应一个请求, 而最终只有一个对象会处理请求时, 可以使用此设计模式.</p>
<h2 id="4-2-命令模式"><a href="#4-2-命令模式" class="headerlink" title="4.2 命令模式"></a>4.2 命令模式</h2><blockquote>
<p>例子: 有一个模拟遥控器的页面, 遥控器面板上有几十种不同的功能. 针对这样的需求, 我们可以使用命令模式, 实现具体的命令类型, 包装具体的操作, 命令发送者只需针对抽象命令类编程, 最后把具体命令类和命令发送者关联起来. </p>
</blockquote>
<p>命令模式可以将请求发送者和接收者完全解耦, 发送者和接收者之间没有直接引用关系, 发送请求的对象只需直到如何发送请求, 而不必知道如何完成请求.</p>
<p><strong>命令模式: 将一个请求封装成一个对象, 从而让我们可用不同的请求对客户进行参数化; 对请求排队或者记录请求日志, 以及支持可撤销的操作. 命令模式是一种对象行为型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1366033467_9048.jpg" alt></p>
<p><strong>命令模式的本质是对请求进行封装, 一个请求对应于一个命令, 将发出命令的责任和执行命令的责任分割开.</strong> 每个命令都是一个操作: 请求的一方发出请求要求执行一个操作; 接收的一方收到请求, 并执行相应的操作. *<em>命令模式允许请求的一方和接收的一方独立开来, 使得请求的一方不必知道接收请求方的接口, 更不必知道请求如何被接收, 操作是否被执行, 何时被执行, 以及怎么被执行. *</em></p>
<p>命令模式的关键在于引入了抽象命令类, 请求发送者针对抽象命令类编程, 只有实现了抽象命令类的具体命令才与请求接收者相关联. </p>
<p>命令模式是一种使用频率非常高的设计模式, 它可以将请求发送者和接收者解耦, 请求发送者通过命令对象来间接引用请求接收者, 使得系统具有更好的灵活性和可扩展性. </p>
<p><strong>优点</strong></p>
<ol>
<li>降低系统耦合度. 由于请求者和接收者之间不存在直接引用, 因此请求者和接收者实现了完全的解耦, 相同的请求者可以对应不同的接收者, 反之亦然.</li>
<li>新的命令可以很容易的加入到系统中.</li>
<li>可以比较容易的设计一个命令队列或者组合命令.</li>
<li>为请求的撤销和恢复提供了一种设计和实现方案.</li>
</ol>
<h2 id="4-3-解释器模式-了解"><a href="#4-3-解释器模式-了解" class="headerlink" title="4.3 解释器模式(了解)"></a>4.3 解释器模式(了解)</h2><p>解释器模式是一种使用频率相对较低但学习难度较大的设计模式, 其用于描述如何使用面向对象语言构建一个简单的语言解释器. 再某些情况下, 为了更好描述某一些特定的问题, 我们可以创建一种新的语言, 这种语言拥有自己的表达式和结构, 即文法规则, 这些问题的实例将对应该语言中的句子. 此时可以使用解释器设计新的语言. 对解释器模式的学习能够加深我们对面向对象思想的理解, 并掌握编程语言中文法规则的解释过程.</p>
<p><strong>解释器模式: 定义一个语言的文法, 并且建立一个解释器来解释该语言中的句子, 这里的语言指使用规定格式和语法的嗲吗. 解释器是一种类行为型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1341331467_7271.jpg" alt></p>
<p>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。与解释器模式类似，目前还诞生了很多基于抽象语法树的源代码处理工具，例如Eclipse中的Eclipse AST，它可以用于表示Java语言的语法结构，用户可以通过扩展其功能，创建自己的文法规则。</p>
<h2 id="4-4-迭代器模式"><a href="#4-4-迭代器模式" class="headerlink" title="4.4 迭代器模式"></a>4.4 迭代器模式</h2><p>开发中我们经常需要使用聚合对象来存储一系列数据. 聚合对象有两个职责, <strong>一是存储数据; 二是遍历数据</strong>. 从依赖上看, 前者是聚合对象的本质工作; 后者是可变的, 可分离的. 因此, 可以将遍历数据的行为从聚合对象中分离出来, 封装在一个被称为迭代器的对象中, 由迭代器来提供遍历聚合对象内部数据的行为, 这样简化了聚合对象的设计,  更符合”单一职责原则”. </p>
<p><strong>迭代器模式: 提供一种方法来访问聚合对象, 而不用暴露这个对象的内部表示, 其别名是游标. 迭代器模式是一种对象行为型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/20130815225537578.jpg" alt></p>
<p>迭代器模式中, 提供了一个外部的迭代器来对聚合对象进行访问和遍历, 迭代器定义了一个访问该聚合元素的接口, 并可以跟踪当前遍历的元素, 了解那些元素遍历过哪些没有. 迭代器的引入, 将使得一个复杂聚合对象的操作变得简单. </p>
<p><strong>优点</strong></p>
<ol>
<li>迭代器模式支持以不同的方式遍历一个聚合对象, 在同一个聚合对象上可以定义多种遍历方式, 再迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法, 我们也可以自己定义迭代器的子类以支持新的遍历方式.</li>
<li>迭代器简化了聚合类. 由于引入了迭代器, 在原有的聚合对象上不需要再执行提供数据遍历方法, 这样可以简化聚合类的设计.</li>
<li>在迭代器模式中, 由于引入了抽象层, 增加新的聚合类和迭代器类都很方便, 无需修改原有代码, 满足开闭原则的要求.</li>
</ol>
<h2 id="4-5-中介者模式"><a href="#4-5-中介者模式" class="headerlink" title="4.5 中介者模式"></a>4.5 中介者模式</h2><p>如果一个系统中对象之间存在多对多的相互关系, 我们可以将对象的一些交互行为从各个对象中分离开来, 并几种封装在一个中介者对象中国, 并由该中介者进行统一协调, 这样对象之间多对多的复杂关系就转化成相对简单的一对多关系. <strong>中介者模式是<code>迪米特法则</code>的一个典型应用.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1357651865_7741.jpg" alt></p>
<p><strong>中介者模式:</strong> 用一个中介对象来封装一系列的对象交互, 中介者使各对象不需要显式地相互引用, 从而使其耦合松散, 而且可以独立地改变他们之间的交互. 中介者模式又称为调停者模式, 它是一种对象行为模式.</p>
<p><img src="http://img.weidongfang.online/imgbed/1357651874_7064.jpg" alt></p>
<p>再中介者模式中, <strong>中介者承担两方面的责任</strong>:</p>
<ol>
<li><strong>中转作用:</strong> 通过中介者模式提供的中转作用, 各个同事对象就不需要显式的应用其它同事, 当需要和其它同事进行通信时, 可通过中介者来间接调用. </li>
<li><strong>协调作用:</strong> 中介者可以进一步对同事之间关系进行封装, 同事可以一致的和中介者进行交互, 而不需要指明中介者需要怎么做, 中介者根据封装在自身内部的协调逻辑, 对同事的请求进行进一步的处理.</li>
</ol>
<p><strong>优点</strong></p>
<ol>
<li>简化了对象之间的交互.</li>
<li>可将各同事对象解耦.</li>
<li>减少生成子类. </li>
</ol>
<p><strong>适用场景</strong></p>
<ol>
<li>系统中对象之间存在复杂的引用关系, 系统结构混乱且难以理解.</li>
<li>一个对象由于引用了其它很多对象并且直接和这些对象通信, 导致难以复用该对象.</li>
<li>想要通过一个中间类来封装多个类的行为, 而不想生成太多的子类. 可以通过引入中介者类来实现. </li>
</ol>
<h2 id="4-6-备忘录模式"><a href="#4-6-备忘录模式" class="headerlink" title="4.6 备忘录模式"></a>4.6 备忘录模式</h2><p>备忘录模式提供可一种状态恢复实现机制 , 使用户可以方便的回到一个特定的历史步骤, 当新的状态无效或者存在问题时, 可以使用暂时存储起来的备忘录将状态恢复.</p>
<p><strong>备忘录模式:</strong> 在不破坏封装的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 这样可以在以后将这个对象恢复到原先保存的状态. 他是一种对象行为型模式. </p>
<p><img src="http://img.weidongfang.online/imgbed/1335891550_5966.jpg" alt></p>
<p>如上图所示, <strong>原发器(Originator)相当于需要被保存状态的对象, 比如一个象棋的棋子; 备忘录(Memento)相当于是是保存棋子位置类型等属性的数据Model, 纯粹用来存储数据的; 负责人(Caretaker)相当于是一个管理类型, 管理人会调用原发器, 生成一个备忘录对象, 管理人也可以根据备忘录对象恢复一个原发器历史的状态.</strong></p>
<p>在设计备忘录模式时要考虑其封装性, <strong>除了Originator类, 不允许其它类来调用备忘录类的Memento的构造函数与相关方法.</strong> 否则可能导致备忘录在保存的历史状态发生改改变, 这样备忘录模式就失去了意义.</p>
<p><strong>优点</strong></p>
<ol>
<li>提供了一种状态恢复的实现机制, 使用户可以方便的回到一个特定的历史步骤, 当新的状态无效或者存在问题时, 可以使用展示存储起来的备忘录将状态复原.</li>
<li>备忘录实现了对信息的封装, 一个备忘录对象是一种原发器对象状态的标识, 不会被其它代码所改动. 备忘录保存了原发器的状态, 吃啊用列表, 堆栈等集合来存储备忘录对象可以实现多次撤销操作.</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>保存一个对象在某一个时刻的全部状态或部分状态, 周鹤洋以后需要时候它能够恢复到先前的状态, 实现撤销操作.</li>
<li>防止完结对象破坏一个对象历史状态的封装性, 避免将对象历史状态的实现细节暴露给外界.</li>
</ol>
<h2 id="4-7-观察者模式"><a href="#4-7-观察者模式" class="headerlink" title="4.7 观察者模式"></a>4.7 观察者模式</h2><p>观察者模式是使用频率最高的设计模式之一, 它用于建立一种对象之间的依赖关系, 一个对象发生改变时将自动通知其它对象, 其它对象做出响应. 观察者模式中, 发生改变的对象称为观察目标, 被通知的对象称为观察者, 一个观察目标可以对应多个观察者, 而这些观察者之间可以没有任何相互联系, 可以根据需要增加或者减少观察者,使系统易于扩展. </p>
<p><strong>观察者模式: 定义对象之间的一种多对多依赖关系, 使得每当一个对象状态发生改变时, 其相互依赖对象皆可得到通知并被自动更新. 观察者模式是一种对象行为型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1341501815_4830.jpg" alt></p>
<p><strong>观察者与MVC</strong></p>
<p>MVC架构中应用了观察者模式. 其中模型对英语观察者模式中的目标, 而视图适用于观察者, 控制器残党两者的中介者. 当模型层的数据发生改变时, 视图层将自动改变其显示内容. </p>
<p><strong>优点</strong></p>
<ol>
<li>观察者模式可以实现表示层和数据逻辑层的分离, 定义了稳定的消息更新传递机制, 并抽象了更新接口,使得可以有各种各样不同的表示层重放具体观察者角色.</li>
<li>观察者模式 在观察目标和观察者之间建立一个抽象的耦合. 观察目标只需维护一个抽象观察者的集合, 无需了解具体观察者, 实现解耦.</li>
<li>观察者模式支持广播通信, 观察哈目标会向所有已注册的观察者对象发送通知, 简化了一对多的系统设计难度.</li>
<li>满足开闭原则的要求, 增加新的具体观察者无序修改原有系统代码, 增加新的观察目标也很方便.</li>
</ol>
<h2 id="4-8-状态模式"><a href="#4-8-状态模式" class="headerlink" title="4.8 状态模式"></a>4.8 状态模式</h2><blockquote>
<p>例子: Cocoa Touch中使用状态模式最典型的应用是UIButton再不同状态下表现不同. 这里状态的切换是由UIButton(Context类)的点击事件或者配置来实现切换的, 使用currentState表示当前状态, 不同状态展示不同的状态.</p>
</blockquote>
<p>状态模式<strong>用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题</strong>. 当系统中某个对象存在多个状态, 这些状态之间可以进行转换, 而且对象在不同状态下行为不相同时可以使用状态模式. 状态模式将一个对象的状态从该对象中分离出来, 封装到专门的状态类中, 使得对象状态可以灵活变化, 对于客户端而言, 无需关心对象状态的转换以及对象当前所处当前状态, 无论对于何种状态的对象, 客户端都一致处理.</p>
<p><strong>状态模式: 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类. 状态模式是一种对象行为型模式.</strong></p>
<p><img src="http://img.weidongfang.online/imgbed/1358693242_5100.jpg" alt></p>
<p>在状态模式中, 我们将对象在不同状态下的行为封装到不同的状态类中, 为了让系统具有更好的灵活性和可扩展性, 同时对各状态下的共有行为进行封装, 我们需要将状态进行抽象.</p>
<p>在状态模式中, 一个对象的状态之间可以进行相互转换, 通常有两种状态转换方式:</p>
<ol>
<li>统一由环境类负责状态之间的转换(上图从的Context类,声明<code>chargeState</code>方法), 根据需要进行状态切换;</li>
<li>由具体状态类负责状态之间转换. 在具体的状态类的业务方法中判断环境类的某些树形, 再根据情况为环境类设置新的状态对象, 实现状态转换. <strong>同样也可以提供专门的方法负责属性值的判断和状态转换(KVO监听变化).</strong></li>
</ol>
<p>某些情况下, 多个环境对象可能需要共享同一个状态, 如果希望在系统中实现多个环境对象共享一个或多个对象, 那么需要将这些状态定义为环境类的静态成员对象.</p>
<h2 id="4-9-策略模式"><a href="#4-9-策略模式" class="headerlink" title="4.9 策略模式"></a>4.9 策略模式</h2><blockquote>
<p>举例: 一个项目中的实例就是对消息推送的组件化封装. 在推送消息组件中封装第三方消息, 推送组件包含了消息处理的管理类型和处理过程的接口. 再实际使用时候去实现协议, 定义具体的处理流程, 然后配置到管理类型中. 推送管理类型负责与具体推送服务做交互.</p>
</blockquote>
<p>实现某一个功能有多条途径, 每一条途径对应一种算法, 此时我们可以使用一种设计模式来实现灵活的选择解决途径, 也能够方便的增加新的解决途径.</p>
<p><strong>策略模式:</strong> 定义一系列算法类, 将每一个算法封装起来, 并让他们相互替换, 策略模式让算法独立于它的客户而变化, 也称为政策模式. 策略模式是一种对象行为型模式.</p>
<p><img src="http://img.weidongfang.online/imgbed/1343811032_3729.jpg" alt></p>
<p><strong>策略模式的主要目的是让算法的定义和使用分开, 也就是将算法的行为和环境分开.</strong> </p>
<p><strong>优点</strong></p>
<ol>
<li>策略模式提供对”开闭原则”的完美支持, 用户可以在不修改原有系统的基础上选择算法和行为, 也可以灵活的增加新的算法和行为.</li>
<li>策略模式提供了管理相关算法簇的办法. </li>
<li>策略模式提供了可以替代继承关系的办法. 使用组合代替继承.</li>
</ol>
<p><strong>使用场景</strong></p>
<ol>
<li>一个系统需要动态的几种算法中选择一种, 那么可以将这些算法封装到一个个的具体算法类中, 而这些具体算法类都是抽象算法类的子类.</li>
<li>一个对象有很多种行为, 如果不用恰当的模式, 这些行为就只好使用多重条件语句来进行实现.</li>
<li>不希望客户端直到复杂的, 与算法相关的数据结构, 再具体策略类中封装算法和相关的数据结构, 可以提高算法的保密性和安全性.</li>
</ol>
<h2 id="4-10-模板方法模式"><a href="#4-10-模板方法模式" class="headerlink" title="4.10 模板方法模式"></a>4.10 模板方法模式</h2><p><strong>模板方法模式</strong>: 定义一个操作中算法的框架, 而将一些步骤延迟到子类中. 模板方法模式可以使得子类可以不改变一个算法结构即可重定义该算法的某些特定步骤.</p>
<p><strong>实现</strong>: 在其他编程语言中, 模板方法模式的实现方式一般是定义一个基类, 并要求子类完善算法, 为缺失的步骤提供步骤. 实现此模式的第一步是将通用的固定的步骤归纳到一个类中, 而允许改变的步骤则需要定义成可通过属性配置的函数. </p>
<p><strong>使用场景</strong>: 此模式可以选择性的允许外界在不修改原有类的情况下, 修改任意算法中的某些步骤的具体实现. <strong>钩子方法的引入使得子类方法可以控制父类的行为.</strong> </p>
<h2 id="4-11-访问者模式"><a href="#4-11-访问者模式" class="headerlink" title="4.11 访问者模式"></a>4.11 访问者模式</h2><p><strong>访问者模式:</strong> 提供一个作用于某对象结构中各元素的操作表示, 它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作. 访问者模式是一种对象行为型模式.</p>
<p><img src="http://img.weidongfang.online/imgbed/1333713874_7112.gif" alt></p>
<p>访问者模式中, 对象结构存储了不同类型的元素对象, 以提供不同访问者访问. 访问者包含两个层次, 一个是访问者层次结构, 提供了抽象访问和具体访问者, 一个是元素层次结构, 提供了抽象元素和具体元素. 相同的访问者可以以不同的方式访问不同元素, 相同元素可以接受不同的访问者以不同访问方式访问. 在访问者模式中, 增加新的访问者无序修改原有系统, 系统具有较好的可扩展性. </p>
<p>在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如visitElementA(ElementA elementA)，还有一种是统一取名为visit()，通过参数类型的不同来定义一系列重载的visit()方法。</p>
<p><strong>优点</strong></p>
<ol>
<li>增加新的访问操作很方便. 使用访问者模式, 增加新的访问操作意味着增加一个新的具体访问者类, 实现简单, 无需修改源代码, 符合开闭原则.</li>
<li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。</li>
<li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。</li>
</ol>
<h1 id="5-其它"><a href="#5-其它" class="headerlink" title="5.其它"></a>5.其它</h1><h2 id="5-1-设计模式概述"><a href="#5-1-设计模式概述" class="headerlink" title="5.1 设计模式概述"></a>5.1 设计模式概述</h2><h3 id="1-设计模式从何而来"><a href="#1-设计模式从何而来" class="headerlink" title="1. 设计模式从何而来"></a>1. 设计模式从何而来</h3><p><strong>模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。</strong>每个模式都是描述一个在我们环境中不断出现的问题, 然后描述了该问题的解决方案核心, 通过这种方式, 我们可以无数次的使用那些已有的成功的解决方案, 无需再重复小矮个女童的工作. 设<strong>计模式用于在特定的条件下 为一些重复出现的软件设计问题提供合理的, 有效的解决方案.</strong></p>
<h3 id="2-设计模式是什么"><a href="#2-设计模式是什么" class="headerlink" title="2. 设计模式是什么?"></a>2. 设计模式是什么?</h3><p>模式是在特定环境下人们解决某类重复出现问题的一套成功或有效的解决方案。</p>
<h3 id="3-设计模式有什么用"><a href="#3-设计模式有什么用" class="headerlink" title="3. 设计模式有什么用?"></a>3. 设计模式有什么用?</h3><ol>
<li>设计模式来源众多专家的经验和智慧，它们是从许多优秀的软件系统中总结出的成功的、能够实现可维护性复用的设计方案，使用这些方案将可以让我们避免做一些重复性的工作，也许我们冥思苦想得到的一个“自以为很了不起”的设计方案其实就是某一个设计模式。在时间就是金钱的今天，设计模式无疑会为有助于我们提高开发和设计效率，但它不保证一定会提高.</li>
<li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的.</li>
<li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的.</li>
<li>设计模式提供了一套通用的设计词汇和一种通用的形式来方便开发人员之间沟通和交流，使得设计方案更加通俗易懂。交流通常很耗时，任何有助于提高交流效率的东西都可以为我们节省不少时间。无论你使用哪种编程语言，做什么类型的项目，甚至你处于一个国际化的开发团队，当面对同一个设计模式时，你和别人的理解并无二异，因为设计模式是跨语言、跨平台、跨应用、跨国界的.</li>
<li>最后一点对初学者很重要，学习设计模式将有助于初学者更加深入地理解面向对象思想，让你知道：如何将代码分散在几个不同的类中？为什么要有“接口”？何谓针对抽象编程？何时不应该使用继承？如果不修改源代码增加新功能？同时还让你能够更好地阅读和理解现有类库（如JDK）与其他系统中的源代码，让你早点脱离面向对象编程的“菜鸟期”.</li>
</ol>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>《随机漫步的傻瓜》— 阅读与总结</title>
    <url>/posts/2021-05/ueysksioajd.html</url>
    <content><![CDATA[<p>这应该不是我第一次阅读这本书，早几年就阅读过一次，当时没有做系统的总结，所以给我留下的印象并不多。这次阅读这本书源自于吴军老师的《硅谷来信》上看到的书名，吴军老师对书中的观点信手拈来，因此我觉得自己是时候重读一遍了。</p>
<p>本次阅读，感觉这本书部分章节的观点是比较晦涩的，有的章节很努力的想要搞清楚作者想要表达什么，但是阅读下来根本搞不清楚作者想要表达的点。不过，按照主题分类，作者几个重要观点叙述还是非常清晰明白的，很容易理解。阅读的意义就在于能从中学到什么，哪怕只有一句话，那么阅读都是有益的。本次阅读加上今天的总结，还是给我留下很多宝贵的观点的。例如随机性和黑天鹅、归纳法的局限性、幸存者偏差、生活中的非对称和非线性事件、我们都是概率盲、如何生活再随机世界中等。有些是我已经拥有的观点了，不过通过阅读本书还是能够加深自己对观点的理解和认识，总体上看，受益匪浅。</p>
<a id="more"></a>

<h2 id="关于随机性和黑天鹅"><a href="#关于随机性和黑天鹅" class="headerlink" title="关于随机性和黑天鹅"></a>关于随机性和黑天鹅</h2><p>由于人类人口基数巨大，根据概率论，对整个人类而言，靠随机性获取成功的人要比我们想象中的更多。举个例子，例如对股市上涨还是下跌的预测中涨跌各占50%，那么连续10次赌对的人有多少？1/1024，也就是说，每一千个人中，就可能有一个人连续10次赌对，如果有1亿人参与呢？那就是10万人。<strong>由此可见，生活中，靠随机性获取成就的人其实大有人在，远比我们想象中的要多。</strong></p>
<p>现实生活就好比是一个巨大的俄罗斯轮盘，就像是一个有这1000发子弹容量的左轮手枪，里面只有一颗子弹。以金融市场为例，你使用自己的方法，连续100次获胜，那么你可能归结为你方法的优越性，完全信任自己的方法，从而开始慢慢的忽略了潜在的风险。千分之一的事件之所以被称为稀有事件而不是不可能事件，是因为千分之一是会发生的，只要你尝试的次数足够多，稀有事件总会到来的。你可能会幸运999次，但是只要有一次致命的失败，就能抹掉你999次的成功。</p>
<p>虽然，靠随机性赚钱的傻瓜一抓一大把，但是他们从没有人认为自己是靠随机性赚钱的，而是将赚钱归功于才华。只有在他们遭遇失败的时候，才会将其决断归结为运气。话说回来，那些随机漫步的傻瓜的存在还是有一点价值的，因为他们的存在，才能够帮助那些有真正智慧的人获得最终的成功。</p>
<h2 id="归纳法的局限性"><a href="#归纳法的局限性" class="headerlink" title="归纳法的局限性"></a>归纳法的局限性</h2><p>人类对<a href="https://zhuanlan.zhihu.com/p/39495529" target="_blank" rel="noopener">归纳法和演绎法</a>的总结也就最近两千年的事情，但是人类对归纳法的应用却有着数百万年的历史，可以说，归纳法是人类刻在骨子里的认知。不可否认，归纳法在整个人类进化史中有着非常重要的作用，帮助我们人类找到大自然的规律，从而更好的生存发展和进化。但是在现如今现代化的世界，很多事情靠归纳是会出错的。</p>
<p><strong>在现实生活中，很多人会对概率性的问题，套用归纳法总结出错误的因果关系，靠概率得出的结论，总有一天会败给概率。</strong>例如一个生活在现实中的人，扣动100次扳机都没有干掉自己，他就会错误的认为扣动扳机是无害的，他从不会回过头认真审视自己的行为。不过，属于他的千分之一终有一天会到来，稀有事件之所以叫稀有事件是因为这些事件是会发生的。</p>
<p>每个人的生命长度和认知都是有限的，这也会在一定程度上导致我们误用归纳法。就好比一只火鸡，364天都能够看到主人来给自己投食，它会错误的认为主人会永远投食，它永远想不到第365天等待它的是什么。</p>
<p><strong>使用归纳法需要注意归纳法的非对称性。</strong>例如有个陈述：没有一个天鹅是白的，因为我看了10w个天鹅。要想推翻这个陈述只需要一只黑天鹅即可，哪怕有再多的白天鹅，只要存在一只黑天鹅，就能推翻“所有天鹅都是白的”这个归纳结论。这就是归纳法的非对称性，证实和证伪难的多，要想证实，就必须看完天底下所有的天鹅，而这在现实世界是不可能的。而稀有事件如果存在，那么一定会在意想不到的时候发生，如果不会发生就不是稀有事件了。</p>
<p>由此可见，归纳法虽好，但也不是万能的。我们在使用归纳法之前一定要三思，认真思考每个归纳前置条件，考虑好每个可能导致归纳偏误的点，考虑好归纳法的非对称性。。</p>
<h2 id="幸存者偏差"><a href="#幸存者偏差" class="headerlink" title="幸存者偏差"></a>幸存者偏差</h2><p><strong>幸存者偏差是我在这本书中重新认识的最重要的知识。</strong>幸存者偏差最早是二战时期的数学家为了证明战机最要害位置计算出来的，之前我对幸存者偏差理解到此位置。这本书给了我一个新的视角，让我从现实生活中找到了幸存者偏差存在的普遍性。</p>
<p><strong>我们的眼里只看到成功者，因此容易形成对机遇的错误看法。</strong>例如，我们经常会认为长得漂亮的人薪资高，这可能是我们通常只会注意到那些薪资比较高的人，或者说，那些薪资比较高的人容易引起我们的注意。“长得漂亮的人薪资高”这样的结论中，我们完全忽略了低收入的人群，如果我们扩大对比的样本，将低收入人群也涵盖进来，可能结果是薪资高低和漂亮与否没有关系。类似这样的，我们在生活中，总是会使用错误的对比样本得出自认为正确的结论；总是会用错误的因果关系，归纳自己的成功经验。殊不知，你的正确可能只是随机漫步的正确，你可能只是一个正确的傻瓜。</p>
<p>长久以来，人们一直忽略幸存者偏差的错误。我们经历的现实只是可能出现的所有随机历史中的一个，我们却误把它当做最有代表性的，忘了还有其它的可能性。简言之，<strong>幸存者偏差的含义是“表现最好的最容易被看见”</strong>。为什么？因为输家没有献身。</p>
<p><strong>关于幸存者偏差可以简述如下</strong>：第一，幸存者偏差起源自我们只看赢家，因而对运气持有错误的看法；第二，不同凡响的成功，最常见的原因是运气；第三：我们在生物构造上缺乏了解概率的能力。</p>
<h2 id="生活中的非对称现象"><a href="#生活中的非对称现象" class="headerlink" title="生活中的非对称现象"></a>生活中的非对称现象</h2><p><strong>概率和期望-从非对称中获利。</strong>举个例子，假设明天市场上涨的概率是80%，但是涨幅只有1%，下跌的概率是20%，但是下跌的幅度是10%。那么请问，你买涨还是买跌？表面上看上涨的概率大，但是买跌的期望收益更大。上涨和下跌的期望并不是对称的，这时候，我们就可是利用非对称现象获利。</p>
<p>这个例子也让我想起来吴军老师讲的瑞士制造的例子。瑞士制造的产品真的比其它绝大多数同类产品更好，但是可能只是好一点点，但正是这一点点的好，其价格比其它产品昂贵数倍。这也可以归结为价格和品质的非对称性。</p>
<p>生活和工作中，我们同样可以使用非对称性获利。比如，工作中，我们可以比同事多努力一点点，哪怕只是一点点，就能够得到更多的绩效评分，从而得到数倍于同事的股票分红。一点点的优势就能拉开巨大的距离。</p>
<p>因此，趁时间还不算太晚，需要好好培养自己的优势了，哪怕只是比别人优秀一点点，当机会来临时候你就能比别人更迅速的抓住。</p>
<h2 id="我们都是概率盲"><a href="#我们都是概率盲" class="headerlink" title="我们都是概率盲"></a>我们都是概率盲</h2><p>举个例子证明你是概率盲。假如中国人人均寿命是70，那么30岁的你预期寿命是多少？可能大多数人脱口而出是70。这样的结论显然忽略了那些30岁前由于各种原因死去的人，70这个数字是包含那些人的，而站在30岁节点的你，已经可以把三十岁前死去的那些人从你的平均数字中删除掉了。所以30岁你的预期寿命肯定是大于70的。</p>
<p>在我们人类几百万年的进化过程中，我们从来不擅长计算概率。某些偏见已经深深嵌入我们大脑中，刻在基因里，阻碍我们处理较复杂、可能需要更精确评估概率的问题。我们人类非常不擅长计算概率问题，因此在一切关于预测这样事情，通常会搞错一些关键条件，忽略关键点。这点需要我们自身提高警惕。</p>
<h2 id="《随机漫步的傻瓜》笔记总结"><a href="#《随机漫步的傻瓜》笔记总结" class="headerlink" title="《随机漫步的傻瓜》笔记总结"></a>《随机漫步的傻瓜》笔记总结</h2><p><a href="https://github.com/Dev-Dongfang/FileArchive/blob/master/Learning/Xminds/读书-随机漫步的傻瓜.xmind" target="_blank" rel="noopener">脑图-读书-随机漫步的傻瓜.xmind</a></p>
<p><img src="http://img.weidongfang.online/imgbed/20210515234648.png" alt></p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>《将心注入-一杯咖啡成就星巴克传奇》— 阅读与总结</title>
    <url>/posts/2021-05/591hsi.html</url>
    <content><![CDATA[<p>星巴克在国内的定价算是比较贵的，至少对于我来讲是比较贵的，为了做本次的阅读总结，我专程跑到附近的星巴克咖啡店体验了一番。看完这本书后再去体验，对星巴克的文化有了更深理解，这不是第一次去，但这次喝星巴克有了不一样的感觉。<a id="more"></a> </p>
<p><strong>星巴克使命宣言</strong></p>
<blockquote>
<p><strong>使命宣言：将星巴克建成全球极品咖啡的翘楚，同时在公司不断成长的过程中，始终坚持之际一贯的原则。</strong></p>
<p><strong>指导原则：</strong></p>
<ul>
<li>提供完善的工作环境，并创造相互尊重和相互信任的工作氛围；</li>
<li>秉持多元化是我们企业经营的重要原则；</li>
<li>采用最高标准进行采购烘焙，并提供最新鲜的咖啡；</li>
<li>是可以高度热忱满足顾客的需求；</li>
<li>积极贡献社区和环境；</li>
<li>认识到盈利是我们未来成功的基础。</li>
</ul>
</blockquote>
<h2 id="星巴克体验"><a href="#星巴克体验" class="headerlink" title="星巴克体验"></a>星巴克体验</h2><p>星巴克是卖咖啡豆生意起家的，至今在星巴克咖啡店显眼的地方仍然有摆着各种咖啡豆、咖啡粉、速溶、浓缩等产品的货架。在我看来，这个货架还是很有意义的，虽然主要营收不在这里，但是这个货架表明了星巴克不忘初心，即使做到了全球连锁也会记得当初的样子，追求极致的价值观念；另一方面，这个货架也表现了星巴克服务至上的理念，即使现在已经很少有人去买咖啡豆，那些喜欢手磨的人依然可以找到地方买星巴克咖啡豆，三十年前习惯去星巴克买咖啡豆的人，至今仍然可以在星巴克买到想要的咖啡豆，就像是大超市一样，总有一些货区是不赚钱甚至是亏钱的，但是作为超市是不可或缺的部分。</p>
<p>第二个让我惊讶的是星巴克周边。星巴克的咖啡杯、星巴克保温杯、主题背包甚至还有毛绒玩具，各种各样的东西，满目琳琅，给我的第一感觉是不务正业。一个做咖啡店生意的不好好做咖啡，整这么多周边，并且还放在进门最显眼的地方，然后想到霍华德带领星巴克走向世界的过程。刚开始，星巴克品牌是卖咖啡豆生意的，在霍华德的带领下开始卖咖啡，当店铺咖啡生意到瓶颈时候星巴克开始为航空公司提供服务，美国咖啡店到瓶颈时候开始走向全世界，当对手的创新超越自己时候，果断扩大自己服务客户理念的外延，跟进对方的创新。星巴克正是因为一次一次的推翻自己，一次一次的探索，才成就了今天的星巴克。理解了这点，也就理解了为什么星巴克有那么多周边，为什么星巴克可以买到蛋糕了。</p>
<p>最让我惊讶的其实是星冰乐。从书中得知，星冰乐是星巴克90年代时候研发的产品，让我没想到的是，至今这款咖啡仍然在售卖，并且放在价目表的第一栏——最显眼的位置。当初星巴克是否要售卖星冰乐这种咖啡延伸饮料，霍华德也经历了痛苦的挣扎，卖，可能影响星巴克咖啡的品质，降低星巴克品牌的价值，不卖，可能错失一个机会。当霍华德亲眼看到用户在星巴克买不到冰咖啡悻悻离去时候，选择听从用户的选择，开始售卖星冰乐。市场是会说话的，星巴克的星冰乐成为当年星巴克乃至美国咖啡产业最受欢迎的咖啡饮品。我果断点了一杯星冰乐，这是一种没什么咖啡味道的饮料，我的感觉是，这已经不是咖啡了，但是是一款非常棒的饮料，说不出哪里好，炎炎夏日，来一杯是真的好！喝了星冰乐之后，也理解了星冰乐能够畅销二十多年的原因，口感很好，心旷神怡，能够畅销二十年也就不足为奇了。</p>
<h2 id="为你喝彩"><a href="#为你喝彩" class="headerlink" title="为你喝彩"></a>为你喝彩</h2><h3 id="如果你从未有过机会，可能是你从未抓住过机会"><a href="#如果你从未有过机会，可能是你从未抓住过机会" class="headerlink" title="如果你从未有过机会，可能是你从未抓住过机会"></a>如果你从未有过机会，可能是你从未抓住过机会</h3><p>和很多励志鸡汤文中写的一样，带领星巴克走向全世界的霍华德也出身自一个贫苦的家庭，但贫苦的家庭也带给他更多的<strong>进取心</strong>。家住在纽约一个低档次的社区，从小就为自己所住的社区而自卑。父亲是一个做杂工的工人，勤奋努力的工作，在一次事故中伤了腿，从此再也无法工作，他父亲的努力工作并没有得到应有的善待，也正因为此，霍华德带领下的星巴克建立了以员工为中心的价值观。霍华德高中时最大的成功就是成为橄榄球队的四分卫，正因为此才成为当时高中的名人，也因此得到了密歇根大学的全额奖学金，没有这笔钱可能就没办法实现上大学的梦想了。</p>
<p>他的母亲是一个聪明、有见识、做事有条理的人。他母亲连高中都没有毕业，但最大的理想却是让她的三个孩子都接受大学教育。鼓励霍华德挑战自己，敢于把自己放在挑战者的位置，从而学会克服困难。</p>
<p>1975年大学毕业后，经过6年的奋斗，已经算是小有成就，大公司、大房子、高薪，这时候他已经获得了很多人无法企及的成功，这样的好日子是他父母不敢想象的，远超过他们的期盼。但是霍华德总感觉自己好像老是在惦记着什么，想要把命运掌握在自己手中，总在想下一步应该做怎么办。直到遇到了星巴克。</p>
<p>实际上，霍华德花了一年的时间才说服星巴克创始人同意雇佣自己。与其说是运气使霍华德获得了成功，不如说是他创造了自己的运气。当你认准了——在你自己的内心，在你的梦想中，你觉得有把握，就必须应该去做能够使自己愿望成为现实的事情。没有一件伟大的事情是紧靠运气就行的。</p>
<p>一次欧洲之旅促使霍华德萌生了将咖啡变成一种生活方式的想法。当时欧洲意式咖啡已经是一种生活习惯，早上起来，路边的咖啡馆三五成群的人在边喝咖啡边聊天，咖啡已经是一种普通的路边饮料一样。而美国却没有类似的东西。霍华德不断的想周围的人灌输这样的思想，但星巴克的创始人杰瑞认为销售出身的霍华德走的有点太远了，杰瑞的星巴克只想专心的做咖啡烘焙生意，致力于用最好的咖啡豆，深度烘焙出最浓厚的咖啡，这也是星巴克咖啡豆能够保持竞争力的原因。</p>
<p>当霍华德认为无法说服杰瑞时候，便选择了离开。第一次遇到星巴克就为之倾倒的霍华德做出离开的决定，一定经历了复杂的心理斗争，但是为了自己的理想，为了自己认为正确的事情，他毅然决然。</p>
<p>我们认识霍华德是因为他带领星巴克走向了全世界，但是在霍华德加入星巴克之前已经是非常成功的人，比身边绝大多数的人都成功，过着以前从不敢想象的生活。很多厉害的人其实并不是做成功了某件事情，所以很厉害，而是因为很厉害，所以能够将别人做不了的事情做成功。现实生活中也有很多人苦于遇不到自己的伯乐，而很少有人反思自己是不是真的千里马。在21世纪的今天，在今天的中国，从没有哪个时代给普通人现在这样多的机会，最近二三十年，涌现出一大批从零开始白手起家创造无尽财富的富豪，所以啊，这是时代并不缺机会，却的是看到机会的人。一个好的社会就是机会均等的社会，不敢说中国现在是完全的机会均等，但是对于绝大多数生活再山区、生活在乡下的孩子、绝不多数的普通人都有一样的机会走出去，看这个世界。相比欧美更加严重的阶级固化，现在的中国可能是机会最均等的国家。</p>
<p>如果你从未有过机会，可能是你从未抓住过机会。</p>
<h3 id="员工至上"><a href="#员工至上" class="headerlink" title="员工至上"></a>员工至上</h3><p>霍华德的父亲一辈子勤勤勉勉辛苦工作，但是并没有得到应有的善待。在工作中不小心伤了腿，由于没有医疗保险，让本就拮据的家庭经济更加困难。也因此，当霍华德接手星巴克时候，将所有员工作为星巴克最重要的资产，员工的利益高于管理层、股东的利益。</p>
<p>在霍华德接手星巴克之前，杰瑞为了收购毕兹咖啡与茶耗费了巨大的资金，导致星巴克员工奖金下降。星巴克员工不理解自己更加辛苦的劳动得到的却是奖金下降，星巴克从创办开始第一次员工和领导层对着干。霍华德也第一次见识到员工对企业的重要性，咖啡豆生意作为零售业，基层员工是最接近客户的地方，如果员工内心积怨还怎么更好的服务客户？</p>
<p>从霍华德接手星巴克后就着手重建管理层和基层员工的关系，力排众议说服所有的股东，将利益向基层普通员工倾斜，给所有的员工包括正式员工和临时工全部缴纳医疗保险，在公司上市之前给所有的员工配股，让所有员工做公司的合伙人，享受企业增长带来红利，这些事情在当时所有的私营企业中都是前所未有的。</p>
<p>得到的结果就是，员工中心耿耿，全身心的为客服服务，员工主动要求解散工会，因为员工完全相信管理层，不需要工会为自己争取权益。当雇员有自信、有尊严时，他们就会做出更多的贡献，为公司、为家庭、为世界。</p>
<h3 id="重建咖啡体验"><a href="#重建咖啡体验" class="headerlink" title="重建咖啡体验"></a>重建咖啡体验</h3><p>咖啡店其实是一个没有太多护城河的行业，只要有优质的咖啡豆，找准一个地段，只要有钱就能开办起来。星巴克靠什么能够打败无数的咖啡店，成为最好的咖啡店呢？</p>
<p>星巴克除了优质的咖啡，提供的更是一种更为深沉的浪漫情怀，给人一种与咖啡同样吸引人的氛围。其它咖啡店可能只是一个喝咖啡的地方，但星巴克可以给人以浪漫，劳累的工作之余，有一个地方可以闻到苏门答腊或者哥斯达黎加咖啡的香味，一边品尝咖啡，一遍品味异域分享也不失为一种浪漫；星巴克提供普通人都消费的起的奢侈消费，不管是蓝领工人还是医生律师都能够品尝到同样的卡布奇诺，享受着同一种世界和一流的产品；星巴克提供一片绿洲，星巴克人对你微笑，迅速为你服务，然后不会打扰你，走进星巴克就能在繁忙之余获得片刻的喘息。这就是星巴克的情怀了吧，每一个简单的事情做到极致，当成企业的价值观经营理念对待，都能够让企业与众不同。</p>
<p>正式这样与众不同的咖啡文化，才打造出星巴克一流的咖啡体验。</p>
<h3 id="进击的星巴克"><a href="#进击的星巴克" class="headerlink" title="进击的星巴克"></a>进击的星巴克</h3><p>星巴克在创立之初就确立了提供优质咖啡的价值观。星巴克咖啡豆的特点就是深度烘焙，厚重的咖啡风味，这和当时其它咖啡不同。星巴克一直恪守自己的经营理念。当其它公司开始提供五花八门的咖啡时候，星巴克还是只有纯正的深度烘焙咖啡，炎炎夏日，其它咖啡店都开始提供冰咖啡时候，星巴克只提供热咖啡。因为星巴克认为，冰咖啡会影响咖啡的风味。与此同时，不断的有门店经理反映咖啡店由于没有冰咖啡造成客户流失，在坚守优质咖啡风味的价值观和迎合客户之间做选择并不是一件容易的事，直到霍华德亲眼看到用户在星巴克买不到冰咖啡悻悻离去时候，选择听从用户的选择，开始售卖星冰乐。</p>
<p>用户的选择永远是最正确的选择，星冰乐在推出当年成为星巴克最畅销的咖啡单品，也是整个咖啡行业最畅销的咖啡单品。现在你去星巴克依然可以买到星冰乐，星冰乐已经畅销了二十多年了。现在的星冰乐已经拼不出咖啡的风味了，但是不可否认是一款非常棒的饮料，其实到底是咖啡还是饮料并不重要，最重要的是客户的认可。我想，如果霍华德固守星巴克最优质的咖啡风味，那么很大可能会输掉星巴克，就像当初杰瑞输掉星巴克一样。</p>
<p>从此之后，星巴克就成为一头会跳舞的大象，身板庞大，但是总能灵活调整，找到企业新的增长点，不断的打造新产品。当咖啡店生意逐渐遇到瓶颈时候，霍华德和航空公司合作，将咖啡店开到机场，将咖啡卖到了飞机上；和百事可乐合作，开发灌装的咖啡；当星巴克开遍美国时候，又瞄上了全球市场；基于科学家的咖啡精华提取技术，提纯咖啡制作浓缩咖啡粉；投资数百万美元，创建实验室研究咖啡的口味、保存等问题。</p>
<p>星巴克的创新永远在路上，这才保证了星巴克稳定的增长。</p>
<h2 id="碎碎念"><a href="#碎碎念" class="headerlink" title="碎碎念"></a>碎碎念</h2><p><strong>1.做正确的选择</strong></p>
<p>并购星巴克后，新的企业应该叫”天天“还是”星巴克“？对于创业者来讲，对自己创建的第一个品牌都会有说不清的怀恋，在品牌选择时候，必须放下自我。出于公司长期发展的考虑，名字必须能够被容易记住，必须能够与人们的精神发生某种联系，必须给大家带来利益，所以，这个选择只能是星巴克。</p>
<p><strong>2.别被比你聪明的人吓倒</strong></p>
<p>最好的管理者是那些对优秀的人才有着良好直觉的人，一方面能够调动能人去放手做事，一方面可知自己不对他们的行动横加干涉。企业家往往喜欢自己出点子，自己去包打天下。但是，只有去聘用更有能力的人，更专业的人企业才能够获得更好的发展。因此完全不必担心别人比你聪明，因为比你聪明的人有很多，很多很多。坦陈自己的不足，坦陈别人比自己优秀，这样才能做一个更好的企业管理者。</p>
<p><strong>3.星巴克名字和logo的来源</strong></p>
<p>星巴克这个名字取自于小说《白鲸》，其中“皮廓德号”那条船的第一个伙伴的名字就叫星巴克。这个名字彰显了早期咖啡经销商远渡重洋和航海的浪漫情怀。星巴克logo的灵感源自于一副16世纪斯堪的纳维亚的木刻画：两条尾巴的美人鱼，或者塞壬，被星巴克最初的名字：星巴克咖啡、茶、香料（STARBUCKS COFFEE TEA SPICES）围绕起来。星巴克最初的塞壬头像是一个坦露胸部的具有鲁本斯风格的女人像，象征咖啡本身对人的诱惑。</p>
<img src="http://img.weidongfang.online/imgbed/20210522101914.png" width="20%">

<blockquote>
<p><strong>Reference:</strong></p>
<p>1.<a href="https://www.36kr.com/p/1723499380737" target="_blank" rel="noopener">星巴克的LOGO是怎么来的？这有一段神奇的历史_详细解读_最新资讯_热点事件_36氪 (36kr.com)</a></p>
<p>2.<a href="https://medium.com/fast-company/the-starbucks-logo-has-a-secret-youve-never-noticed-dca0e319b19a" target="_blank" rel="noopener">The Starbucks Logo Has A Secret You’ve Never Noticed | by Fast Company | Fast Company | Medium</a></p>
</blockquote>
<p><strong>4.投资就是投人</strong></p>
<p>霍华德经过自己一番努力，最终收获了很多笔投资。但是其中很多人之所以出钱是因为霍华德，而不是因为咖啡店这个点子。<strong>一句话，投资就是投人。</strong>从侧面也反映出了霍华德在当时已经获得很多人的支持，身边很多人都看好霍华德这个人，用中国话说就是：<strong>靠谱</strong>。</p>
<p><strong>5.我不同意你的观点，但是我捍卫你说话的权利</strong></p>
<p>星巴克的创始人杰瑞并不看好霍华德的咖啡生活方式的咖啡馆，但是在霍华德准备离开创办咖啡馆时候，仍然给他投资了15万美金，杰瑞说：这不是我们自己想要的公司，但是我们支持你。由此也可以看出，杰瑞也是一个宽宏大量的人，杰瑞虽然没有陪伴星巴克走向更加光明的未来，但是他也在坚守自己的价值观，坚守公司最初的理想。</p>
]]></content>
      <categories>
        <category>reading</category>
      </categories>
  </entry>
  <entry>
    <title>【译】如何在Set集合中避免重复元素</title>
    <url>/posts/2019-11/52136.html</url>
    <content><![CDATA[<blockquote>
<p>文章翻译自 <a href="https://www.hackingwithswift.com/articles/199/avoiding-near-duplicates-in-sets" target="_blank" rel="noopener">Avoiding near-duplicates in sets</a>, 作者<a href="https://www.hackingwithswift.com/about" target="_blank" rel="noopener">Paul Hudson</a> <a href="https://twitter.com/twostraws" target="_blank" rel="noopener">@twostraws</a>是一名优秀的Swifter。<br>这是我第一次翻译，可能有翻译不到位的地方，如果有任何问题，欢迎反馈。学习学习再学习，加油💪！</p>
</blockquote>
<p><img src="http://img.weidongfang.online/imgbed/coding-man-2.jpg" alt="img"></p>
<p>Julian Schiavo写道：我想用Set集合来保证我的Array中元素是唯一的，但是Set集合中每个元素都包含一个Date类型的变量，当两个不同元素仅仅是Date变量不同的时候，实际上Set中可以同时保存这两个元素，这就出现了重复元素。这种问题该怎么解决呢？</p>
<a id="more"></a>

<p>这是个好问题，实际上Swift的协议给我们提供了很聪明的解决方案。</p>
<p>首先，我们先看下下面示例代码。结构体<code>NewsStory</code>有三个属性：id、title、date：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NewsStory &#123;</span><br><span class="line">    var id: Int</span><br><span class="line">    var title: String</span><br><span class="line">    var date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码所示，结构体实例初始化时候会自动将当前时间赋值给date属性。</p>
<p>我们可以用上面的结构体创建三个对象，如下代码所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let story1 = NewsStory(id: 1, title: &quot;What&apos;s new in Swift 5.1?&quot;)</span><br><span class="line">let story2 = NewsStory(id: 2, title: &quot;What&apos;s new in Swift 6.0?&quot;)</span><br><span class="line">let story3 = NewsStory(id: 3, title: &quot;What&apos;s new in Swift 6.1?&quot;)</span><br></pre></td></tr></table></figure>

<p>Julian想要保存这些新的对象到一个Set集合而不是数组中，这是一个很明智的选择。因此我们写下如下的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var stories = Set&lt;NewsStory&gt;()</span><br><span class="line">stories.insert(story1)</span><br><span class="line">stories.insert(story2)</span><br><span class="line">stories.insert(story3)</span><br><span class="line">print(stories)</span><br></pre></td></tr></table></figure>

<p>如上代码所示，创建一个保存故事对象的Set，然后将我们创建的对象添加到Set集合中，然后打印这个Set集合。然而上面的代码无法通过编译：为了每个元素在Set中都有唯一的标识，我们需要让<code>NewStory</code>对象遵守<code>Hashable</code>协议，Hashable协议能够产生唯一的hash值来标识唯一的一个对象。</p>
<p>Swift语言这点做得非常好，我们只需要让一个包含Hashable属性的类型遵守<code>Hashable</code>协议即可，Hashable协议会自动帮我们计算这个对象的哈希值。因此我们需要更新<code>NewStory</code>结构体如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NewsStory: Hashable &#123;</span><br><span class="line">    var id: Int</span><br><span class="line">    var title: String</span><br><span class="line">    var date = Date()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到现在，我们的代码终于能够正常的跑起来啦！</p>
<p>然后，Julian遇到的问题并没有解决，如下代码所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let story4 = NewsStory(id: 1, title: &quot;What&apos;s new in Swift 5.1?&quot;)</span><br><span class="line">stories.insert(story4)</span><br><span class="line">print(stories)</span><br></pre></td></tr></table></figure>

<p>当我们创建一个和已存在对象相同ID和title的NewStory对象，并添加到set集合中，然后打印集合的内容，你会发现现在集合中包含4个对象，并且其中有一个是重复的。</p>
<p>就像前面写的那样，当一个类型遵守Hashable协议并且其属性也都遵守Hashable协议的时候，Swift会帮我们自动计算这个对象的hash值。计算方法是这样的：获取对象中所有属性的hash值并将它们结合在一起。</p>
<p>因此，我们以为两个对象是相同的，因为他们有相同的ID和title，但是在Swift看来他们是不同的，因为他们的date并不相同。</p>
<p>我们需要做的就是给Swift提供一个自定义的hash计算规则，告诉Swift说”如果两个stories对象的ID和title是相同的，那么他们就是相同的，请忽略date属性。”</p>
<p>为了自定义hash计算规则，我们需要在<code>NewStory</code>中实现两个方法：一个是自定义计算hash值，两一个是检查两个对象的唯一标识看是否相等。</p>
<p>第一个方法只使用ID来计算一个story对象的hash值，如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">    hasher.combine(id)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第二个方法使用运算符重载来实现一个自定义的<code>==</code>方法来比较两个story对象是否相同。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">static func ==(lhs: NewsStory, rhs: NewsStory) -&gt; Bool &#123;</span><br><span class="line">    return lhs.id == rhs.id</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到此为止，完美解决问题！我们实现Hashable版本比Swift自动生成的方法的版本更快，因为我们的hash函数只计算了ID的hash值，而Swift的版本计算了所有属性的hash值。</p>
<p>示例中我们只使用了id这个属性值，但是你在项目中也可以使用更多的属性来保证你的对象是不同的。</p>
<p>最终<code>NewsStory</code>代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">struct NewsStory: Hashable &#123;</span><br><span class="line">    var id: Int</span><br><span class="line">    var title: String</span><br><span class="line">    var date = Date()</span><br><span class="line"></span><br><span class="line">    func hash(into hasher: inout Hasher) &#123;</span><br><span class="line">        hasher.combine(id)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static func ==(lhs: NewsStory, rhs: NewsStory) -&gt; Bool &#123;</span><br><span class="line">        return lhs.id == rhs.id</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在我们的文章结束之前，需要提醒一点， 其实是<a href="https://twitter.com/cocoaphony/status/1174655727878758400" target="_blank" rel="noopener">Rob Napier</a>的提醒：相等意味着可替换——任何两个相等的对象在代码中都可以相互替换。如果你只比较了<code>id</code>，那就意味着”如果两个对象有相同的id，但是其它属性是不同的，我不关心其它属性是什么样的，算法可以自由的返回其中的任意一个。”</p>
<p>最后，也是最重要的一点：如果两个对象相等(因为自定义的<code>==</code>返回true)，那么Swift会自由选择。Swift可能总是选择第一个对象，也可能总是选择第二个对象，或者每次随机选择两个中的一个——这种表现在未来的Swift版本中可能会发生改变。记住这点，因为我们告诉Swift两个对象是相同的，才会发生这个问题，如果关于对象的选择对你来说很重要，你需要注意这个问题。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【译】SwiftUI入门教程</title>
    <url>/posts/2019-11/57431.html</url>
    <content><![CDATA[<p><a href="https://www.hackingwithswift.com/about" target="_blank" rel="noopener">Paul Hudson</a>    October 14th 2019     <a href="https://twitter.com/twostraws" target="_blank" rel="noopener">@twostraws</a></p>
<p><img src="http://img.weidongfang.online/imgbed/ios-13-1.jpg" alt="img"></p>
<p>SwiftUI是苹果公司新发布的用于构建UI界面的框架，它可以用于搭建iOS、macOS、tvOS、watchOS系统的UI界面。它采用声明式的方式进行构建，相比UIKit，使用SwiftUI搭建App更快、更安全。</p>
<a id="more"></a>

<p>如果你用过UIKit，刚上手使用SwiftUI可能会不习惯，因为我们已经习惯了用UIKit搭建界面的流程，但是一旦你习惯了SwiftUI声明式的方式，习惯了SwiftUI的思考方式，你一定会爱上SwiftUI。</p>
<p>WWDC2019苹果介绍SwiftUI时候，说它有四个特点：</p>
<ul>
<li><strong>声明式的：</strong>我们只需声明我们想要的样式，并不需要像UIKit那样描述如何实现我们的样式。</li>
<li><strong>自动化的：</strong>自动化意味着它可以省去很多之前我们必须手动完成的事情。</li>
<li><strong>可组合的：</strong>可组合意味着我们可以构建很多小的UI元素，然后将小的元素组合在一起，形成复杂的UI界面。</li>
<li><strong>稳定的：</strong>稳定意味着在不同版本的系统中SwiftUI搭建的界面表现是相同的。</li>
</ul>
<p>目前为止我已经使用SwiftUI写了成千上万行的代码，我可以明确的告诉你， 他们漏了很重要的一点：<strong>简洁</strong>。你使用SwiftUI搭建界面的代码量可能只有UIKit代码量的10-20%。之所以会减少这么多，是因为我们不需要再写重复的UI元素，也不用处理生命周期相关的方法等等。</p>
<p>让我们一起来看看SwiftUI到底是如何工作的：</p>
<ul>
<li>更新：我已经发布了大量的SwiftUI免费教程：<a href="https://hackingwithswift.com/quick-start/swiftui" target="_blank" rel="noopener">SwiftUI示例代码</a>。里面有很多代码示例和SwiftUI常见问题的解决方案，外加一个长视频叫你怎么搭建你的第一个完整SwiftUI项目。</li>
<li>现在你还可以关注我的<a href="https://www.hackingwithswift.com/100/swiftui" target="_blank" rel="noopener">100天SwiftUI入门</a>课程，手把手叫你写SwiftUI。</li>
</ul>
<h3 id="View是什么"><a href="#View是什么" class="headerlink" title="View是什么?"></a>View是什么?</h3><p>在SwiftUI中，<code>View</code>的功能类似于<code>UIView</code>，但是有两个重要的不同点：</p>
<ol>
<li>View是协议类型而不是class类型，因此不会出现继承问题。</li>
<li>我们的view必须返回唯一的一个view，这个view内部可以包含多个其他的view，但是我们只能返回多个view的superview。</li>
</ol>
<p>苹果给的代码示例如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可能会注意到这些事情：</p>
<ol>
<li>上述View的返回值是<code>some View</code>，其实some view是一个透明类型。如果你没见过这种用法，你可以参考我的文章：<a href="https://www.youtube.com/watch?v=DvHkeUxiwYY&feature=youtu.be" target="_blank" rel="noopener">透明返回类型</a>。</li>
<li>它实际上返回的是一个包含文本“Hello World”的Text视图，Text等价于UIKit中的UILabel。</li>
<li>这里并没有使用<code>return</code>关键字，这是Swift5.1的另一个新特性，如果你不明白可以查看<a href="https://www.youtube.com/watch?v=EkvxlrYFUkc&feature=youtu.be" target="_blank" rel="noopener">我的视频</a>。</li>
</ol>
<h3 id="创建栈布局"><a href="#创建栈布局" class="headerlink" title="创建栈布局"></a>创建栈布局</h3><p>前面提到，我们的View必须返回唯一的一个东西，不是0个、2个或者200个。因此如果你想要展示多个标签，你必须将他们放到一个容器里面，比如<code>HStack</code>、<code>VStack</code>、<code>ZStack</code>，分别对应水平布局、垂直布局、堆叠布局。</p>
<p>因此，如果你想要垂直排列三个label，你需要像下面这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，这些label只会占据他们需要的空间，所以你将会在屏幕中央看到这三个label。如果你想让他们分开，你需要使用<code>Spacer</code>插入一个可变的控件，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">    <span class="type">VStack</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">        <span class="type">Spacer</span>()</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello World"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在你将会看到前两个label在你屏幕的顶部，然后是一个空隙，然后是最后一个view在屏幕的底部。为了产生更加微妙的效果，你可以使用Divider，这个可以用来创建元素水平上的空隙，而不会将他们推开。</p>
<h3 id="创建列表内容"><a href="#创建列表内容" class="headerlink" title="创建列表内容"></a>创建列表内容</h3><p>用过UIKit的人都知道，创建TableView是非常单调乏味的事情：首先注册cell，然后告诉UIKit列表中有多少个元素，从缓存池中获取cell并进行配置，然后是其它的工作，这些重复的工作是非常乏味的。</p>
<p>而在SwiftUI中，我们不再需要做这些重复的工作。</p>
<p>列表在SwiftUI中用<code>List</code>来实现，它能够展示静态或者动态的内容。例如，我们可能想要定义一个结构体来定义用户的属性，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们要想把如上结构体展示到一个列表中，首先我们需要定义列表中的一行是什么样子的。因为每一行都需要展示一个结构体类型User，所以我们需要在View对象中添加一个User属性，由于列表中每一行都需要展示name属性，所以我们需要让我们View的body返回一个展示文本的视图。</p>
<p>如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserRow</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user: <span class="type">User</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"\(user.firstName) \(user.lastName)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，我们需要更新<code>ContentView</code>结构体以便创建多个用户，然后将用户放置到列表中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> user1 = <span class="type">User</span>(firstName: <span class="string">"Piper"</span>, lastName: <span class="string">"Chapman"</span>)</span><br><span class="line">        <span class="keyword">let</span> user2 = <span class="type">User</span>(firstName: <span class="string">"Gloria"</span>, lastName: <span class="string">"Mendoza"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">List</span> &#123;</span><br><span class="line">            <span class="type">UserRow</span>(user: user1)</span><br><span class="line">            <span class="type">UserRow</span>(user: user2)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面简单的列表示例可以正常运行，但是为了更好的使用列表展示数据，你可能想要通过一个数组来动态配置列表内容，让SwiftUI自行判断需要多少行，自动创建并且展示。</p>
<p>为了实现这个功能，我们需要让User实现<code>Identifiable</code>协议，以便让SwiftUI确定唯一的一个用户。我们可以通过判断每个User中每个属性是否相同来实现这个功能，但是这样效率很低并且容易出错。因此我们需要给我们的User结构体添加一个id属性，以此来保证列表中的User不会发生重复。</p>
<p>我们给User添加一个id属性，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> id: <span class="type">Int</span></span><br><span class="line">    <span class="keyword">var</span> firstName: <span class="type">String</span></span><br><span class="line">    <span class="keyword">var</span> lastName: <span class="type">String</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你可以使用任何你想用的类型来做唯一标记，比如字符串、UUID等等。</p>
<p>现在我们可以创建一个包含多个User对象的数组，你可以随便填写一点内容，然后通过闭包给每一行配置数据，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="comment">// create some example data</span></span><br><span class="line">        <span class="keyword">let</span> user1 = <span class="type">User</span>(id: <span class="number">1</span>, firstName: <span class="string">"Piper"</span>, lastName: <span class="string">"Chapman"</span>)</span><br><span class="line">        <span class="keyword">let</span> user2 = <span class="type">User</span>(id: <span class="number">2</span>, firstName: <span class="string">"Gloria"</span>, lastName: <span class="string">"Mendoza"</span>)</span><br><span class="line">        <span class="keyword">let</span> users = [user1, user2]</span><br><span class="line"></span><br><span class="line">        <span class="comment">// show that data</span></span><br><span class="line">        <span class="keyword">return</span> <span class="type">List</span>(users) &#123; user <span class="keyword">in</span></span><br><span class="line">            <span class="type">UserRow</span>(user: user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>声明一点：上面示例大部分代码都是为了创建示例数据用的，真正的SwiftUI代码只有三行，这三行还包含了闭包的必要结构。</p>
<p>实际上，如果你想像上面示例那张展示数据，你只需要写一行SwiftUI代码即可，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">List</span>(users, rowContent: <span class="type">UserRow</span>.<span class="keyword">init</span>)</span><br></pre></td></tr></table></figure>

<p><strong>Duang！</strong></p>
<p>说实话，SwiftUI将会大量的削减你的UI代码。</p>
<p>在结束这个例子之前，再说一点：我们可以随意的修改UserRow而无需担心它在哪里使用了它。SwiftUI一个重要特性就是可组合的，我们把一个User对象传递给UserRow，UserRow会自行决定如何展示数据，我们不需要像UIKit那样使用主视图来控制所有的子视图。</p>
<p>如果你想要让UserRow垂直展示两个Label，其中一个使用大标题，一个使用小标题，并且都靠左对齐，你可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">UserRow</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> user: <span class="type">User</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span>(alignment: .leading) &#123;</span><br><span class="line">            <span class="type">Text</span>(user.firstName)</span><br><span class="line">                .font(.largeTitle)</span><br><span class="line">            <span class="type">Text</span>(user.lastName)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>漂亮！</p>
<h3 id="展示一个详细页"><a href="#展示一个详细页" class="headerlink" title="展示一个详细页"></a>展示一个详细页</h3><p>仅仅展示一个页面挺没意思的，再来一个吧。</p>
<p>首先，我们想让这个视图展示列表中选中User的名字，并且用红色字体大标题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DetailView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> selectedUser: <span class="type">User</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(selectedUser.lastName)</span><br><span class="line">            .font(.largeTitle)</span><br><span class="line">            .foregroundColor(.red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们想把列表嵌入到一个导航View中，相当于是UIKit中的导航控制器：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> user1 = <span class="type">User</span>(id: <span class="number">1</span>, firstName: <span class="string">"Piper"</span>, lastName: <span class="string">"Chapman Yay"</span>)</span><br><span class="line">        <span class="keyword">let</span> user2 = <span class="type">User</span>(id: <span class="number">2</span>, firstName: <span class="string">"Gloria"</span>, lastName: <span class="string">"Mendoza"</span>)</span><br><span class="line">        <span class="keyword">let</span> users = [user1, user2]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="type">NavigationView</span> &#123;</span><br><span class="line">            <span class="type">List</span>(users, rowContent: <span class="type">UserRow</span>.<span class="keyword">init</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>默认情况下，导航栏没有标题，所以你需要给导航栏添加一个标题：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(users, rowContent: <span class="type">UserRow</span>.<span class="keyword">init</span>)</span><br><span class="line">    .navigationBarTitle(<span class="string">"Users"</span>)</span><br></pre></td></tr></table></figure>

<p>我们真正想要的是点击列表中的一行，然后展示这一行对应的详情页面。</p>
<p>为了实现这个功能，我们需要将我们的UserRow包装到NavigationLink中。NavigationLink的初始化方法需要几个参数，这里我们只填两个参数，一个是点击后要跳转的目标View，另一个是闭包来给每一行添加数据。这个示例中，是给我们的UserRow配置数据。</p>
<p>我们的NavigationView变成了这样：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="type">NavigationView</span> &#123;</span><br><span class="line">    <span class="type">List</span>(users) &#123; user <span class="keyword">in</span></span><br><span class="line">        <span class="type">NavigationLink</span>(destination: <span class="type">DetailView</span>(selectedUser: user)) &#123;</span><br><span class="line">            <span class="type">UserRow</span>(user: user)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;.navigationBarTitle(<span class="string">"Users"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在发生了两件事情。首先，如果你点击右下角预览区域的播放按钮，你会看到现在你可以点击列表中的行然后展开详情页面了；其次你会注意到我们列表行有一个指示器，意思是SwiftUI是自动化的。</p>
<h3 id="接下来怎么做？"><a href="#接下来怎么做？" class="headerlink" title="接下来怎么做？"></a>接下来怎么做？</h3><p>一旦你习惯了使用SwiftUI，你再使用UIKit就好比是用习惯了Swift再回去用Objective-C，类似于<code>viewDidLoad()</code>等保证生命周期的方法看起来就很多余了，你可能开始讨厌编写这些模板代码了，因为这些东西在SwiftUI中全部都不见了。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【译】不安全的Swift：Swift指针与C交互</title>
    <url>/posts/2020-02/13093.html</url>
    <content><![CDATA[<blockquote>
<p>原文链接：<a href="https://www.raywenderlich.com/7181017-unsafe-swift-using-pointers-and-interacting-with-c" target="_blank" rel="noopener">https://www.raywenderlich.com/7181017-unsafe-swift-using-pointers-and-interacting-with-c</a></p>
<p>在这个教程中，你将学会如何在swift中使用指针直接操作内存。</p>
</blockquote>
<p>默认情况下，Swift是内存安全的：Swift禁止直接的内存访问并确保你定义的变量在使用之前必须初始化。但是，这只是“默认情况下”。在 Swift中你也可以使用指针来直接访问内存。</p>
<p>本教程将带你快速浏览一下Swift所谓“不安全”的特性。</p>
<p>这里的 “不安全”并不意味着危险的错误代码，而是说编写这部分代码需要格外的小心，因为编译器并不会为这部分代码做全面的检查。</p>
<a id="more"></a>

<p>这个特性你可能在很多场景下用到，比如，在代码中和其它非内存安全的语言进行交互 （比如C语言），想要优化代码运行时性能或者探索Swift语言的内部实现等。本教程将教你如何使用指针直接和内存进行交互。</p>
<h1 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h1><p>本教程用到的素材文件请<a href="https://koenig-media.raywenderlich.com/uploads/2020/02/Unsafe-Swift.zip" target="_blank" rel="noopener">点这里</a>下载，其中包含三个空的Swift playgrounds：</p>
<ul>
<li>第一个playground中，你将使用几个简单的代码片段探索内存布局，你将体验使用不安全的指针类型。</li>
<li>第二个playground中，你将会把一个底层的C语言压缩数据流的API包装成Swift接口。</li>
<li>最后一个playground中，你将创建一个不依赖平台的<code>arc4random</code>函数来产生随机数。它使用不安全的Swift特性，但是对用户隐藏实现细节。</li>
</ul>
<p>首先，打开名字为<code>UnsafeSwift</code>的playground开始吧！本教程中所有代码都和处理器平台无关，所以你可以使用任何平台。</p>
<h1 id="使用Swift指针探索内存布局"><a href="#使用Swift指针探索内存布局" class="headerlink" title="使用Swift指针探索内存布局"></a>使用Swift指针探索内存布局</h1><p><img src="http://img.weidongfang.online/imgbed/memory-480x214.png" alt></p>
<p>不安全的Swift可以直接操作内存。你可以将内存看成是一系列的盒子——数十亿个盒子——每个盒子都包含一个数字。</p>
<p>每个盒子都有一个唯一的内存地址。最小的可寻址的单位是一个字节，通常一个字节包含8bits。</p>
<p>8bits能够存储数值从0-255。处理器能够高效的访问一组包含多个字节的内存地址。</p>
<p>在64bit操作系统中，处理器能够操作8个字节也就是64bit的宽度。你可以使用<code>MemoryLayout</code>来查看Swift基础类型所占的大小或者对齐方式。</p>
<p>将下面的代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.size          <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.alignment     <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.<span class="built_in">stride</span>        <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.size        <span class="comment">// returns 2</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment   <span class="comment">// returns 2</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span>      <span class="comment">// returns 2</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.size         <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.alignment    <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Bool</span>&gt;.<span class="built_in">stride</span>       <span class="comment">// returns 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.size        <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.alignment   <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Float</span>&gt;.<span class="built_in">stride</span>      <span class="comment">// returns 4</span></span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.size       <span class="comment">// returns 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.alignment  <span class="comment">// returns 8</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">Double</span>&gt;.<span class="built_in">stride</span>     <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p><code>MemoryLayout&lt;Type&gt;</code> 是一个泛型，具体类型会在编译时进行推断。它会返回一个数字，表示某个特定类型的<code>size</code>, <code>alignment</code>, <code>stride</code>相关的信息。</p>
<p>例如，<code>Int16</code>的size是两个字节，它的对齐宽度是2。这意味着它必须从偶数地址开始，也就是能够被2整除的地址开始。</p>
<p>例如，在内存地址是100的位置分配空间给<code>Int16</code>是合法的，而在内存地址101位置分配就是非法的——只有偶数地址才符合要求的对齐宽度。</p>
<p>当你需要将一堆<code>Int16</code>放在一起时候，它们必须以指定间隔放置。对于这些基本类型，size和stride是相同的。</p>
<h1 id="检查结构体的布局"><a href="#检查结构体的布局" class="headerlink" title="检查结构体的布局"></a>检查结构体的布局</h1><p>接下来，让我们看看自定义结构体的内存布局，将下面代码添加到playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">EmptyStruct</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.size      <span class="comment">// returns 0</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.alignment <span class="comment">// returns 1</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyStruct</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 1</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SampleStruct</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number: <span class="type">UInt32</span></span><br><span class="line">  <span class="keyword">let</span> flag: <span class="type">Bool</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.size       <span class="comment">// returns 5</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.alignment  <span class="comment">// returns 4</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleStruct</span>&gt;.<span class="built_in">stride</span>     <span class="comment">// returns 8</span></span><br></pre></td></tr></table></figure>

<p>一个空的结构体所占内存空间大小是0，由于它的对齐宽度是1，任何一个内存地址都能够被1整除，所以它能够在任何一个内存地址上申请空间。</p>
<p>奇怪的是，stride也是1。这是因为你创建的每个<code>EmptyStruct</code>对象必须有唯一一个内存地址，即便它所需要的内存大小是0，它也需要。</p>
<p>对于<code>SampleStruct</code>，它所需要内存大小是5B，但是stride却是8。这是因为内存对齐要求最小的内存空间必须能被4整除。鉴于此，最好的办法是以八个字节为一组。</p>
<p>为了区别类型和结构体内存布局的不同之处，将下面代码添加到playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EmptyClass</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.size      <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">EmptyClass</span>&gt;.alignment <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SampleClass</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> number: <span class="type">Int64</span> = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> flag = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.size      <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.<span class="built_in">stride</span>    <span class="comment">// returns 8 (on 64-bit)</span></span><br><span class="line"><span class="type">MemoryLayout</span>&lt;<span class="type">SampleClass</span>&gt;.alignment <span class="comment">// returns 8 (on 64-bit)</span></span><br></pre></td></tr></table></figure>

<p>类是引用类型，所以<code>MemoryLayout</code>给出的是一个引用类型的大小：八个字节。</p>
<p>如果你深入探索内存布局，可以产看迈克尔的讲解，<a href="https://realm.io/news/goto-mike-ash-exploring-swift-memory-layout/" target="_blank" rel="noopener">探索Swift内存布局</a></p>
<h1 id="在Swift中使用指针"><a href="#在Swift中使用指针" class="headerlink" title="在Swift中使用指针"></a>在Swift中使用指针</h1><p>一个指针指向一个内存地址。</p>
<p>能够直接访问内存的类型都包含一个<em>unsafe</em>前缀，所以Swift指针类型就叫<code>UnsafePointer</code>。额外的前缀似乎很烦人，但是它提醒你你直接访问内存地址的行为是不安全的，编译器并不会对你的访问进行安全校验。当你访问错误地址时候，可能会导致<a href="http://blog.llvm.org/2011/05/what-every-c-programmer-should-know.html" target="_blank" rel="noopener">未知的结果</a>，而不是可预测的崩溃。</p>
<p>Swift不像C语言那样仅仅提供了一种非结构化的内存访问方法（char *），在Swift中除了<code>UnsafePointer</code>访问内存，还包含其它多种指针类型，每种都有不同的功能和目的。你需要在编码中选择恰当的指针类型，这样可以更好的传达你的意图、更不容易出错同时也能避免未知的结果。</p>
<p>不安全的Swift指针使用可预知的命名方案来描述指针类型的特征：可变还是不可变、原始类型还是非原始类型、是否是缓冲区，总共有八种不同的指针类型。你将在接下来的章节详细的了解它们。</p>
<p><img src="http://img.weidongfang.online/imgbed/pointers-650x444.png" alt="Guide to unsafe swift pointers"></p>
<p>#使用原始指针</p>
<p>本节中，你将会使用Swift指针来存储和加载两个整数。将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.<span class="built_in">stride</span></span><br><span class="line"><span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int</span>&gt;.alignment</span><br><span class="line"><span class="keyword">let</span> byteCount = <span class="built_in">stride</span> * <span class="built_in">count</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Raw pointers"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(</span><br><span class="line">    byteCount: byteCount,</span><br><span class="line">    alignment: alignment)</span><br><span class="line">  <span class="comment">// 4</span></span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    pointer.deallocate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 5</span></span><br><span class="line">  pointer.storeBytes(of: <span class="number">42</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">  pointer.advanced(by: <span class="built_in">stride</span>).storeBytes(of: <span class="number">6</span>, <span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">  pointer.load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">  pointer.advanced(by: <span class="built_in">stride</span>).load(<span class="keyword">as</span>: <span class="type">Int</span>.<span class="keyword">self</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 6</span></span><br><span class="line">  <span class="keyword">let</span> bufferPointer = <span class="type">UnsafeRawBufferPointer</span>(start: pointer, <span class="built_in">count</span>: byteCount)</span><br><span class="line">  <span class="keyword">for</span> (index, byte) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"byte \(index): \(byte)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里发生的事情：</p>
<ol>
<li>这里定义的常量保存后面频繁使用的值：<ul>
<li><code>count</code>表示需要保存整数的个数。</li>
<li><code>stride</code>表示整数类型的宽度。</li>
<li><code>alignment</code>表示整数类型的对齐宽度。</li>
<li><code>byteCount</code>保存总共需要的字节数。</li>
</ul>
</li>
<li>使用<code>do</code>关键字定义一个代码块，这样在后续的代码中你可以使用相同的变量名字。</li>
<li><code>UnsafeMutableRawPointer.allocate</code>方法分配指定字节数量的内存空间，这个方法返回<code>UnsafeMutableRawPointer</code>类型。从类型名字中你可以看出，这个指针可以加载和存储或者改变原始的内容。</li>
<li><code>defer</code>关键字用来保证你正确的释放指针。这里ARC并不会帮你管理内存——你需要自行管理你申请 的内存空间！</li>
<li><code>storeBytes</code> 和 <code>load</code>分别用来保存和加载数据。这里你可以通过stride来计算第二个整数存储的位置。由于指针类型遵守<code>Strideable</code>协议，这里你也可以这样写：``(pointer+stride).storeBytes(of: 6, as: Int.self)`。</li>
<li><code>UnsafeRawBufferPointer</code>类型可以让你像访问字节数组那样的访问内存，这意味着你可以通过下标访问它们，你也可以使用filter/map/reduce等高阶函数访问它们。你可以使用原始指针来初始化一个缓冲区指针。</li>
</ol>
<p>即便<code>UnsafeRawBufferPointer</code>是不安全的，你也可以将它特化成指定类型。</p>
<p>#使用特化指针</p>
<p>你可以使用特化指针简化前面的例子。将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Typed pointers"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int</span>&gt;.allocate(capacity: <span class="built_in">count</span>)</span><br><span class="line">  pointer.initialize(repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    pointer.deinitialize(<span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">    pointer.deallocate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  pointer.pointee = <span class="number">42</span></span><br><span class="line">  pointer.advanced(by: <span class="number">1</span>).pointee = <span class="number">6</span></span><br><span class="line">  pointer.pointee</span><br><span class="line">  pointer.advanced(by: <span class="number">1</span>).pointee</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bufferPointer = <span class="type">UnsafeBufferPointer</span>(start: pointer, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">for</span> (index, value) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value \(index): \(value)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意下面的不同点：</p>
<ul>
<li>你通过<code>UnsafeMutablePointer.allocate</code>来分配内存空间，特化参数类型告诉Swift你想要加载和存储的类型是整数类型。</li>
<li>你必须在使用内存空间之前初始化，使用之后去初始化，分别对应<code>initialize</code> 和 <code>deinitialize</code> 。<em>non-trivial types</em>类型的去初始化是必须的，其它类型是非必须的，不过最好所有类型都加上，这样就算你以后将trivial类型改成了<em>non-trivial types</em>类型代码一样完美运行。编译器会在编译期将不需要的代码自动移除掉。</li>
<li>特化指针有一个<code>pointee</code>属性，这个属性提供类型安全的方法存储和加载数值。</li>
<li>当向前推进指针位置时候，你可以通过提供一个index来完成。指针能够自行根据特化类型计算出你想要推进到的位置。当然，这里使用算数加减也是可以的，这里你也可以这么写： <code>(pointer+1).pointee = 6</code>。</li>
<li>对于特化缓冲区类型同样如此：它 迭代的是值的宽度而不是单个字节。</li>
</ul>
<p>接下来，你将会学到如何将不受约束的<code>UnsafeRawBufferPointer</code>变得更加安全，类型约束的<code>UnsafeRawBufferPointer</code>。</p>
<h1 id="将原始指针转化成特化指针"><a href="#将原始指针转化成特化指针" class="headerlink" title="将原始指针转化成特化指针"></a>将原始指针转化成特化指针</h1><p>你并不需要每次都直接初始化特化指针，你也可以把原始指针变成特化指针。将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Converting raw pointers to typed pointers"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> rawPointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(</span><br><span class="line">    byteCount: byteCount,</span><br><span class="line">    alignment: alignment)</span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    rawPointer.deallocate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> typedPointer = rawPointer.bindMemory(to: <span class="type">Int</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span>)</span><br><span class="line">  typedPointer.initialize(repeating: <span class="number">0</span>, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">defer</span> &#123;</span><br><span class="line">    typedPointer.deinitialize(<span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  typedPointer.pointee = <span class="number">42</span></span><br><span class="line">  typedPointer.advanced(by: <span class="number">1</span>).pointee = <span class="number">6</span></span><br><span class="line">  typedPointer.pointee</span><br><span class="line">  typedPointer.advanced(by: <span class="number">1</span>).pointee</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bufferPointer = <span class="type">UnsafeBufferPointer</span>(start: typedPointer, <span class="built_in">count</span>: <span class="built_in">count</span>)</span><br><span class="line">  <span class="keyword">for</span> (index, value) <span class="keyword">in</span> bufferPointer.enumerated() &#123;</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">"value \(index): \(value)"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个例子除了在刚开始的时候申请的原始指针，其它部分都和前面的例子非常相似。你通过将内存空间绑定到整数类型上来创建了一个特化指针。</p>
<p>通过绑定内存空间，你可以更加安全的访问内存。创建特化指针时候，类型绑定会在后台自动完成。这个例子剩下的部分和上个例子是相同的，一旦你有了特化指针，你就可以使用pointee等特化指针相关的属性。</p>
<h1 id="获取一个实例对象的所有的字节"><a href="#获取一个实例对象的所有的字节" class="headerlink" title="获取一个实例对象的所有的字节"></a>获取一个实例对象的所有的字节</h1><p>很多时候，你有一个实例化的对象，你想要检查这个对象的内存情况，你可以通过<code>withUnsafeBytes(of:)</code>方法来实现。</p>
<p>将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Getting the bytes of an instance"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  withUnsafeBytes(of: &amp;sampleStruct) &#123; bytes <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">for</span> byte <span class="keyword">in</span> bytes &#123;</span><br><span class="line">      <span class="built_in">print</span>(byte)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码将打印出 <code>SampleStruct</code> 对象的原始字节值。</p>
<p><code>withUnsafeBytes(of:)</code> 方法可以给你提供一个<code>UnsafeRawBufferPointer</code>类型指针，你可以在闭包中使用这个指针。数组和Data类型上也可以使用<code>withUnsafeBytes</code>方法。</p>
<h1 id="计算校验和"><a href="#计算校验和" class="headerlink" title="计算校验和"></a>计算<a href="https://baike.baidu.com/item/Checksum/1691589?fr=aladdin" target="_blank" rel="noopener">校验和</a></h1><p> <code>withUnsafeBytes(of:)</code>可以返回一个值。例如，你可以使用它来计算结构中字节的32位校验和。将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Checksum the bytes of a struct"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> checksum = withUnsafeBytes(of: &amp;sampleStruct) &#123; (bytes) -&gt; <span class="type">UInt32</span> <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> ~bytes.<span class="built_in">reduce</span>(<span class="type">UInt32</span>(<span class="number">0</span>)) &#123; $<span class="number">0</span> + <span class="built_in">numericCast</span>($<span class="number">1</span>) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"checksum"</span>, checksum) <span class="comment">// prints checksum 4294967269</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>reduce方法将所有的字节加起来，然后使用<code>~</code>反转每一个比特位，虽然这并不是最靠谱的校验方法，但它显示了这一概念。</p>
<p>现在你知道如何使用不安全的Swift了，接下来告诉你几个一定一定不能做的事情。</p>
<h1 id="使用Swift指针三个注意事项"><a href="#使用Swift指针三个注意事项" class="headerlink" title="使用Swift指针三个注意事项"></a>使用Swift指针三个注意事项</h1><p>当写不安全代码时候，要注意避免出现不可预知的结果。这里有几个反面教材：</p>
<h2 id="不要在withUnsafeBytes闭包中返回指针"><a href="#不要在withUnsafeBytes闭包中返回指针" class="headerlink" title="不要在withUnsafeBytes闭包中返回指针"></a>不要在withUnsafeBytes闭包中返回指针</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule #1</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"1. Don't return the pointer from withUnsafeBytes!"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> sampleStruct = <span class="type">SampleStruct</span>(number: <span class="number">25</span>, flag: <span class="literal">true</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> bytes = withUnsafeBytes(of: &amp;sampleStruct) &#123; bytes <span class="keyword">in</span></span><br><span class="line">    <span class="keyword">return</span> bytes <span class="comment">// strange bugs here we come ☠️☠️☠️</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"Horse is out of the barn!"</span>, bytes) <span class="comment">// undefined!!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>withUnsafeBytes(of:)</code>中的指针只能在闭包中使用，决不能让指针超出闭包范围存在，即使当时你的代码是好好的，未来也可能出现奇怪的bug。</p>
<p>##一次绑定一个类型</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule #2</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"2. Only bind to one type at a time!"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">3</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span></span><br><span class="line">  <span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment</span><br><span class="line">  <span class="keyword">let</span> byteCount = <span class="built_in">count</span> * <span class="built_in">stride</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(</span><br><span class="line">    byteCount: byteCount,</span><br><span class="line">    alignment: alignment)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> typedPointer1 = pointer.bindMemory(to: <span class="type">UInt16</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Breakin' the Law... Breakin' the Law (Undefined behavior)</span></span><br><span class="line">  <span class="keyword">let</span> typedPointer2 = pointer.bindMemory(to: <span class="type">Bool</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span> * <span class="number">2</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// If you must, do it this way:</span></span><br><span class="line">  typedPointer1.withMemoryRebound(to: <span class="type">Bool</span>.<span class="keyword">self</span>, capacity: <span class="built_in">count</span> * <span class="number">2</span>) &#123;</span><br><span class="line">    (boolPointer: <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Bool</span>&gt;) <span class="keyword">in</span></span><br><span class="line">    <span class="built_in">print</span>(boolPointer.pointee) <span class="comment">// See Rule #1, don't return the pointer</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不要同时将内存绑定到两个不相关的类型上去，Swift不喜欢这么做。</p>
<p>你可以使用 <code>withMemoryRebound(to:capacity:)</code>将内存暂时的绑定到不同的类型上。</p>
<p>同样的，将<a href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md#trivial-types" target="_blank" rel="noopener">trivial type</a>绑定到non-trivial也是不合法的，比如将Int类型绑定到class类型上，千万不要这么做！</p>
<h2 id="千万不要走到尽头…"><a href="#千万不要走到尽头…" class="headerlink" title="千万不要走到尽头…"></a>千万不要走到尽头…</h2><figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Rule #3... wait</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">"3. Don't walk off the end... whoops!"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">count</span> = <span class="number">3</span></span><br><span class="line">  <span class="keyword">let</span> <span class="built_in">stride</span> = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.<span class="built_in">stride</span></span><br><span class="line">  <span class="keyword">let</span> alignment = <span class="type">MemoryLayout</span>&lt;<span class="type">Int16</span>&gt;.alignment</span><br><span class="line">  <span class="keyword">let</span> byteCount =  <span class="built_in">count</span> * <span class="built_in">stride</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> pointer = <span class="type">UnsafeMutableRawPointer</span>.allocate(</span><br><span class="line">    byteCount: byteCount,</span><br><span class="line">    alignment: alignment)</span><br><span class="line">  <span class="keyword">let</span> bufferPointer = <span class="type">UnsafeRawBufferPointer</span>(start: pointer, <span class="built_in">count</span>: byteCount + <span class="number">1</span>) </span><br><span class="line">  <span class="comment">// OMG +1????</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> byte <span class="keyword">in</span> bufferPointer &#123;</span><br><span class="line">    <span class="built_in">print</span>(byte) <span class="comment">// pawing through memory like an animal</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不安全的代码，经常会出现一一对应错误的问题，小心点，注意代码审查和测试！</p>
<h1 id="不安全的Swift例1：压缩数据"><a href="#不安全的Swift例1：压缩数据" class="headerlink" title="不安全的Swift例1：压缩数据"></a>不安全的Swift例1：压缩数据</h1><p>是时候运用你所学知识包装一个C API了。Cocoa框架包含了一个实现数据压缩算法的C模块。这些算法包括：</p>
<ul>
<li><strong>LZ4</strong>：追求快速时候可以使用这个。</li>
<li><strong>LZ4A</strong>：当你需要很高压缩率并不在乎压缩速度时候可以使用这个。</li>
<li><strong>ZLIB</strong>：平衡了压缩率和压缩速度。</li>
<li><strong>LZFSE</strong>：一个新的开源的库，比起ZLIB更好的平衡了压缩率和压缩速度。</li>
</ul>
<p>现在你可以打开名字是<em>Compression</em>的playground。</p>
<p>首先，你需要使用<code>Data</code>创建一个纯Swift的API，将如下代码粘贴到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"><span class="keyword">import</span> Compression</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressionAlgorithm</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> lz4   <span class="comment">// speed is critical</span></span><br><span class="line">  <span class="keyword">case</span> lz4a  <span class="comment">// space is critical</span></span><br><span class="line">  <span class="keyword">case</span> zlib  <span class="comment">// reasonable speed and space</span></span><br><span class="line">  <span class="keyword">case</span> lzfse <span class="comment">// better speed and space</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CompressionOperation</span> </span>&#123;</span><br><span class="line">  <span class="keyword">case</span> compression, decompression</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// return compressed or uncompressed data depending on the operation</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">perform</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="number">_</span> operation: CompressionOperation,</span></span></span><br><span class="line"><span class="function"><span class="params">  on input: Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  using algorithm: CompressionAlgorithm,</span></span></span><br><span class="line"><span class="function"><span class="params">  workingBufferSize: Int = <span class="number">2000</span>)</span></span> </span><br><span class="line">    -&gt; <span class="type">Data?</span>  &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现压缩和解压缩的方法是<code>preform</code>，现在它返回的是nil，等会你需要在这个方法里面添加一些不安全的Swift代码。</p>
<p>接下来，将如下代码添加到你的playground的尾部：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// Compressed keeps the compressed data and the algorithm</span></span><br><span class="line"><span class="comment">/// together as one unit, so you never forget how the data was</span></span><br><span class="line"><span class="comment">/// compressed.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Compressed</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data: <span class="type">Data</span></span><br><span class="line">  <span class="keyword">let</span> algorithm: <span class="type">CompressionAlgorithm</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">init</span>(data: <span class="type">Data</span>, algorithm: <span class="type">CompressionAlgorithm</span>) &#123;</span><br><span class="line">    <span class="keyword">self</span>.data = data</span><br><span class="line">    <span class="keyword">self</span>.algorithm = algorithm</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// Compresses the input with the specified algorithm. Returns nil if it fails.</span></span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">compress</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    input: Data,with algorithm: CompressionAlgorithm)</span></span> </span><br><span class="line">      -&gt; <span class="type">Compressed?</span> &#123;</span><br><span class="line">    <span class="keyword">guard</span> <span class="keyword">let</span> data = perform(.compression, on: input, using: algorithm) <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Compressed</span>(data: data, algorithm: algorithm)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/// Uncompressed data. Returns nil if the data cannot be decompressed.</span></span><br><span class="line"> <span class="function"><span class="keyword">func</span> <span class="title">decompressed</span><span class="params">()</span></span> -&gt; <span class="type">Data?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> perform(.decompression, on: data, using: algorithm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Compressed</code>结构体存储需要压缩的数据和用来实现实现压缩的算法类型。这样在选择解压缩算法时候更不容易出错。</p>
<p>接下来，将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">/// For discoverability, adds a compressed method to Data</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Data</span> </span>&#123;</span><br><span class="line">  <span class="comment">/// Returns compressed data or nil if compression fails.</span></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">compressed</span><span class="params">(with algorithm: CompressionAlgorithm)</span></span> -&gt; <span class="type">Compressed?</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Compressed</span>.compress(input: <span class="keyword">self</span>, with: algorithm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Example usage:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> input = <span class="type">Data</span>(<span class="type">Array</span>(repeating: <span class="type">UInt8</span>(<span class="number">123</span>), <span class="built_in">count</span>: <span class="number">10000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> compressed = input.compressed(with: .lzfse)</span><br><span class="line">compressed?.data.<span class="built_in">count</span> <span class="comment">// in most cases much less than original input count</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> restoredInput = compressed?.decompressed()</span><br><span class="line">input == restoredInput <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>其中最重要的是Data的扩展。你已经在扩展中添加了<code>compressed(with:)</code>方法，这个方法返回值是<code>Compressed</code>可选值。这个方法只是简单的调用 <code>Compressed</code>的静态方法<code>compress(input:with:)</code>。</p>
<p>扩展后面的代码是一个使用示例，但是现在它还无法正常工作。</p>
<p>滑动到你输入的第一个代码块位置，将如下diamante插入到<code>perform(_:on:using:workingBufferSize:)</code>发方法中。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// set the algorithm</span></span><br><span class="line"><span class="keyword">let</span> streamAlgorithm: compression_algorithm</span><br><span class="line"><span class="keyword">switch</span> algorithm &#123;</span><br><span class="line"><span class="keyword">case</span> .lz4:   streamAlgorithm = <span class="type">COMPRESSION_LZ4</span></span><br><span class="line"><span class="keyword">case</span> .lz4a:  streamAlgorithm = <span class="type">COMPRESSION_LZMA</span></span><br><span class="line"><span class="keyword">case</span> .zlib:  streamAlgorithm = <span class="type">COMPRESSION_ZLIB</span></span><br><span class="line"><span class="keyword">case</span> .lzfse: streamAlgorithm = <span class="type">COMPRESSION_LZFSE</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// set the stream operation and flags</span></span><br><span class="line"><span class="keyword">let</span> streamOperation: compression_stream_operation</span><br><span class="line"><span class="keyword">let</span> flags: <span class="type">Int32</span></span><br><span class="line"><span class="keyword">switch</span> operation &#123;</span><br><span class="line"><span class="keyword">case</span> .compression:</span><br><span class="line">  streamOperation = <span class="type">COMPRESSION_STREAM_ENCODE</span></span><br><span class="line">  flags = <span class="type">Int32</span>(<span class="type">COMPRESSION_STREAM_FINALIZE</span>.rawValue)</span><br><span class="line"><span class="keyword">case</span> .decompression:</span><br><span class="line">  streamOperation = <span class="type">COMPRESSION_STREAM_DECODE</span></span><br><span class="line">  flags = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是将你的Swift类型转换成压缩算法所需要的C类型。接下来，用下面代码替换<code>return nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1: create a stream</span></span><br><span class="line"><span class="keyword">var</span> streamPointer = <span class="type">UnsafeMutablePointer</span>&lt;compression_stream&gt;.allocate(capacity: <span class="number">1</span>)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">  streamPointer.deallocate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2: initialize the stream</span></span><br><span class="line"><span class="keyword">var</span> stream = streamPointer.pointee</span><br><span class="line"><span class="keyword">var</span> status = compression_stream_init(&amp;stream, streamOperation, streamAlgorithm)</span><br><span class="line"><span class="keyword">guard</span> status != <span class="type">COMPRESSION_STATUS_ERROR</span> <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">  compression_stream_destroy(&amp;stream)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3: set up a destination buffer</span></span><br><span class="line"><span class="keyword">let</span> dstSize = workingBufferSize</span><br><span class="line"><span class="keyword">let</span> dstPointer = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">UInt8</span>&gt;.allocate(capacity: dstSize)</span><br><span class="line"><span class="keyword">defer</span> &#123;</span><br><span class="line">  dstPointer.deallocate()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span> <span class="comment">// To be continued</span></span><br></pre></td></tr></table></figure>

<p>这里发生的事情：</p>
<ol>
<li>给<code>compression_stream</code>类型分配内存空间，并在defer代码块中对内存空间进行释放。</li>
<li>然后使用pointee属性获取流并将它传递给<code>compression_stream_init</code>方法。这里编译器会做一些特殊的事情：编译器通过<code>&amp;</code>获取到<code>compression_stream</code>类型，并将它转换成<code>UnsafeMutablePointer&lt;compression_stream&gt;</code>。另外，你也可以直接把<code>streamPointer</code>传递进入，这样就不需要这种特别的转换了。</li>
<li>最后，你需要创建一个目标缓冲区来替换中间缓冲区。</li>
</ol>
<p>下面，你需要用如下代码替换<code>return nil</code>：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="comment">// process the input</span></span><br><span class="line"><span class="keyword">return</span> input.withUnsafeBytes &#123; srcRawBufferPointer <span class="keyword">in</span></span><br><span class="line">  <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> output = <span class="type">Data</span>()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">let</span> srcBufferPointer = srcRawBufferPointer.bindMemory(to: <span class="type">UInt8</span>.<span class="keyword">self</span>)</span><br><span class="line">  <span class="keyword">guard</span> <span class="keyword">let</span> srcPointer = srcBufferPointer.baseAddress <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br><span class="line">  stream.src_ptr = srcPointer</span><br><span class="line">  stream.src_size = input.<span class="built_in">count</span></span><br><span class="line">  stream.dst_ptr = dstPointer</span><br><span class="line">  stream.dst_size = dstSize</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">while</span> status == <span class="type">COMPRESSION_STATUS_OK</span> &#123;</span><br><span class="line">    <span class="comment">// process the stream</span></span><br><span class="line">    status = compression_stream_process(&amp;stream, flags)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// collect bytes from the stream and reset</span></span><br><span class="line">    <span class="keyword">switch</span> status &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_OK</span>:</span><br><span class="line">      <span class="comment">// 4</span></span><br><span class="line">      output.append(dstPointer, <span class="built_in">count</span>: dstSize)</span><br><span class="line">      stream.dst_ptr = dstPointer</span><br><span class="line">      stream.dst_size = dstSize</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_ERROR</span>:</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">      </span><br><span class="line">    <span class="keyword">case</span> <span class="type">COMPRESSION_STATUS_END</span>:</span><br><span class="line">      <span class="comment">// 5</span></span><br><span class="line">      output.append(dstPointer, <span class="built_in">count</span>: stream.dst_ptr - dstPointer)</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="built_in">fatalError</span>()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里是真正实现压缩的地方，代码实现是这样的：</p>
<ol>
<li>创建一个存储输出结果的Data数据类型——到底是压缩还是解压缩的结果取决于操作类型是什么。</li>
<li>使用分配内存空间的指针和大小设置源缓冲区和目标缓冲区。</li>
<li>当<code>status == COMPRESSION_STATUS_OK</code>时候，一直调用<code>compression_stream_process</code>方法。</li>
<li>然后将目标缓冲区内容拷贝到output中。</li>
<li>当<code>statue == COMPRESSION_STATUS_END</code>时候，说明这是最后一个数据包，你可能只需要拷贝最后一个数据包的一部分。</li>
</ol>
<p>这个例子中，你能看到，一个包含1000个元素的数组被压缩成153字节。效果还不错。</p>
<h1 id="不安全的Swift例2：随机数生成器"><a href="#不安全的Swift例2：随机数生成器" class="headerlink" title="不安全的Swift例2：随机数生成器"></a>不安全的Swift例2：随机数生成器</h1><p>随机数在很出程序中都有应用，从游戏到机器学习。</p>
<p>macOS提供了arc4random，它会产生加密的随机数。不幸的是，在Linux中并不支持这种方法，此外，arc4random只能提供UInt32类型的随机数。不过<em>/dev/urandom</em>能够提供不受源限制的随机数。</p>
<p>本节中，你将会使用你新学到的知识阅读这个文件并创建类型安全的随机数。</p>
<p><img src="http://img.weidongfang.online/imgbed/hexdump-480x202.png" alt="hexdump"></p>
<p>创建一个新的playground，可以叫做<em>RandomNumbers</em>，或者打开你下载的playground。</p>
<p>创建项目时候确保你选择的是macOS。然后使用如下代码替换文件中内容：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Foundation</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">RandomSource</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> file = fopen(<span class="string">"/dev/urandom"</span>, <span class="string">"r"</span>)!</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">let</span> queue = <span class="type">DispatchQueue</span>(label: <span class="string">"random"</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="keyword">func</span> <span class="title">get</span><span class="params">(<span class="built_in">count</span>: Int)</span></span> -&gt; [<span class="type">Int8</span>] &#123;</span><br><span class="line">    <span class="keyword">let</span> capacity = <span class="built_in">count</span> + <span class="number">1</span> <span class="comment">// fgets adds null termination</span></span><br><span class="line">    <span class="keyword">var</span> data = <span class="type">UnsafeMutablePointer</span>&lt;<span class="type">Int8</span>&gt;.allocate(capacity: capacity)</span><br><span class="line">    <span class="keyword">defer</span> &#123;</span><br><span class="line">      data.deallocate()</span><br><span class="line">    &#125;</span><br><span class="line">    queue.sync &#123;</span><br><span class="line">      fgets(data, <span class="type">Int32</span>(capacity), file)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Array</span>(<span class="type">UnsafeMutableBufferPointer</span>(start: data, <span class="built_in">count</span>: <span class="built_in">count</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你将file变量声明成静态类型，所以系统中只会存在一个。当进程退出的时候，系统会自动关闭这个文件。</p>
<p>由于多个线程可能同时访问获取随机数的方法，你需要使用串行GCD队列来保护生成器代码。</p>
<p><code>get</code>方法是实际生成随机数的地方。</p>
<p>首先创建超出你所需范围的未分配的内存空间，因为<code>fget</code>总是以0结尾。</p>
<p>然后再GCD串行队列中获取文件中的数据。</p>
<p>最后，将data数据拷贝到一个能够像序列一样操作的<code>UnsafeMutableBufferPointer</code>中，随后再转换成标准的数组。</p>
<p>现在为止，这只会为你提供安全的方法获取Int8数组，你还需要扩展它。</p>
<p>将如下代码添加到你的playground中：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">BinaryInteger</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">var</span> randomized: <span class="type">Self</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> numbers = <span class="type">RandomSource</span>.<span class="keyword">get</span>(<span class="built_in">count</span>: <span class="type">MemoryLayout</span>&lt;<span class="type">Self</span>&gt;.size)</span><br><span class="line">    <span class="keyword">return</span> numbers.withUnsafeBufferPointer &#123; bufferPointer <span class="keyword">in</span></span><br><span class="line">      <span class="keyword">return</span> bufferPointer.baseAddress!.withMemoryRebound(</span><br><span class="line">        to: <span class="type">Self</span>.<span class="keyword">self</span>,</span><br><span class="line">        capacity: <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> $<span class="number">0</span>.pointee</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Int8</span>.randomized</span><br><span class="line"><span class="type">UInt8</span>.randomized</span><br><span class="line"><span class="type">Int16</span>.randomized</span><br><span class="line"><span class="type">UInt16</span>.randomized</span><br><span class="line"><span class="type">Int16</span>.randomized</span><br><span class="line"><span class="type">UInt32</span>.randomized</span><br><span class="line"><span class="type">Int64</span>.randomized</span><br><span class="line"><span class="type">UInt64</span>.randomized</span><br></pre></td></tr></table></figure>

<p>以上代码给所有遵守<code>BinaryInteger</code>协议的子类型添加了一个获取随机数属性。如果你想了解更多关于协议的用法，可以查看另一个教程<a href="https://www.raywenderlich.com/148448/introducing-protocol-oriented-programming" target="_blank" rel="noopener">面向协议编程</a>。</p>
<p>首先，你获取到随机数数组，然后将Int8类型的值绑定到所需要的类型上去，并返回充绑定的这个拷贝。</p>
<p>就这样，现在你可以使用不安全的Swift安全的生成随机数。</p>
<h1 id="接下来怎么做"><a href="#接下来怎么做" class="headerlink" title="接下来怎么做"></a>接下来怎么做</h1><p>这里有几篇关于不安全Swift用法的教程：</p>
<ol>
<li><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0107-unsaferawpointer.md" target="_blank" rel="noopener">Swift Evolution 0107: UnsafeRawPointer API</a> 给出了Swift内存模型的详细概述，并使阅读API文档更容易理解。</p>
</li>
<li><p><a href="https://github.com/apple/swift-evolution/blob/master/proposals/0138-unsaferawbufferpointer.md" target="_blank" rel="noopener">Swift Evolution 0138: UnsafeRawBufferPointer API</a> 广泛谈论了如何使用无类型的内存，并连接到可从使用无类型内存受益的开源项目。</p>
</li>
<li><p><a href="https://developer.apple.com/documentation/swift/imported_c_and_objective-c_apis" target="_blank" rel="noopener">Imported C and Objective-C APIs</a> 剖析Swift如何与C交互。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【译】优化签名流程——为编译提速</title>
    <url>/posts/2020-12/83620274.html</url>
    <content><![CDATA[<p>原文链接：<a href="https://eisel.me/signing" target="_blank" rel="noopener">https://eisel.me/signing</a> </p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>不管你的项目使用的是增量编译还是全量编译，代码签名所占用时间都是相同的。App体积越大签名时间也越长，因此，签名有时候会成为你编译耗时的瓶颈。这里有几个可以减少代码签名耗时的技巧，严格的说，这些技巧并没有文档记录可考证，在将来也有可能被禁用，但是也有大公司在使用，目前并没有发现明显的劣势。</p>
<p><strong>注意</strong>：这些技巧只能用于开发环境。</p>
<p><strong>注意</strong>：请查看代码签名的耗时，即你能够节省的时间，并确定这些时间对你来说是否重要。</p>
<a id="more"></a>



<h2 id="加快签名速度技巧"><a href="#加快签名速度技巧" class="headerlink" title="加快签名速度技巧"></a>加快签名速度技巧</h2><h3 id="加快哈希算法速度"><a href="#加快哈希算法速度" class="headerlink" title="加快哈希算法速度"></a>加快哈希算法速度</h3><p>最简单的、风险最小的技巧是更改签名哈希算法。Xcode默认使用<code>SHA-256</code>进行代码签名，我们可以把它改成更快的<code>SHA-1</code>算法，只需在Xcode的<code>build settings --&gt; Other Code Signing Flags</code>增加编译选项<code>--digest-algorithm=sha1</code>即可。你觉得SHA-1不够安全？在某些情况下，确实如此，不过在个人调试版本中你可能并不关心签名安全问题。</p>
<h3 id="资源规则"><a href="#资源规则" class="headerlink" title="资源规则"></a>资源规则</h3><p>现在我们已经加快了哈希算法速度，接下来我们将试着减少需要被哈希加密的文件数量。资源规则实际上是说，我们可以通过提供一个plist文件，告诉签名程序那些文件需要被签名，那些可以被忽略。由于签名过程中有很大一部分时间都花费在签名bubdle中二进制文件，而苹果似乎主要关心的是可执行文件是否签名，所以我们可以提供一个资源规则，告诉签名程序，除了可执行文件，其它文件都不需要签名。plist可以这么写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot; &quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span><br><span class="line">&lt;plist version=&quot;1.0&quot;&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">       &lt;key&gt;rules&lt;/key&gt;</span><br><span class="line">       &lt;dict&gt;</span><br><span class="line">               &lt;key&gt;.*&lt;/key&gt;</span><br><span class="line">               &lt;false/&gt;</span><br><span class="line">       &lt;/dict&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure>

<p>将plist放到你项目的某个目录中，然后在Xcode的<code>build settings --&gt; Other Code Signing Flags</code>中添加一一个flag：<code>--resource-rules=&lt;path to the plist&gt;</code>。虽然这个flag在iOS7中被废弃了，但是在Xcode11、Xcode12中还是有效的。这里还有另一种方法，不需要使用被废弃的flag，但是需要做更多的工作，所以不推荐使用。这种方法中，首先你需要创建一个临时空目录<code>MyApp.app</code>，然后将编译好的二进制可执行文件拷贝到这个目录中，最后对这个目录进行签名，并把签名后的可执行文件拷贝到原来的位置。因为签名的包中只包含一个可执行文件，因此这里只会对可执行文件签名而忽略其他所有文件。</p>
<h3 id="模拟器签名提速技巧"><a href="#模拟器签名提速技巧" class="headerlink" title="模拟器签名提速技巧"></a>模拟器签名提速技巧</h3><p>上面的两个技巧减少签名时间的同时，保留了签名的功能。在模拟器上有另一个技巧。这个技巧唯一的缺点是可能会破坏App组关系和其它权限信息（大部分权限，例如钥匙串、苹果登陆不受影响）。如果想使用这种方法，你就不需要使用前面两个技巧了，因为前面两个技巧的配置并不能为此方法提速。背景：签名过程包括计算哈希值并存储某个位置、权限信息写入到可执行文件中。由于大部分API只会检查二进制文件中是否包含权限信息，并且模拟器似乎并不关系可执行文件是否被签名过，所以我们可以自己将权限信息注入到可执行文件中。</p>
<p>如何像代码签名那样注入权限信息：</p>
<ul>
<li>使用<code>xcrun segedit &lt;path to simulator binary&gt; -extract __TEXT __entitlements -</code>查看签名程序注入到可执行文件中的权限信息。</li>
<li>比较你在Xcode中配置的权限信息和签名程序注入的权限信息，看看是如何进行转换的（可能只是环境变量的替换）</li>
<li>在编译阶段，自己用脚本做这样的转换。</li>
<li>在<em>Other Linker Flags</em>中添加 <code>-Wl,-sectcreate,__TEXT,__entitlements,&lt;the processed entitlements file path&gt;</code> ，这样我们就能将自己转换的授权信息注入到可执行文件的<code>__entitlements</code>中了。（系统签名程序做了同样的事情）</li>
<li>在<code>.xcconfig</code>中配置<code>CODE_SIGNING_ALLOWED = NO</code> ，这样就能禁用Xcode的代码签名步骤了。</li>
</ul>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>通过以上几个步骤，可以改善你调试模式下的签名时间。由于这些技巧算是取巧，所以如果遇到任何问题可以在推特上告诉我。苹果的签名工具效率低的令人发指，使用的是单线程而不是多线程。希望未来苹果或者其它开源项目能够优化一下。如果你真的想要深入理解代码签名，推荐阅读《<em>MacOS and iOS Internals, Volume III</em>》。</p>
<p><em>特别感谢Milen Dzhumerov和Keith Smiley在本文中给我的帮助。</em></p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【译】SwiftUI中常见的8个错误以及解决方案</title>
    <url>/posts/2020-11/2dya62uis2.html</url>
    <content><![CDATA[<blockquote>
<p>原文：<a href="https://www.hackingwithswift.com/articles/224/common-swiftui-mistakes-and-how-to-fix-them" target="_blank" rel="noopener">8 Common SwiftUI Mistakes - and how to fix them</a></p>
<p>作者：<a href="https://www.hackingwithswift.com/about" target="_blank" rel="noopener">Paul Hudson</a>  2020/10/9   twitter：<a href="https://twitter.com/twostraws" target="_blank" rel="noopener">@twostraws</a></p>
<p>翻译：韦东方</p>
</blockquote>
<img src="https://www.hackingwithswift.com/uploads/swiftui.jpg" style="width:1000%">

<blockquote>
<p>用更少的代码做更多的事情。</p>
</blockquote>
<p>SwiftUI是一个大型的、复杂的框架，也是一个非常有意思的框架，不过对于初学者很多地方都很容易出错。这篇文章我将介绍8个初学者常犯的错误，以及其解决方案。</p>
<p>有些错误实际上是误解，因为SwiftUI是如此的复杂，某些细节上很容易造成误解。另外一些错误是由于对SwiftUI工作原理理解不够透彻，或者思维习惯还留在UIKit时代而造成的。例如有时候你会花费大量的时间写视图和修饰器，而没有预留足够的时间去简化最终的代码。</p>
<a id="more"></a>

<p>在我们深入讲解每个问题之前，先来看看这8个问题都是什么吧！</p>
<ol>
<li>添加不必要的视图和装饰器；</li>
<li>在需要使用<code>@StateObject</code>的地方使用了<code>@ObservedObject</code>；</li>
<li>使用错误的修饰器顺序；</li>
<li>在包装属性上添加属性监听器；</li>
<li>当需要绘制边框时绘制了形状；</li>
<li>使用可选类型数据绑定alerts和sheets；</li>
<li>试图获取当前SwiftUI试图的背景试图；</li>
<li>使用无效的范围创建动态视图。</li>
</ol>
<h2 id="1-添加不必要的视图和装饰器"><a href="#1-添加不必要的视图和装饰器" class="headerlink" title="1.添加不必要的视图和装饰器"></a>1.添加不必要的视图和装饰器</h2><p>我们从一个最常见的写很多多余代码的例子开始讲。之所以这样，部分原因是我们解决问题时候会编写大量的代码，但是随后很容易忘记清理。也有一部分原因是在你编码SwiftUI代码时候很容易陷入以往的思维模式中，特别是当你之前用过UIKit或者其他的UI框架时候，更容易犯错。</p>
<p>第一个例子，让你用一个红色的矩形填充满整个屏幕，你会怎么做？你可能会这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Rectangle</span>()</span><br><span class="line">    .fill(<span class="type">Color</span>.red)</span><br></pre></td></tr></table></figure>

<p>说实话上面的代码能够很好的达到期望的效果。但是有一大半的代码都是多余的，实际上你可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br></pre></td></tr></table></figure>

<p>这是因为，所有SwiftUI的颜色和形状都自动遵守了<code>View</code>协议，所以你可以把它们当成View来使用。</p>
<p>在裁剪形状时候你可能会看到这样的代码，因为提到裁剪我们首先想到的就是<code>clipShape()</code>函数，例如我们可以用clipShape()函数来裁剪我们的红色矩形，代码如下：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br><span class="line">    .clipShape(<span class="type">RoundedRectangle</span>(cornerRadius: <span class="number">50</span>))</span><br></pre></td></tr></table></figure>

<p>但是你完全可以写的更简单点，你可以使用<code>cornerRadius()</code>这个修饰器来简化你的代码，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Color</span>.red</span><br><span class="line">    .cornerRadius(<span class="number">50</span>)</span><br></pre></td></tr></table></figure>

<p>删除这些多余的代码是需要时间的，不过更重要的是你需要改变你的思维模式。当然，在你刚开始学习SwiftUI时候这些是比较难的，所以，如果你一直在用较长版本的代码也不要感到气馁。</p>
<h2 id="2-在需要使用-StateObject的地方使用了-ObservedObject"><a href="#2-在需要使用-StateObject的地方使用了-ObservedObject" class="headerlink" title="2.在需要使用@StateObject的地方使用了@ObservedObject"></a>2.在需要使用<code>@StateObject</code>的地方使用了<code>@ObservedObject</code></h2><p>SwiftUI提供许多属性装饰器来帮我们建立响应式的用户界面，这里有三个是最重要的：<code>@State</code>、<code>@StateObject</code>、 <code>@ObservedObject</code>。熟悉这几个装饰器分别在什么场景下使用是非常重要的，如果用错的话可能会导致很多的问题。</p>
<p>第一个是最简单的：<code>@State</code>，当你的View有一个值类型的属性时候，就应该使用这个修饰器。所以，整数类型、字符串、数组等等都优先使用<code>@State</code>。</p>
<p>但是另外两个修饰器不太容易区分，你可能见过这样的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DataModel</span>: <span class="title">ObservableObject</span> </span>&#123;</span><br><span class="line">    @<span class="type">Published</span> <span class="keyword">var</span> username = <span class="string">"@twostraws"</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">ObservedObject</span> <span class="keyword">var</span> model = <span class="type">DataModel</span>()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(model.username)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><em>这是一个错误的示范，这样的代码很容易引起错误。</em></p>
<p>就像前面说的那样，<code>@State</code>意味着一个值类型被当前视图拥有，这里的重点是<strong>拥有</strong>。所以，上面所示代码应该使用<code>StateObject</code>，因为这里的state意味着”这是被当前视图持有的“。</p>
<p>所以，它应该是这样的：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line">@<span class="type">StateObject</span> model = <span class="type">DataModel</span>()</span><br></pre></td></tr></table></figure>

<p>当你用<code>@ObservedObject</code>来修饰一个新创建的对象时，你的视图并不持有这个对象，这就意味着这个对象可能在任何时候被销毁掉。并且，这样的错误并不是必现的，所以你可能以为你的代码是没有任何问题的，仅仅是偶然情况下会出错。</p>
<p>这里你应该牢记于心的是：<code>@State</code>、<code>@StateObject</code>意味着“视图拥有数据”，但是其他的修饰器诸如<code>@ObservedObject</code> 、 <code>@EnvironmentObject</code>都意味着“视图不拥有数据”。</p>
<h2 id="3-使用错误的修饰器顺序"><a href="#3-使用错误的修饰器顺序" class="headerlink" title="3.使用错误的修饰器顺序"></a>3.使用错误的修饰器顺序</h2><p>SwiftUI中修饰器的顺序是非常重要的，错误的组合顺序不仅会导致错误的布局效果，并且也会降低性能。</p>
<p>这里有一个经典的错误使用边距和背景色的例子，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br><span class="line">    .padding()</span><br></pre></td></tr></table></figure>

<p>由于我们先设置了背景色，后设置边距，所以，效果是背景色仅仅显示在文本周围，而边距部分并不会被设置背景色。如果你想让边距和文本背景色都是绿色，你需要这么做：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .padding()    </span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br></pre></td></tr></table></figure>

<p>当你试图调整视图位置时，这会变得更有意思。</p>
<p>例如，当你用<code>offset()</code>改变一个已经渲染的视图位置，但是却没有改变视图实际尺寸。这就意味着，在<code>offset()</code>之后应用的修饰器并不知道发生了移动。</p>
<p>试试下面代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .offset(x: <span class="number">15</span>, y: <span class="number">15</span>)</span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="http://img.weidongfang.online/imgbed20201112132222.png" style="margin-left:0px">

<br>

<p>你会发现文本发生了偏移，但是背景色却没有。现在试试交换<code>offse()</code>和<code>background()</code>的位置：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br><span class="line">    .offset(x: <span class="number">15</span>, y: <span class="number">15</span>)</span><br></pre></td></tr></table></figure>

<p>现在你会发现，文本和背景都发生了偏移。</p>
<p>另一种选择是<code>position()</code>，这个modifier会改变视图在父视图上渲染的位置，但是前提是你需要使用一个自适应布局进行一层包装。</p>
<p>试试下面的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br><span class="line">    .position(x: <span class="number">150</span>, y: <span class="number">150</span>)</span><br></pre></td></tr></table></figure>

<p>你会发现背景颜色紧紧包裹着文本，整个文本紧贴着父视图的左上角。现在交换<code>background()</code> 和 <code>position()</code>的位置试试：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .position(x: <span class="number">150</span>, y: <span class="number">150</span>)</span><br><span class="line">    .background(<span class="type">Color</span>.green)</span><br></pre></td></tr></table></figure>

<p>现在你会发现整个视图都变成绿色的了。强调一下，使用<code>position()</code>需要先用一个自适应布局包裹文本视图（Text view），自适应布局将会自动占据所有可用的空间。所以，当我们设置绿色时候，整个视图都会变成绿色。</p>
<p>之所以会出现这样的现象，是因为大多数的修饰器都会创建新的视图 - 就是说，当你应用一个position或者background color时候，会创建新的视图并将应用这个修饰器的视图包裹起来。这将带来很大的好处，这样的话我们就能在一个视图上应用同一个modifier多次，例如添加多个边距和背景：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(Color.green)</span><br><span class="line">    .padding()</span><br><span class="line">    .background(Color.blue)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="http://img.weidongfang.online/imgbed20201112193345.png" style="width:30%;margin-left:0px">

<p>或者是应用多个阴影以创建密集阴影效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Text(&quot;Hello, World!&quot;)</span><br><span class="line">    .font(.largeTitle)</span><br><span class="line">    .foregroundColor(.white)</span><br><span class="line">    .shadow(color: .black, radius: 10)</span><br><span class="line">    .shadow(color: .black, radius: 10)</span><br><span class="line">    .shadow(color: .black, radius: 10)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="http://img.weidongfang.online/imgbed20201115144151.png" style="width:30%;margin-left:0px">

<h2 id="4-在包装属性上添加属性监听器"><a href="#4-在包装属性上添加属性监听器" class="headerlink" title="4.在包装属性上添加属性监听器"></a>4.在包装属性上添加属性监听器</h2><p>某些情况下，你可能需要给一个包装属性添加观察器，例如<code>didSet</code>，但是通常情况下并不能达到预期的效果。</p>
<p>例如，当你使用slider时候，你可能想要在滑块位置变化时候做些事情，你可能会这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span> &#123;</span><br><span class="line">        <span class="keyword">didSet</span> &#123;</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">"Rating changed to \(rating)"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Slider</span>(value: $rating)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然而，在你滑动slider时候<code>didSet</code>并没有执行，这是因为rating值直接被绑定器修改掉了，而不是每次都创建新的值。</p>
<p>SwiftUI本身可以使用onChange()修饰器，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Slider</span>(value: $rating)</span><br><span class="line">            .onChange(of: rating) &#123; value <span class="keyword">in</span></span><br><span class="line">                <span class="built_in">print</span>(<span class="string">"Rating changed to \(value)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过，我更喜欢用稍微不同的方法：我会创建一个Binding的类别，然后在类别方法对包装值做一层封装，然后在setter方法中把新值传给回调方法：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">Binding</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">onChange</span><span class="params">(<span class="number">_</span> handler: @escaping <span class="params">(Value)</span></span></span> -&gt; <span class="type">Void</span>) -&gt; <span class="type">Binding</span>&lt;<span class="type">Value</span>&gt; &#123;</span><br><span class="line">        <span class="type">Binding</span>(</span><br><span class="line">            <span class="keyword">get</span>: &#123; <span class="keyword">self</span>.wrappedValue &#125;,</span><br><span class="line">            <span class="keyword">set</span>: &#123; newValue <span class="keyword">in</span></span><br><span class="line">                <span class="keyword">self</span>.wrappedValue = newValue</span><br><span class="line">                handler(newValue)</span><br><span class="line">            &#125;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了它，我们就可以把回调直接绑定到slider上了。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rating = <span class="number">0.0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Slider</span>(value: $rating.onChange(sliderChanged))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">sliderChanged</span><span class="params">(<span class="number">_</span> value: Double)</span></span> &#123;</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">"Rating changed to \(value)"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>你喜欢哪种方法就用哪种方法！</p>
<h2 id="5-当需要绘制边框时绘制了形状"><a href="#5-当需要绘制边框时绘制了形状" class="headerlink" title="5.当需要绘制边框时绘制了形状"></a>5.当需要绘制边框时绘制了形状</h2><p>这是一个很简单的但是很多人会犯的错：没弄清楚<code>stroke()</code> 和 <code>strokeBorder()</code>。当你绘制一个大的图形时候可能会犯这个错，例如这个：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .stroke(<span class="type">Color</span>.red, lineWidth: <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>请注意，为什么看不到圆的左右边缘？这是因为<code>stroke()</code>这个修饰器会将视图边缘作为边框的中心，所以，20个点的红色边框，在左右边缘将有10个点在边框内，10个点在边框外，所以你看不到完整的左右边缘。</p>
<p>相比之下，<code>strokeBorder()</code>将会把把所有的点绘制在边缘内，所以它绘制的形状绝不会大于边框：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .strokeBorder(<span class="type">Color</span>.red, lineWidth: <span class="number">20</span>)</span><br></pre></td></tr></table></figure>

<p>但是 <code>stroke()</code> 有一个<code>strokeBorder()</code>不具备的优势，当你在使用stroke时候，<code>stroke()</code>将会返回一个新的形状而不是新的视图。这能让你创建其它方式无法创建的的效果，例如，绘制一个形状两次：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Circle</span>()</span><br><span class="line">    .stroke(style: <span class="type">StrokeStyle</span>(lineWidth: <span class="number">20</span>, dash: [<span class="number">10</span>]))</span><br><span class="line">    .stroke(style: <span class="type">StrokeStyle</span>(lineWidth: <span class="number">20</span>, dash: [<span class="number">10</span>]))</span><br><span class="line">    .frame(width: <span class="number">280</span>, height: <span class="number">280</span>)</span><br></pre></td></tr></table></figure>

<p>效果：</p>
<img src="http://img.weidongfang.online/imgbed20201112202532.png" style="width:60%;margin-left:0px">

<h2 id="6-使用可选类型数据绑定alerts和sheets"><a href="#6-使用可选类型数据绑定alerts和sheets" class="headerlink" title="6.使用可选类型数据绑定alerts和sheets"></a>6.使用可选类型数据绑定alerts和sheets</h2><p>当你想要展示一个选项菜单时候，最简单的方法就是把一个选项菜单绑定到一个布尔类型上，如下所示：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span>: <span class="title">Identifiable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> id: <span class="type">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedUser: <span class="type">User?</span></span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> showingAlert = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Show Alert"</span>) &#123;</span><br><span class="line">                selectedUser = <span class="type">User</span>(id: <span class="string">"@twostraws"</span>)</span><br><span class="line">                showingAlert = <span class="literal">true</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .alert(isPresented: $showingAlert) &#123;</span><br><span class="line">            <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Hello, \(selectedUser!.id)"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码能够很好的工作，并且很容易理解。但是，一旦你迈过了初学者的门槛，你就应该考虑替换掉其中的可选类型，在去掉布尔值的同时也可以去掉强解包。唯一要做的是，你提供的被观察者必须遵守<code>Identifiable</code>协议。</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> selectedUser: <span class="type">User?</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">Button</span>(<span class="string">"Show Alert"</span>) &#123;</span><br><span class="line">                selectedUser = <span class="type">User</span>(id: <span class="string">"@twostraws"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        .alert(item: $selectedUser) &#123; user <span class="keyword">in</span></span><br><span class="line">            <span class="type">Alert</span>(title: <span class="type">Text</span>(<span class="string">"Hello, \(user.id)"</span>))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这会让你的代码更加容易阅读和书写，同时也避免了某些情况下强解包可能带来的错误。</p>
<h2 id="7-试图获取当前SwiftUI试图的背景试图"><a href="#7-试图获取当前SwiftUI试图的背景试图" class="headerlink" title="7. 试图获取当前SwiftUI试图的背景试图"></a>7. 试图获取当前SwiftUI试图的背景试图</h2><p>使用SwiftUI过程中，人们遇到最常见的问题是他们试图改变一个视图背后的视图。通常会出现如下所示的代码：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">            .background(<span class="type">Color</span>.red)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码会呈现一个白色的大背景，上面是一个被红色背景紧紧包裹的文本。而很多人想要的可能是整个红色的大背景，所以他们开始向上查找SwiftUI背后的视图对应UIKit中的什么视图，以便对其进行修改。</p>
<p>现在，在你的SwiftUI代码背后绝对有一个UIKit的视图：实际上是一个叫<code>UIHostingController</code>的UIKit控制器，和其它控制器类似的控制器。一旦你开始进入UIkit领域进行操作，则可能会导致SwiftUI表现异常，或者在无法使用UIKit的平台上遇到问题。</p>
<p>相反，如果你想让你的视图扩展填充满整个背景视图，你可以这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Text</span>(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .frame(maxWidth: .infinity, maxHeight: .infinity)</span><br><span class="line">    .background(<span class="type">Color</span>.red)</span><br><span class="line">    .ignoresSafeArea()</span><br></pre></td></tr></table></figure>

<h2 id="8-使用无效的范围创建动态视图"><a href="#8-使用无效的范围创建动态视图" class="headerlink" title="8.使用无效的范围创建动态视图"></a>8.使用无效的范围创建动态视图</h2><p>有几个SwiftUI的初始化器允许我们传入范围，这将会让我们很容易创建多种视图样式。</p>
<p>例如，如果我们想要创建一个包含4个元素的列表，我们可能这么写：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ContentView</span>: <span class="title">View</span> </span>&#123;</span><br><span class="line">    @<span class="type">State</span> <span class="keyword">private</span> <span class="keyword">var</span> rowCount = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> body: some <span class="type">View</span> &#123;</span><br><span class="line">        <span class="type">VStack</span> &#123;</span><br><span class="line">            <span class="type">List</span>(<span class="number">0</span>..&lt;rowCount) &#123; row <span class="keyword">in</span></span><br><span class="line">                <span class="type">Text</span>(<span class="string">"Row \(row)"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码能够正常运行，不过当你想要在运行时改变范围时候就会出现问题。如上代码所示，我用<code>@State</code>标记<code>rowCount</code>是可变的，所以我们可以在<code>Vstack</code>顶部添加一个按钮，点击时候做+1操作：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">Button</span>(<span class="string">"Add Row"</span>) &#123;</span><br><span class="line">    rowCount += <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">.padding(.top)</span><br></pre></td></tr></table></figure>

<p>如果你运行上面代码你会发现，点击按钮时候Xcode调试窗口会输出警告信息，视图上没发生任何变化 - 点击不起任何作用。</p>
<p>为了解决这个问题，你可以使用<code>Identifiable</code>协议或者提供一个特殊的id操作，以便让SwiftUI知道这里的范围会随着时间推移发生变化：</p>
<figure class="highlight swift"><table><tr><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">0</span>..&lt;rowCount, id: \.<span class="keyword">self</span>) &#123; row <span class="keyword">in</span></span><br><span class="line">    <span class="type">Text</span>(<span class="string">"Row \(row)"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有了这些之后，代码才能预期效果。</p>
]]></content>
      <categories>
        <category>翻译</category>
      </categories>
  </entry>
  <entry>
    <title>【逆】逆向分析实践-钉钉打卡/钉钉签到/钉钉定位/远程打卡功能</title>
    <url>/posts/2020-02/42423.html</url>
    <content><![CDATA[<blockquote>
<p>本文内容仅为iOS逆向技术研究，请勿用作非法用途。</p>
</blockquote>
<p>在家隔离的日子过得还是比较漫长的，每天宅在家里，吃饭睡觉写代码挺无聊的。因为笔者所在公司使用钉钉打卡，于是钉钉便成了笔者本次逆向练习的目标😏。</p>
<a id="more"></a>

<h1 id="1-脱壳"><a href="#1-脱壳" class="headerlink" title="1. 脱壳"></a>1. 脱壳</h1><p>笔者比较习惯使用AloneMonkey重写的<a href>dumpdecrypted</a>进行脱壳操作，只需将目标app的BundleIdentifity写入plist即可，是真的香。无奈平时使用的ios8.4越狱机留在公司了，而手边只有一个iOS12.4的越狱机（dumpdecrypted在笔者iOS12.4不好使），因此只能换种方式了。</p>
<p>这次脱壳使用了lldb的方式，lldb脱壳的原理是：将运行中的app数据部分拷贝到电脑上，然后将加密的mach-o文件也拷贝到电脑上，最后将从ios系统内存拷贝的mach-o数据部分拼接到加密的mach-o文件对应的部分，再将mach-o的<code>cryptid</code>改成0即可。</p>
<p>网上关于lldb脱壳的博客还是比较多的，这里不再赘述。</p>
<h1 id="2-工具"><a href="#2-工具" class="headerlink" title="2.工具"></a>2.工具</h1><ol>
<li>MacBook Pro，iOS12.4 6s越狱机。</li>
<li>pc端工具：otool、class-dump、Xcode、lldb、vscode、lipo、reveal。</li>
<li>iOS端工具：钉钉、debugserver。</li>
</ol>
<h1 id="3-分析"><a href="#3-分析" class="headerlink" title="3. 分析"></a>3. 分析</h1><p>打开App，使用reveal查看<strong>签到</strong>页面，我们发现，这个页面的控制器叫<code>DTWebViewController</code>，打开这个类的头文件，并没有发现任何与location/coordinate相关的方法和属性。</p>
<p>想到在正向开发中，一般都会有一个地理位置管理的类型，于是在所有头文件中搜索<code>locationmanager</code>，这次搜索到的结果就比较多了，引起我注意的有两个类，<code>AMapLocationManager</code>和<code>DTALocationManager</code>。</p>
<p>DTALocationManager应该就是整个钉钉中用于位置管理的类型了，DTALocationManager头文件部分代码如下所示:</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DTALocationManager</span> : <span class="title">NSObject</span> &lt;<span class="title">AMapLocationManagerDelegate</span>, <span class="title">DTLocationManager</span>&gt;</span></span><br><span class="line">&#123;</span><br><span class="line">    AMapLocationManager *_locationManager;</span><br><span class="line">    <span class="keyword">double</span> _dt_distanceFilter;</span><br><span class="line">    <span class="keyword">double</span> _dt_desiredAccuracy;</span><br><span class="line">    _Bool _dt_pausesLocationUpdatesAutomatically;</span><br><span class="line">    _Bool _dt_allowBackgroundLocationUpdates;</span><br><span class="line">    <span class="keyword">id</span> &lt;DTLocationManagerDelegate&gt; _dt_delegate;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) <span class="keyword">double</span> dt_desiredAccuracy; <span class="comment">// @synthesize dt_desiredAccuracy=_dt_desiredAccuracy;</span></span><br><span class="line"><span class="keyword">@property</span>(<span class="keyword">nonatomic</span>) __<span class="keyword">weak</span> <span class="keyword">id</span> &lt;DTLocationManagerDelegate&gt; dt_delegate; <span class="comment">// @synthesize dt_delegate=_dt_delegate;</span></span><br><span class="line"></span><br><span class="line">- (<span class="keyword">void</span>)amapLocationManager:(<span class="keyword">id</span>)arg1 didUpdateLocation:(<span class="keyword">id</span>)arg2;</span><br><span class="line">- (<span class="keyword">void</span>)amapLocationManager:(<span class="keyword">id</span>)arg1 didFailWithError:(<span class="keyword">id</span>)arg2;</span><br><span class="line">- (<span class="keyword">id</span>)locationManager;</span><br><span class="line"><span class="keyword">@end</span></span><br></pre></td></tr></table></figure>

<p>既然DTALocationManager是通过AMapLocationManager进行定位的，那么我们就直接hook AMapLocationManager就可以了。</p>
<p>通过查看分析AMapLocationManager头文件，我们发现了这个方法<code>- (void)locationManager:(id)arg1 didUpdateLocations:(id)arg2;</code>，使用theos建立tweak工程，hook <code>locationManager:didUpdateLocation:</code>，指定自己想要的坐标，运行，成功！</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="meta">#import <span class="meta-string">&lt;CoreLocation/CoreLocation.h&gt;</span></span></span><br><span class="line">%hook AMapLocationManager</span><br><span class="line">- (<span class="keyword">void</span>)locationManager:(<span class="keyword">id</span>)arg1 didUpdateLocations:(<span class="keyword">id</span>)arg2 &#123; </span><br><span class="line">	<span class="keyword">double</span> latitude = <span class="number">39.135972</span>;</span><br><span class="line">	<span class="keyword">double</span> longitude = <span class="number">117.261949</span>;</span><br><span class="line">	<span class="built_in">CLLocation</span> *location = [[<span class="built_in">CLLocation</span> alloc]initWithLatitude:latitude longitude:longitude];</span><br><span class="line">    %orig(arg1, @[location]);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>怎么也没想到逆向钉钉的定位功能这么简单😂。</p>
<h1 id="4-优化"><a href="#4-优化" class="headerlink" title="4. 优化"></a>4. 优化</h1><h2 id="4-1-签到-gt-地点微调页面"><a href="#4-1-签到-gt-地点微调页面" class="headerlink" title="4.1 签到&gt;地点微调页面"></a>4.1 签到&gt;地点微调页面</h2><p>经过上一步的操作，签到页面和打卡页面已经能够展示我们期望的目标地理位置了，但是我们发现签<code>到&gt;地点微调</code>页面还是当前真实的地理位置。</p>
<p>经过分析我们发现，地址微调使用的地理位置是由<code>MAMapView</code>类提供的，于是乎，使用应用在<code>AMapLocationManager</code>相同的方式hook完美解决这个问题。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">%hook MAMapView</span><br><span class="line">- (<span class="keyword">void</span>)locationManager:(<span class="keyword">id</span>)arg1 didUpdateLocations:(<span class="keyword">id</span>)arg2 &#123; </span><br><span class="line">	<span class="keyword">double</span> latitude = <span class="number">39.135972</span>;</span><br><span class="line">	<span class="keyword">double</span> longitude = <span class="number">117.261949</span>;</span><br><span class="line">	<span class="built_in">CLLocation</span> *location = [[<span class="built_in">CLLocation</span> alloc]initWithLatitude:latitude longitude:longitude];</span><br><span class="line">    %orig(arg1, @[location]);</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<h2 id="4-2-输入并保存任意坐标"><a href="#4-2-输入并保存任意坐标" class="headerlink" title="4.2 输入并保存任意坐标"></a>4.2 输入并保存任意坐标</h2><p>在<strong>工作</strong>菜单栏页面添加修改定位的按钮，点击可以修改成你想要的位置。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">DTWorkWebViewController</span></span></span><br><span class="line">- (<span class="keyword">void</span>)presentViewController:(<span class="built_in">UIViewController</span> *)viewControllerToPresent animated: (<span class="built_in">BOOL</span>)flag completion:(<span class="keyword">void</span> (^ __<span class="keyword">nullable</span>)(<span class="keyword">void</span>))completion;</span><br><span class="line">- (<span class="keyword">void</span>)addModifyLocationItem;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">UINavigationItem</span> *navigationItem;</span><br><span class="line"><span class="keyword">@property</span> <span class="built_in">UIView</span> *view;</span><br><span class="line"><span class="keyword">@end</span></span><br><span class="line"></span><br><span class="line">%hook DTWorkWebViewController</span><br><span class="line"><span class="comment">//修改打卡经纬度alert弹窗以及保存目标坐标</span></span><br><span class="line">%new</span><br><span class="line">- (<span class="keyword">void</span>)modifyLocation &#123;</span><br><span class="line">    <span class="built_in">UIAlertController</span> *alert = [<span class="built_in">UIAlertController</span> alertControllerWithTitle:<span class="string">@"请输入自定义经纬度"</span> message:<span class="literal">nil</span> preferredStyle:<span class="built_in">UIAlertControllerStyleAlert</span>];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *cancelAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"取消"</span> style:<span class="built_in">UIAlertActionStyleCancel</span> handler:<span class="literal">nil</span>];</span><br><span class="line">    <span class="built_in">UIAlertAction</span> *confirmAction = [<span class="built_in">UIAlertAction</span> actionWithTitle:<span class="string">@"确认"</span> style:<span class="built_in">UIAlertActionStyleDefault</span> handler:^(<span class="built_in">UIAlertAction</span> * _Nonnull action) &#123;</span><br><span class="line">        <span class="built_in">NSString</span> *latitute = alert.textFields[<span class="number">0</span>].text;</span><br><span class="line">        <span class="built_in">NSString</span> *longtitute = alert.textFields[<span class="number">1</span>].text;</span><br><span class="line">        <span class="keyword">if</span> (latitute != <span class="literal">nil</span> &amp;&amp; longtitute != <span class="literal">nil</span>) &#123;</span><br><span class="line">            <span class="built_in">NSString</span> *customLocation = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%@,%@"</span>, latitute, longtitute];</span><br><span class="line">            [[<span class="built_in">NSUserDefaults</span> standardUserDefaults] setObject:customLocation forKey:<span class="string">@"custom_user_location"</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addTextFieldWithConfigurationHandler:^(<span class="built_in">UITextField</span> * _Nonnull textField) &#123;</span><br><span class="line">        textField.placeholder = <span class="string">@"请输入纬度"</span>;</span><br><span class="line">		textField.keyboardType = <span class="built_in">UIKeyboardTypeNumbersAndPunctuation</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    [alert addTextFieldWithConfigurationHandler:^(<span class="built_in">UITextField</span> * _Nonnull textField) &#123;</span><br><span class="line">        textField.placeholder = <span class="string">@"请输入经度"</span>;</span><br><span class="line">		textField.keyboardType = <span class="built_in">UIKeyboardTypeNumbersAndPunctuation</span>;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [alert addAction:cancelAction];</span><br><span class="line">    [alert addAction:confirmAction];</span><br><span class="line">    [<span class="keyword">self</span> presentViewController:alert animated:<span class="literal">true</span> completion:<span class="literal">nil</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加修改地理位置坐标的按钮</span></span><br><span class="line">%new</span><br><span class="line">- (<span class="keyword">void</span>)addModifyLocationItem &#123;</span><br><span class="line">	<span class="built_in">UIButton</span> *modifyBtn = [<span class="built_in">UIButton</span> buttonWithType:<span class="built_in">UIButtonTypeCustom</span>];</span><br><span class="line">    modifyBtn.frame = <span class="built_in">CGRectMake</span>(<span class="number">6</span>, <span class="number">6</span>, <span class="number">80</span>, <span class="number">35</span>);</span><br><span class="line">	[modifyBtn setTitleColor:<span class="built_in">UIColor</span>.redColor forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [modifyBtn setTitle:<span class="string">@"修改定位"</span> forState:<span class="built_in">UIControlStateNormal</span>];</span><br><span class="line">    [modifyBtn addTarget:<span class="keyword">self</span> action:<span class="keyword">@selector</span>(modifyLocation) forControlEvents:<span class="built_in">UIControlEventTouchUpInside</span>];</span><br><span class="line">    [<span class="keyword">self</span>.view addSubview:modifyBtn];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hook并添加修改位置按钮</span></span><br><span class="line">- (<span class="keyword">void</span>)viewDidLoad &#123;</span><br><span class="line">	%orig;</span><br><span class="line">	[<span class="keyword">self</span> addModifyLocationItem];</span><br><span class="line">&#125;</span><br><span class="line">%end</span><br></pre></td></tr></table></figure>

<p>修改地理位置效果如下图所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/IMG_0007.PNG" alt></p>
<p>完整的tweak代码可以<a href="/resource/files/dingtalktweak.zip">点这里</a>下载。</p>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>【逆】如何将App打包成deb安装包</title>
    <url>/posts/2020-01/9045.html</url>
    <content><![CDATA[<blockquote>
<p>我们通过Cydia只能安装deb格式的插件，无法直接安装ipa。如果我们想要在Cydia发布应用程序类型的插件，那么必须将App打包成deb才能进行发布。</p>
</blockquote>
<a id="more"></a>

<h1 id="1-创建目录结构"><a href="#1-创建目录结构" class="headerlink" title="1. 创建目录结构"></a>1. 创建目录结构</h1><p><strong>1）</strong>创建deb工程目录：<code>PackageDeb</code>。</p>
<p><strong>2）</strong>在<code>PackageDeb</code>目录下新建两个目录：<code>DEBIAN</code>和<code>Applications</code>。</p>
<p><strong>3）</strong>在<code>DEBIAN</code>下创建<code>control</code>文件。</p>
<p>control文件的配置如下所示：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">Package: net.exchen.test			  <span class="comment">#应用包名</span></span><br><span class="line">Name: 应用名称									 <span class="comment">#应用名称</span></span><br><span class="line">Version: <span class="number">0.0</span>.<span class="number">1</span>		 						  <span class="comment">#deb安装包的版本号</span></span><br><span class="line">Description: 描述								 <span class="comment">#deb的描述，会展示的cydia相关问题</span></span><br><span class="line">Section: 分类										 <span class="comment">#deb分类</span></span><br><span class="line">Depends: firmware (&gt;= <span class="number">8.0</span>)			<span class="comment">#描述最低支持版本号</span></span><br><span class="line">Priority: optional</span><br><span class="line">Architecture: iphoneos-arm			<span class="comment">#cup类型</span></span><br><span class="line">Author: walden									<span class="comment">#作者				</span></span><br><span class="line">Homepage: https://blog.weidongfang.online  <span class="comment">#主页</span></span><br><span class="line">Icon: file:///app/icon/path			<span class="comment">#图标的位置</span></span><br><span class="line"><span class="keyword">Maintainer</span>: walden							<span class="comment">#维护人</span></span><br></pre></td></tr></table></figure>

<p>关于control文件的更多描述信息可以参考<a href="https://www.debian.org/doc/debian-policy/ch-controlfields.html" target="_blank" rel="noopener">官方网站</a>。</p>
<p><strong>4）</strong>使用xcode打开你想要打包的app项目，选择目标设备编译一下，将Product中生成app文件拷贝到<code>Applications</code>文件夹。</p>
<h1 id="2-安装dpkg"><a href="#2-安装dpkg" class="headerlink" title="2. 安装dpkg"></a>2. 安装dpkg</h1><p><code>dpkg</code>是<strong>Debian</strong>软件包管理器的基础，被用于软件的安装、更新和移除。这里我们需要使用dpkg将我们构建的目录打包成deb文件。</p>
<p>如果你的电脑上找不到dpkg命令，请直接下载即可：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> brew dpkg</span></span><br></pre></td></tr></table></figure>

<h1 id="3-打包"><a href="#3-打包" class="headerlink" title="3. 打包"></a>3. 打包</h1><p>我们需要切换到<code>PackageDeb</code>目录的上层目录进行打包：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">➜  downloads$ cd PackageDeb</span><br><span class="line">➜  PackageDeb$ cd ..</span><br><span class="line">➜  downloads$ dpkg-deb -b PackageDeb TargetApplication.deb</span><br><span class="line">dpkg-deb: building package 'con.walden.testdeb' in 'TargetApplication.deb'.</span><br></pre></td></tr></table></figure>

<h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h1><p>使用任何你喜欢的方式安装生成的deb文件即可。iFile、Filza、dpkg命令、AutoInstall等等等。</p>
<h1 id="5-sh脚本打包"><a href="#5-sh脚本打包" class="headerlink" title="5. sh脚本打包"></a>5. sh脚本打包</h1><p>为了简化上述步骤，笔者写了一个简单的sh脚本，你只需按照脚本提示一步一步执行即可成功打包。如果需要可以<a href="/downloads/packageDEB.sh">点这里</a>下载。</p>
<p>执行sh脚本：</p>
<ol>
<li>使用Terminal进入sh脚本所在目录，执行:<code>sh  脚本文件名</code>即可。</li>
<li>进入sh脚本所在目录，赋予sh文件可执行权限：<code>chmod +x 脚本文件名</code>，执行脚本：<code>./脚本文件名</code>。</li>
</ol>
<blockquote>
<p>注意：</p>
<p>1.如果安装后桌面看不到App图标，刷新UI即可：<code>uicache</code>。</p>
</blockquote>
]]></content>
      <categories>
        <category>逆向</category>
      </categories>
  </entry>
  <entry>
    <title>《如何做好一场技术演讲》— 学习与总结</title>
    <url>/posts/2021-06/6350866.html</url>
    <content><![CDATA[<p>演讲和当众讲话是每个人都无法避免的事情，也是当今世界非常重要的个人技能。纵然你有天纵之才，你也需要表达出来，别人才能够知道，表达出来你才会有更多的机会和资源表现自己，实现自己。TED掌门人克里斯安德森曾说，<strong>无论今天公众演讲有多么重要，未来只会更加重要。</strong></p>
<a id="more"></a>

<p><strong>演讲前的焦虑和紧张</strong></p>
<p>演讲前的焦虑和紧张实际上是普遍存在非常正常的一件事。我个人是一个偏内向一点的人，从小就不擅长在很多人面前讲话，演讲前的焦虑和紧张也是我非常恐惧的一件事。曾经我以为演讲前的焦虑和恐惧是内向人专属的心理，读完这系列文章之后才知道，焦虑和恐惧是所有人都有的心理。就连我崇拜的乔布斯，演讲之神乔布斯在演讲前也会紧张，更何况是我们普通人了。文章中有提到一个小调查，统计人们最恐惧的事情，排名第一的竟然不是死亡，而是当众讲话。由此可见，面对当众讲话的焦虑和紧张是大家都有的事情，个人完全不必为自己的焦虑和紧张感到害羞或者不自信之类的。当然，也有很多方法可以帮助我们缓解焦虑，充分的准备，建立演讲的自信我想是其中最重要的。</p>
<p><strong>演讲的主线</strong></p>
<p>演讲的主线就是说你是按照什么思路去表达你的观点，说服听众相信你的观点。一个好的主线能够让你的演讲更有意思，能够让听众听到他们想听的东西，给听众带来价值，这样你的演讲才有价值。</p>
<p>演讲最重要的是主题，首先必须明确你演讲的主题是什么。然后分析你的听众组成，了解他们想听什么，通过你的演讲，能够给听众带来什么东西，学习到什么东西。对于技术类的演讲主线可以按照这个固定的模式：Who-What&amp;When-Why-How-Future-Recap。（这里不再展开赘述，详情可参考脑图）</p>
<p>个人认为，不同的演讲目的，不同的场合可以使用不同的主线，模式是死的，但是在不同场景也是需要变通的。没有最好的演讲主线，只有最合适的演讲主线，选择自己认为最合理的演讲主线即可。</p>
<p>使用演讲主线的好处。演讲主线能够让你的演讲更加清晰明白，层层递进，可以让听众更容易理解你讲的东西；按照主线的逻辑顺序表达自己的思路，也能提醒演讲者接下来的演讲内容，按照逻辑顺序不容易遗忘演讲内容，更好的将内容讲清楚。</p>
<p><strong>逐字稿</strong></p>
<p>曾几何时，我以为逐字稿是我这样不擅长当众讲话的人专属的工具，这系列文章却告诉我逐字稿是所有人的工具。很早之前，在需要当众讲话的场景我都会自己准备逐字稿，看到别人不需要准备逐字稿而信口拈来甚是羡慕，现在看来，或许只是别人的逐字稿没有被我看到而已。</p>
<p>到底需要不需要准备逐字稿，要看演讲的场景和个人需要。如果是非常正式的，非常重要的演讲场合，比如代表公司参加技术演讲，苹果公司的产品发布会，稍有疏忽就可能造成重大影响的演讲场合，逐字稿是一定要准备的，并且需要不断的练习，每一个微笑、语气都需要慎重的选择，彩排也是必要的。如果个人非常不擅长演讲，不擅长当众讲话，就像我这样，逐字稿在演讲中也是必要的，思索书写逐字稿的过程其实也是帮助你思考的过程，能让你对演讲内容更加熟练，上台后不容易磕巴。</p>
<p>逐字稿可以用来练习，但是不适合在台上逐字背诵。逐字稿在帮助记忆演讲内容和练习效果上有很大的帮助，但是妄想在台上逐字背诵就会让演讲效果大打折扣。因为演讲中最重要的是人，不仅仅是你说的话，更是你的每一个表情、每一个语调、每一个眼神，如果你背诵的话，就会导致大脑用更多的时间去搜索记忆，忽略了你的表演，让演讲效果大打折扣。</p>
<p><strong>演讲中的姿态</strong></p>
<p>演讲过程中的手势和表情其实也是演讲非常重要的组成部分。不同的音调、手势、表情能够帮助你传达不同的思想，让听众更容易理解你演讲的重点。很多人不知道在演讲中应该做什么样的动作，什么样的表情，只是直直的站在那里说话，这样的演讲效果肯定是比较差的。</p>
<p>演讲中的姿态实际上是有套路的，对于大多数平常人来讲，切西瓜就能应付90%以上的场合。伸出手臂，摊开手掌，让手掌与地面垂直，然后小幅上下挥动。如下所示：</p>
<p><img src="http://img.weidongfang.online/imgbed/20210601143847.png" alt></p>
<p>演讲中语言和声音控制也是有技巧的，<strong>这里的核心技巧就是：没有技巧。</strong> <strong>让你的情感告诉你最合适的肢体语言和声音和表情是什么</strong>，用心体会他们，然后记住他们、反复练习，然后在演讲中表达出来即可。</p>
<p><strong>小结</strong></p>
<p>要说学习这个课程给我最大的帮助什么，我想就是帮我<strong>正确认识演讲的焦虑和紧张</strong>。每次当众说话之前我都会焦虑和紧张，需要在开始之前在脑海里反复的预演，思考如何串联自己想要表达的内容，这一度让我觉得我是一个胆小怕事没有表达能力的人。通过学习课程才认识到我遇到的问题可能是很多人都遇到过的问题，这其实能够给我很大的自信。一个课程如果能够让人学到一件事情，学习就是有价值的，但这个课程让我学到了很多，可以讲是物超所值，推荐在当众讲话和演讲上有疑问的人都看一下。</p>
<p><br>下面是个人总结的脑图：</p>
<p><img src="http://img.weidongfang.online/imgbed/%E5%A6%82%E4%BD%95%E5%81%9A%E5%A5%BD%E4%B8%80%E5%9C%BA%E6%8A%80%E6%9C%AF%E6%BC%94%E8%AE%B2.svg" alt></p>
<p>脑图: <a href="https://github.com/Dev-Dongfang/FileArchive/blob/master/Learning/Xminds/极客时间-如何做好一场技术演讲.xmind" target="_blank" rel="noopener">Github - 极客时间-如何做好一场技术演讲.xmind)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/28488602" target="_blank" rel="noopener">我们为什么要演讲？ - 知乎 (zhihu.com)</a></p>
]]></content>
      <categories>
        <category>极客时间</category>
      </categories>
  </entry>
</search>
